{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.\\_]+"},"docs":[{"location":"","text":"This is a landing page, you can not add Markdown content directly. Configure the landing page using meta tags in the header: --- title: Page title description: Page description hide: - toc - navigation illustration: assets/illustrations/undraw_completed_steps_re_h9wc.svg links: - link: link-url/ title: Link title profiles: - link: url title: title text: this can be a multiline text image: asset path ---","title":"GoQuorum Enterprise Ethereum Client"},{"location":"support/","text":"GoQuorum support \u00b6 Need help on using GoQuorum? Ask our community or request paid support. Professional support (paid) \u00b6 ask our ConsenSys Quorum support team for a professional subscription. Professional support detail Paid subscription (yearly or monthly) SLAs Support level choice (Gold, Bronze, Silver) Business hours worldwide coverage Community support (free) \u00b6 Discord read more on ConsenSys Quorum site create an issue on the repository . Community support detail Free, no subscription Community led 24/7 worldwide coverage","title":"Support"},{"location":"support/#goquorum-support","text":"Need help on using GoQuorum? Ask our community or request paid support.","title":"GoQuorum support"},{"location":"support/#professional-support-paid","text":"ask our ConsenSys Quorum support team for a professional subscription. Professional support detail Paid subscription (yearly or monthly) SLAs Support level choice (Gold, Bronze, Silver) Business hours worldwide coverage","title":"Professional support (paid)"},{"location":"support/#community-support-free","text":"Discord read more on ConsenSys Quorum site create an issue on the repository . Community support detail Free, no subscription Community led 24/7 worldwide coverage","title":"Community support (free)"},{"location":"concepts/account-management/","text":"Account/key management \u00b6 Cryptographic keys are an essential component of a GoQuorum network. GoQuorum uses keys to create digital signatures which verify a sender\u2019s identity and prevent message tampering. The Privacy Manager uses keys to encrypt private transaction data. Both GoQuorum and the Privacy Manager use user-provided asymmetric key pairs. Each key pair consists of a public key and a private key. The public key can be shared freely, but the private key should never be shared . GoQuorum derives the account address from the public key by taking the last 20 bytes of its keccak256 hash The Privacy Manager uses the public key as an identifier for the target nodes of a private transaction (that is the privateFor transaction field) Key management determines how GoQuorum and Tessera store and use private keys.","title":"Account management"},{"location":"concepts/account-management/#accountkey-management","text":"Cryptographic keys are an essential component of a GoQuorum network. GoQuorum uses keys to create digital signatures which verify a sender\u2019s identity and prevent message tampering. The Privacy Manager uses keys to encrypt private transaction data. Both GoQuorum and the Privacy Manager use user-provided asymmetric key pairs. Each key pair consists of a public key and a private key. The public key can be shared freely, but the private key should never be shared . GoQuorum derives the account address from the public key by taking the last 20 bytes of its keccak256 hash The Privacy Manager uses the public key as an identifier for the target nodes of a private transaction (that is the privateFor transaction field) Key management determines how GoQuorum and Tessera store and use private keys.","title":"Account/key management"},{"location":"concepts/architecture/","text":"Architecture \u00b6 The following diagram outlines the GoQuorum high-level architecture. Differences from geth \u00b6 GoQuorum is a lightweight fork of geth. GoQuorum is updated as geth releases occur. GoQuorum includes the following changes to geth: Consensus is achieved with the Istanbul BFT , QBFT , or Raft consensus protocols instead of proof of work. The P2P layer is changed to only allow connections between permissioned nodes. The block generation logic is changed to replace the global state root check with a global public state root check. The block validation logic is changed to replace the global state root in the block header with the global public state root . The State Patricia trie is split into two: a public state trie and a private state trie . Block validation logic is changed to handle private transactions . Transaction creation is changed to allow for replacing transaction data with encrypted hashes to preserve private data where required. The pricing of gas is removed. Gas itself remains. For more information about the GoQuorum architecture and its differences from geth, contact us on GoQuorum support .","title":"Architecture"},{"location":"concepts/architecture/#architecture","text":"The following diagram outlines the GoQuorum high-level architecture.","title":"Architecture"},{"location":"concepts/architecture/#differences-from-geth","text":"GoQuorum is a lightweight fork of geth. GoQuorum is updated as geth releases occur. GoQuorum includes the following changes to geth: Consensus is achieved with the Istanbul BFT , QBFT , or Raft consensus protocols instead of proof of work. The P2P layer is changed to only allow connections between permissioned nodes. The block generation logic is changed to replace the global state root check with a global public state root check. The block validation logic is changed to replace the global state root in the block header with the global public state root . The State Patricia trie is split into two: a public state trie and a private state trie . Block validation logic is changed to handle private transactions . Transaction creation is changed to allow for replacing transaction data with encrypted hashes to preserve private data where required. The pricing of gas is removed. Gas itself remains. For more information about the GoQuorum architecture and its differences from geth, contact us on GoQuorum support .","title":"Differences from geth"},{"location":"concepts/free-gas-network/","text":"Free gas networks \u00b6 GoQuorum is a free gas network, which means there\u2019s no gas price. Transactions use computational resources, so they have associated costs. Gas is the cost unit and gas price is the price per gas unit. The transaction cost is the gas used multiplied by the gas price. In public Ethereum networks, the account submitting the transaction pays the transaction cost, in Ether. The miner (or validator, in proof of authority networks) that includes the transaction in a block receives the transaction cost. In many private networks, including GoQuorum, network participants run the validators and don\u2019t require gas as an incentive. Networks that don\u2019t require gas as an incentive usually remove gas price or configure the gas price to be zero (that is, free gas). Some private networks might allocate Ether and use a non-zero gas price to limit resource use. In free gas networks, the gas price is zero but transactions still use gas, so the transaction cost (gas used multiplied by the gas price) is zero. In GoQuorum, gas price is completely removed. Gas price is not included as a transaction object parameter in GoQuorum privacy API methods . When using standard Ethereum JSON-RPC methods such as sendSignedTransaction , you must set gasPrice to 0. Tip We use the term free gas network to refer to a network with a gas price of zero. A network with a gas price of zero is also known as a zero gas network or no gas network .","title":"Free gas network"},{"location":"concepts/free-gas-network/#free-gas-networks","text":"GoQuorum is a free gas network, which means there\u2019s no gas price. Transactions use computational resources, so they have associated costs. Gas is the cost unit and gas price is the price per gas unit. The transaction cost is the gas used multiplied by the gas price. In public Ethereum networks, the account submitting the transaction pays the transaction cost, in Ether. The miner (or validator, in proof of authority networks) that includes the transaction in a block receives the transaction cost. In many private networks, including GoQuorum, network participants run the validators and don\u2019t require gas as an incentive. Networks that don\u2019t require gas as an incentive usually remove gas price or configure the gas price to be zero (that is, free gas). Some private networks might allocate Ether and use a non-zero gas price to limit resource use. In free gas networks, the gas price is zero but transactions still use gas, so the transaction cost (gas used multiplied by the gas price) is zero. In GoQuorum, gas price is completely removed. Gas price is not included as a transaction object parameter in GoQuorum privacy API methods . When using standard Ethereum JSON-RPC methods such as sendSignedTransaction , you must set gasPrice to 0. Tip We use the term free gas network to refer to a network with a gas price of zero. A network with a gas price of zero is also known as a zero gas network or no gas network .","title":"Free gas networks"},{"location":"concepts/multi-tenancy/","text":"Multi-tenancy via multiple private states \u00b6 In a typical GoQuorum network, each participant (tenant) uses its own GoQuorum and Tessera node. Tessera can be configured to manage multiple key pairs owned by one tenant. This model is costly to run and scale as more tenants join the network. Use multi-tenancy via multiple private states (MPS) to allow multiple tenants to use the same GoQuorum node, with each tenant having its own private state(s). Each tenant can perform all operations (create, read, and write) on any contract in its private state, and a single tenant can have access to multiple private states . Multi-tenancy provides a user experience similar to a user running their own managed node. The public state remains publicly available to all tenants, and private states are logically separated. Architecture \u00b6 In this example architecture, an organization represents a tenant with multiple departments, and users within the departments. Each tenant operates on its own private state. Each user in an organization owns one or more privacy manager key pairs that allow them to operate on their organization\u2019s private state. A network operator administers entitlements and private state access for each organization using the authorization server. JSON-RPC security features are used to manage a user\u2019s access to a private state. The authorization server controls this access. Network topology \u00b6 A network can consist of multi-tenant nodes and single-tenant nodes. One or more independent authorization servers can be used to protect multi-tenant nodes, but one multi-tenant node can only be protected by one authorization server. Enterprise authorization server \u00b6 To support multi-tenancy, you must configure an authorization server, such as ORY Hydra or Okta . The authorization server can grant private state access to clients via a private state identifier (PSI) . Access token scope \u00b6 The JSON-RPC security plugin enables the geth JSON-RPC API server to be an OAuth2-compliant resource server. A client must first obtain a pre-authenticated access token from an authorization server, then present the access token (using an Authorization HTTP request header) when calling an API. Calls to the GoQuorum API without an authenticated token are rejected. The value of the scope encoded in an access token (in case of JWT), or Introspection response (in the case of the OAuth2 Token Introspection API) contains the RPC scope and tenant scope, which has the following URL-based syntax: \"psi://[PSI]?self.eoa=0x0&node.eoa=0x0\" In the syntax, PSI is the URL-encoded value of the PSI. For example, for a client that has access to two private states PS1 and PS2 , an authorization server operator sets up and grants the following scopes to the client: \"psi://PS1?self.eoa=0x0&node.eoa\" \"psi://PS2?self.eoa=0x0&node.eoa\" A client presenting an access token containing these scopes has full access (read/write/create) to private contracts on private states PS1 and PS2 using any Ethereum accounts. Multiple private states \u00b6 Multiple private states (MPS) is a feature that allows a GoQuorum node to manage more than one private state. This functionality lays the foundation for multi-tenancy. If running GoQuorum version 21.4.1 or earlier or Tessera version 21.1.1 or earlier, upgrade your existing nodes to enable MPS . Private state identifier \u00b6 A private state is identified by a sequence of bytes, referred to as the PSI (private state identifier). The PSI is used to determine the specific private state a user can operate on. Trie of private states \u00b6 A trie of private states keeps track of all private states managed by a node. The PSI is the key in the trie that maps to the root hash of the corresponding private state. At each block: All affected private states are updated and their new root hashes are calculated. The trie is updated with the new private state root hashes at their PSIs. A new root of the trie of private states is calculated and mapped to the public block hash. Private state manager \u00b6 The GoQuorum private state manager resolves the PSI based on input parameters. Any RPC API call must be accompanied by a PSI or authorization token. From the token, the private state manager derives the private state the user is attempting to access. Tessera resident groups \u00b6 MPS uses Tessera resident groups to map tenants to private states. During Tessera startup, residentGroups are validated to check each Tessera key is part of a single resident group. Every Tessera key must be in a resident group for Tessera to start. During GoQuorum startup, the residentGroups are retrieved from Tessera and kept in memory in GoQuorum. Tessera Q2T communication changes \u00b6 The /groups/resident QT2 endpoint returns the resident groups defined in Tessera. This endpoint is invoked at GoQuorum startup to retrieve all resident groups. These details are kept in memory in GoQuorum, so the private state manager can resolve these resident groups to the corresponding private state. Accessing a private state \u00b6 Users must specify the private state they wish to operate on. For backwards compatibility, if a user connects without specifying the private state, the default private identifier is used. If a private state is not configured, the user operates on an empty read-only private state. In order of precedence, users have the following three options to specify a private state to operate on: URL parameter. PSI query parameter can be added to the API URI: geth attach http://localhost:22000/?PSI = PS1 HTTP header. Every RPC request must have an HTTP header \u201cPSI\u201d attached that specifies the private state to use. IPC and inproc connections. Prepend the PSI to the ID field of the jsonrpcMessage . Accessing a private state using web3j \u00b6 To access a private state using web3j , specify the query parameter in the URL when initializing the HttpService . If you have authentication enabled you must specify a bearer token in the Authorization header. HttpService service = new HttpService ( \"https://secure_endpoint?PSI=$PSI\" ); service . addHeader ( \"Authorization\" , \"bearer $accessToken\" ); quorum = Quorum . build ( service );","title":"Multi-tenancy"},{"location":"concepts/multi-tenancy/#multi-tenancy-via-multiple-private-states","text":"In a typical GoQuorum network, each participant (tenant) uses its own GoQuorum and Tessera node. Tessera can be configured to manage multiple key pairs owned by one tenant. This model is costly to run and scale as more tenants join the network. Use multi-tenancy via multiple private states (MPS) to allow multiple tenants to use the same GoQuorum node, with each tenant having its own private state(s). Each tenant can perform all operations (create, read, and write) on any contract in its private state, and a single tenant can have access to multiple private states . Multi-tenancy provides a user experience similar to a user running their own managed node. The public state remains publicly available to all tenants, and private states are logically separated.","title":"Multi-tenancy via multiple private states"},{"location":"concepts/multi-tenancy/#architecture","text":"In this example architecture, an organization represents a tenant with multiple departments, and users within the departments. Each tenant operates on its own private state. Each user in an organization owns one or more privacy manager key pairs that allow them to operate on their organization\u2019s private state. A network operator administers entitlements and private state access for each organization using the authorization server. JSON-RPC security features are used to manage a user\u2019s access to a private state. The authorization server controls this access.","title":"Architecture"},{"location":"concepts/multi-tenancy/#network-topology","text":"A network can consist of multi-tenant nodes and single-tenant nodes. One or more independent authorization servers can be used to protect multi-tenant nodes, but one multi-tenant node can only be protected by one authorization server.","title":"Network topology"},{"location":"concepts/multi-tenancy/#enterprise-authorization-server","text":"To support multi-tenancy, you must configure an authorization server, such as ORY Hydra or Okta . The authorization server can grant private state access to clients via a private state identifier (PSI) .","title":"Enterprise authorization server"},{"location":"concepts/multi-tenancy/#access-token-scope","text":"The JSON-RPC security plugin enables the geth JSON-RPC API server to be an OAuth2-compliant resource server. A client must first obtain a pre-authenticated access token from an authorization server, then present the access token (using an Authorization HTTP request header) when calling an API. Calls to the GoQuorum API without an authenticated token are rejected. The value of the scope encoded in an access token (in case of JWT), or Introspection response (in the case of the OAuth2 Token Introspection API) contains the RPC scope and tenant scope, which has the following URL-based syntax: \"psi://[PSI]?self.eoa=0x0&node.eoa=0x0\" In the syntax, PSI is the URL-encoded value of the PSI. For example, for a client that has access to two private states PS1 and PS2 , an authorization server operator sets up and grants the following scopes to the client: \"psi://PS1?self.eoa=0x0&node.eoa\" \"psi://PS2?self.eoa=0x0&node.eoa\" A client presenting an access token containing these scopes has full access (read/write/create) to private contracts on private states PS1 and PS2 using any Ethereum accounts.","title":"Access token scope"},{"location":"concepts/multi-tenancy/#multiple-private-states","text":"Multiple private states (MPS) is a feature that allows a GoQuorum node to manage more than one private state. This functionality lays the foundation for multi-tenancy. If running GoQuorum version 21.4.1 or earlier or Tessera version 21.1.1 or earlier, upgrade your existing nodes to enable MPS .","title":"Multiple private states"},{"location":"concepts/multi-tenancy/#private-state-identifier","text":"A private state is identified by a sequence of bytes, referred to as the PSI (private state identifier). The PSI is used to determine the specific private state a user can operate on.","title":"Private state identifier"},{"location":"concepts/multi-tenancy/#trie-of-private-states","text":"A trie of private states keeps track of all private states managed by a node. The PSI is the key in the trie that maps to the root hash of the corresponding private state. At each block: All affected private states are updated and their new root hashes are calculated. The trie is updated with the new private state root hashes at their PSIs. A new root of the trie of private states is calculated and mapped to the public block hash.","title":"Trie of private states"},{"location":"concepts/multi-tenancy/#private-state-manager","text":"The GoQuorum private state manager resolves the PSI based on input parameters. Any RPC API call must be accompanied by a PSI or authorization token. From the token, the private state manager derives the private state the user is attempting to access.","title":"Private state manager"},{"location":"concepts/multi-tenancy/#tessera-resident-groups","text":"MPS uses Tessera resident groups to map tenants to private states. During Tessera startup, residentGroups are validated to check each Tessera key is part of a single resident group. Every Tessera key must be in a resident group for Tessera to start. During GoQuorum startup, the residentGroups are retrieved from Tessera and kept in memory in GoQuorum.","title":"Tessera resident groups"},{"location":"concepts/multi-tenancy/#tessera-q2t-communication-changes","text":"The /groups/resident QT2 endpoint returns the resident groups defined in Tessera. This endpoint is invoked at GoQuorum startup to retrieve all resident groups. These details are kept in memory in GoQuorum, so the private state manager can resolve these resident groups to the corresponding private state.","title":"Tessera Q2T communication changes"},{"location":"concepts/multi-tenancy/#accessing-a-private-state","text":"Users must specify the private state they wish to operate on. For backwards compatibility, if a user connects without specifying the private state, the default private identifier is used. If a private state is not configured, the user operates on an empty read-only private state. In order of precedence, users have the following three options to specify a private state to operate on: URL parameter. PSI query parameter can be added to the API URI: geth attach http://localhost:22000/?PSI = PS1 HTTP header. Every RPC request must have an HTTP header \u201cPSI\u201d attached that specifies the private state to use. IPC and inproc connections. Prepend the PSI to the ID field of the jsonrpcMessage .","title":"Accessing a private state"},{"location":"concepts/multi-tenancy/#accessing-a-private-state-using-web3j","text":"To access a private state using web3j , specify the query parameter in the URL when initializing the HttpService . If you have authentication enabled you must specify a bearer token in the Authorization header. HttpService service = new HttpService ( \"https://secure_endpoint?PSI=$PSI\" ); service . addHeader ( \"Authorization\" , \"bearer $accessToken\" ); quorum = Quorum . build ( service );","title":"Accessing a private state using web3j"},{"location":"concepts/network-and-chain-id/","text":"Network and chain ID \u00b6 An Ethereum network is run using a network ID and a chain ID. The network ID is a property of a peer, not of the chain the peer is managing. Network ID is passed in via the command line by --networkid <id> . Its purpose is to separate peers that are running under a different network ID. You cannot sync with anyone who is running a node with a different network ID. However, since it is trivial to change this, it is a less secure version of GoQuorum\u2019s --permissioned flag, and it only used for simple segregation. The chain ID is a property of the chain managed by the node. It is used for replay protection of transactions. Setting the chain ID has the effect of changing one of the parameters of a transaction, namely the V parameter. The v parameter is set to 2*ChainID + 35/36 . For the Ethereum Mainnet, which has a chain ID of 1 , this means that all transactions have a value of either 37 or 38 . The chain ID set in the genesis configuration file, in the config section, and is only used when the block number is above the one set at eip155Block . See the GoQuorum example genesis files for an example. It can be changed as many times as needed while the chain is below the eip155Block number and re-rerunning geth init - this will not delete or modify any current sync process or saved blocks. In GoQuorum, transactions are considered private if the v parameter is set to 37 or 38 , which clashes with networks which have a Chain ID of 1 . For this reason, GoQuorum will not run using chain ID 1 and will immediately quit if started with such a configuration.","title":"Network and chain ID"},{"location":"concepts/network-and-chain-id/#network-and-chain-id","text":"An Ethereum network is run using a network ID and a chain ID. The network ID is a property of a peer, not of the chain the peer is managing. Network ID is passed in via the command line by --networkid <id> . Its purpose is to separate peers that are running under a different network ID. You cannot sync with anyone who is running a node with a different network ID. However, since it is trivial to change this, it is a less secure version of GoQuorum\u2019s --permissioned flag, and it only used for simple segregation. The chain ID is a property of the chain managed by the node. It is used for replay protection of transactions. Setting the chain ID has the effect of changing one of the parameters of a transaction, namely the V parameter. The v parameter is set to 2*ChainID + 35/36 . For the Ethereum Mainnet, which has a chain ID of 1 , this means that all transactions have a value of either 37 or 38 . The chain ID set in the genesis configuration file, in the config section, and is only used when the block number is above the one set at eip155Block . See the GoQuorum example genesis files for an example. It can be changed as many times as needed while the chain is below the eip155Block number and re-rerunning geth init - this will not delete or modify any current sync process or saved blocks. In GoQuorum, transactions are considered private if the v parameter is set to 37 or 38 , which clashes with networks which have a Chain ID of 1 . For this reason, GoQuorum will not run using chain ID 1 and will immediately quit if started with such a configuration.","title":"Network and chain ID"},{"location":"concepts/permissions-overview/","text":"Permissioning \u00b6 GoQuorum supports two network permissioning models, basic network permissioning and enhanced network permissioning . Basic network permissioning \u00b6 In the basic network permissioning model, you can control: The nodes that a particular GoQuorum node can connect to. The nodes that a particular GoQuorum node can receive connections from. It is managed at the individual node level by providing the --permissioned command line option when starting the node. You can configure basic network permissioning . Enhanced network permissioning \u00b6 The enhanced network permissioning model caters to enterprise-level needs by using smart contracts. It has significant flexibility to manage nodes, accounts, and account-level access controls. Two versions of enhanced network permissioning are available: Version 1 - The permissioning rules are applied only at the time of transaction entry with respect to the permissioning data stored in node memory. Version 2 - The permissioning rules are applied both at the time of transaction entry and block minting with respect to the data stored in the permissioning contracts. You can configure enhanced network permissioning . Key definitions \u00b6 Network - A set of interconnected nodes representing an enterprise blockchain. The network comprises a group of organizations. The network administrator accounts defined at the network level can propose and approve new organizations to join the network, and can assign an account as an organization administrator. Organization - A set of roles, Ethereum accounts, and nodes having a variety of permissions to interact with the network. The organization administrator can create roles, create sub-organizations, assign roles to its accounts, and add any other node that is part of the organization. The organization administrator can assign an account as a sub-organization administrator. Sub-organization - A sub-group within an organization, corresponding to business needs. A sub-organization can have its own set of roles, accounts, and sub-organizations. Account - An externally-owned Ethereum account. The access rights of an account are derived based on the role assigned to it. The account can transact via any node linked to its sub-organization or at the organization level. Voter - An account capable of voting for a certain action. Role - A named job function in an organization. Node - A geth node that is part of the network and belongs to an organization or sub-organization.","title":"Permissioning"},{"location":"concepts/permissions-overview/#permissioning","text":"GoQuorum supports two network permissioning models, basic network permissioning and enhanced network permissioning .","title":"Permissioning"},{"location":"concepts/permissions-overview/#basic-network-permissioning","text":"In the basic network permissioning model, you can control: The nodes that a particular GoQuorum node can connect to. The nodes that a particular GoQuorum node can receive connections from. It is managed at the individual node level by providing the --permissioned command line option when starting the node. You can configure basic network permissioning .","title":"Basic network permissioning"},{"location":"concepts/permissions-overview/#enhanced-network-permissioning","text":"The enhanced network permissioning model caters to enterprise-level needs by using smart contracts. It has significant flexibility to manage nodes, accounts, and account-level access controls. Two versions of enhanced network permissioning are available: Version 1 - The permissioning rules are applied only at the time of transaction entry with respect to the permissioning data stored in node memory. Version 2 - The permissioning rules are applied both at the time of transaction entry and block minting with respect to the data stored in the permissioning contracts. You can configure enhanced network permissioning .","title":"Enhanced network permissioning"},{"location":"concepts/permissions-overview/#key-definitions","text":"Network - A set of interconnected nodes representing an enterprise blockchain. The network comprises a group of organizations. The network administrator accounts defined at the network level can propose and approve new organizations to join the network, and can assign an account as an organization administrator. Organization - A set of roles, Ethereum accounts, and nodes having a variety of permissions to interact with the network. The organization administrator can create roles, create sub-organizations, assign roles to its accounts, and add any other node that is part of the organization. The organization administrator can assign an account as a sub-organization administrator. Sub-organization - A sub-group within an organization, corresponding to business needs. A sub-organization can have its own set of roles, accounts, and sub-organizations. Account - An externally-owned Ethereum account. The access rights of an account are derived based on the role assigned to it. The account can transact via any node linked to its sub-organization or at the organization level. Voter - An account capable of voting for a certain action. Role - A named job function in an organization. Node - A geth node that is part of the network and belongs to an organization or sub-organization.","title":"Key definitions"},{"location":"concepts/plugins/","text":"GoQuorum plugins \u00b6 GoQuorum allows adding features as plugins to the core geth client, providing extensibility, flexibility, and isolation of GoQuorum features. The benefits of plugins include: Allowing the implementation of certain GoQuorum components to be changed at configuration time. Supporting the GoQuorum community to improve the GoQuorum client with innovative plugin implementations in different languages. Decoupling new GoQuorum-specific features from the core geth , simplifying the process of integrating changes from upstream geth , and isolating potential failures. How it works \u00b6 Each plugin exposes an implementation for a specific plugin interface . Plugins are executed as separate processes and communicate with the main geth process over a gRPC interface. The plugin implementation must adhere to certain gRPC services defined in a .proto file corresponding to the plugin interface. Plugins can be written in different languages, as gRPC provides a mechanism to generate stub code from .proto files. The high-level plugin library automatically handles the network communication and RPC. Using plugins \u00b6 The GoQuorum client reads the plugin configuration file to determine which plugins to load and searches for installed plugins ( <name>-<version>.zip files) in the plugins directory baseDir (the default directory is <datadir>/plugins ). You can specify a plugin configuration file , develop plugins , and use an example HelloWorld plugin . Plugin reloading \u00b6 The Plugin Manager exposes an API admin_reloadPlugin that allows reloading a plugin. This attempts to restart the current plugin process. Plugin configuration changes made after the initial node startup are applied when reloading the plugin. This is demonstrated in the HelloWorld plugin tutorial . Plugin integrity verification \u00b6 GoQuorum uses Plugin Central Server to download and verify plugin integrity using PGP . You can enable the same verification process locally using the --plugins.localverify and --plugins.publickey command-line options, or remotely using custom Plugin Central . To disable the plugin verification process, use the --plugins.skipverify command-line option. Warning Using --plugins.skipverify introduces security risks and isn\u2019t recommended for production environments. DEBUG TEST!!! \u00b6 Spelling test ie. as well as","title":"Plugins"},{"location":"concepts/plugins/#goquorum-plugins","text":"GoQuorum allows adding features as plugins to the core geth client, providing extensibility, flexibility, and isolation of GoQuorum features. The benefits of plugins include: Allowing the implementation of certain GoQuorum components to be changed at configuration time. Supporting the GoQuorum community to improve the GoQuorum client with innovative plugin implementations in different languages. Decoupling new GoQuorum-specific features from the core geth , simplifying the process of integrating changes from upstream geth , and isolating potential failures.","title":"GoQuorum plugins"},{"location":"concepts/plugins/#how-it-works","text":"Each plugin exposes an implementation for a specific plugin interface . Plugins are executed as separate processes and communicate with the main geth process over a gRPC interface. The plugin implementation must adhere to certain gRPC services defined in a .proto file corresponding to the plugin interface. Plugins can be written in different languages, as gRPC provides a mechanism to generate stub code from .proto files. The high-level plugin library automatically handles the network communication and RPC.","title":"How it works"},{"location":"concepts/plugins/#using-plugins","text":"The GoQuorum client reads the plugin configuration file to determine which plugins to load and searches for installed plugins ( <name>-<version>.zip files) in the plugins directory baseDir (the default directory is <datadir>/plugins ). You can specify a plugin configuration file , develop plugins , and use an example HelloWorld plugin .","title":"Using plugins"},{"location":"concepts/plugins/#plugin-reloading","text":"The Plugin Manager exposes an API admin_reloadPlugin that allows reloading a plugin. This attempts to restart the current plugin process. Plugin configuration changes made after the initial node startup are applied when reloading the plugin. This is demonstrated in the HelloWorld plugin tutorial .","title":"Plugin reloading"},{"location":"concepts/plugins/#plugin-integrity-verification","text":"GoQuorum uses Plugin Central Server to download and verify plugin integrity using PGP . You can enable the same verification process locally using the --plugins.localverify and --plugins.publickey command-line options, or remotely using custom Plugin Central . To disable the plugin verification process, use the --plugins.skipverify command-line option. Warning Using --plugins.skipverify introduces security risks and isn\u2019t recommended for production environments.","title":"Plugin integrity verification"},{"location":"concepts/plugins/#debug-test","text":"Spelling test ie. as well as","title":"DEBUG TEST!!!"},{"location":"concepts/profiling/","text":"Quorum profiling \u00b6 Quorum profiling is a custom toolset used to benchmark transaction throughput and network statistics on any existing Quorum network using the JMeter and TPS monitoring tool profiles. Alternatively, it could also be used to spin up an entire GoQuorum network from scratch in AWS and benchmark the network for TPS , CPU/Memory usage. The various scenarios of usage is explained here Metrics visualization \u00b6 Key Components: Telegraf - plugin-driven server agent for collecting and reporting metrics. Refer to GoQuorum profiling config . JMeter - Load testing tool. The detail of various profiles and test execution, refer here TPS Monitor - Custom \u201cgo\u201d project to monitor transactions per second, total transactions and total blocks in Quorum network. InfluxDB - Open source time series database for monitoring metrics and events, providing real-time visibility. Prometheus - similar to influx Prometheus records real-time metrics in a time series database built using a HTTP \u201cpull\u201d model, with flexible queries and real-time alerting Grafana - Monitoring tool for metrics and logs consolidation The tool executes the stress test profile selected and then collects the following metrics: CPU/Memory usage for both Quorum & tessera Transaction & Block count Transaction processing speed Jmeter test execution statistics These metrics could be configured to be stored in an InfluxDB or Prometheus for further analysis. Both databases integrate well with the open source dashboard editor Grafana to allow for easy creation of dashboards to visualise the data being captured from the profiling tool. Sample dashboards below: Sample network dashboard \u00b6 Sample JMeter dashboard \u00b6","title":"GoQuorum profiling"},{"location":"concepts/profiling/#quorum-profiling","text":"Quorum profiling is a custom toolset used to benchmark transaction throughput and network statistics on any existing Quorum network using the JMeter and TPS monitoring tool profiles. Alternatively, it could also be used to spin up an entire GoQuorum network from scratch in AWS and benchmark the network for TPS , CPU/Memory usage. The various scenarios of usage is explained here","title":"Quorum profiling"},{"location":"concepts/profiling/#metrics-visualization","text":"Key Components: Telegraf - plugin-driven server agent for collecting and reporting metrics. Refer to GoQuorum profiling config . JMeter - Load testing tool. The detail of various profiles and test execution, refer here TPS Monitor - Custom \u201cgo\u201d project to monitor transactions per second, total transactions and total blocks in Quorum network. InfluxDB - Open source time series database for monitoring metrics and events, providing real-time visibility. Prometheus - similar to influx Prometheus records real-time metrics in a time series database built using a HTTP \u201cpull\u201d model, with flexible queries and real-time alerting Grafana - Monitoring tool for metrics and logs consolidation The tool executes the stress test profile selected and then collects the following metrics: CPU/Memory usage for both Quorum & tessera Transaction & Block count Transaction processing speed Jmeter test execution statistics These metrics could be configured to be stored in an InfluxDB or Prometheus for further analysis. Both databases integrate well with the open source dashboard editor Grafana to allow for easy creation of dashboards to visualise the data being captured from the profiling tool. Sample dashboards below:","title":"Metrics visualization"},{"location":"concepts/profiling/#sample-network-dashboard","text":"","title":"Sample network dashboard"},{"location":"concepts/profiling/#sample-jmeter-dashboard","text":"","title":"Sample JMeter dashboard"},{"location":"concepts/qlight-node/","text":"GoQuorum qlight node \u00b6 A qlight node is a lightweight replica of a full node that proxies transactions to the full node. You can deploy a qlight node to reduce the amount of data that is shared with external parties by the full nodes. The qlight node can be used to: Avoid impacting main nodes which are processing transactions with anything that could thrash the API (such as monitoring, state querying, or other intensive processes). Prevent security concerns where the main node is handling multiple private parties (multi-tenancy) . The qlight client deals with a private state for one party only, and only that user has access to the qlight client. Qlight nodes and standard nodes \u00b6 A standard GoQuorum node processes all blocks and associated transactions. It also requires a local private transaction manager to handle private data. This can require significant resources and can make it more difficult to scale networks. Additionally, since the node processes all transactions, privacy concerns could be raised by business partners. Using a qlight node for process-intensive tasks can help lessen impact to the performance of a main node. Qlight nodes help prevent network throttling due to third party network limits, or multiple clients all hitting the same main node. Qlight nodes differ from standard quorum nodes in the following ways: Qlight nodes depend on a server full node for receiving data and will only connect to the server node. There is no communication with any other node. They only receive blocks from the server node, processing them locally to build up the public and private state. They do not require a transaction manager. Instead, private data is sent directly by the server node via the qlight P2P protocol. They act as a proxy for locally submitted transactions, performing minimal validation. API calls like SendTansaction / SendRawTransaction / StoreRaw are forwarded to the server node for processing. They use the same RPC APIs that are required for dapps, delegating calls to the server node if needed. They do not partake in the consensus mechanism. Client and server \u00b6 qlight client refers to the qlight node. qlight server refers to a full node that is configured to supply data to the qlight client. It also handles API requests that are delegated from the qlight client. Architecture \u00b6 Communication protocol \u00b6 The qlight client and server communicate through a peer-to-peer protocol. Security \u00b6 A number of security features are available for the qlight client-server connection: Native transport layer security (TLS): this can be used to encrypt communications and ensure the security of private transaction data. Network restriction: restricts communication to specified IP networks (CIDR masks). File based permissioning: allows qlight peers to be checked against a permissioned list and a disallowed list. Enterprise authorization protocol integration: this allows qlight clients to be authenticated using an OAuth2 server. Private transaction manager cache \u00b6 The qlight client does not have a local private transaction manager , but relies on the qlight server to supply private data. This is implemented by means of a local cache which simulates a local private transaction manager. Therefore, private transactions can be executed locally, with the private data being fetched from the private transaction manager cache. New API methods (on qlight server) \u00b6 admin.qnodeInfo : Returns details of the qlight configuration. admin.qpeers : Returns details of the qlight clients that are connected.","title":"GoQuorum qlight client"},{"location":"concepts/qlight-node/#goquorum-qlight-node","text":"A qlight node is a lightweight replica of a full node that proxies transactions to the full node. You can deploy a qlight node to reduce the amount of data that is shared with external parties by the full nodes. The qlight node can be used to: Avoid impacting main nodes which are processing transactions with anything that could thrash the API (such as monitoring, state querying, or other intensive processes). Prevent security concerns where the main node is handling multiple private parties (multi-tenancy) . The qlight client deals with a private state for one party only, and only that user has access to the qlight client.","title":"GoQuorum qlight node"},{"location":"concepts/qlight-node/#qlight-nodes-and-standard-nodes","text":"A standard GoQuorum node processes all blocks and associated transactions. It also requires a local private transaction manager to handle private data. This can require significant resources and can make it more difficult to scale networks. Additionally, since the node processes all transactions, privacy concerns could be raised by business partners. Using a qlight node for process-intensive tasks can help lessen impact to the performance of a main node. Qlight nodes help prevent network throttling due to third party network limits, or multiple clients all hitting the same main node. Qlight nodes differ from standard quorum nodes in the following ways: Qlight nodes depend on a server full node for receiving data and will only connect to the server node. There is no communication with any other node. They only receive blocks from the server node, processing them locally to build up the public and private state. They do not require a transaction manager. Instead, private data is sent directly by the server node via the qlight P2P protocol. They act as a proxy for locally submitted transactions, performing minimal validation. API calls like SendTansaction / SendRawTransaction / StoreRaw are forwarded to the server node for processing. They use the same RPC APIs that are required for dapps, delegating calls to the server node if needed. They do not partake in the consensus mechanism.","title":"Qlight nodes and standard nodes"},{"location":"concepts/qlight-node/#client-and-server","text":"qlight client refers to the qlight node. qlight server refers to a full node that is configured to supply data to the qlight client. It also handles API requests that are delegated from the qlight client.","title":"Client and server"},{"location":"concepts/qlight-node/#architecture","text":"","title":"Architecture"},{"location":"concepts/qlight-node/#communication-protocol","text":"The qlight client and server communicate through a peer-to-peer protocol.","title":"Communication protocol"},{"location":"concepts/qlight-node/#security","text":"A number of security features are available for the qlight client-server connection: Native transport layer security (TLS): this can be used to encrypt communications and ensure the security of private transaction data. Network restriction: restricts communication to specified IP networks (CIDR masks). File based permissioning: allows qlight peers to be checked against a permissioned list and a disallowed list. Enterprise authorization protocol integration: this allows qlight clients to be authenticated using an OAuth2 server.","title":"Security"},{"location":"concepts/qlight-node/#private-transaction-manager-cache","text":"The qlight client does not have a local private transaction manager , but relies on the qlight server to supply private data. This is implemented by means of a local cache which simulates a local private transaction manager. Therefore, private transactions can be executed locally, with the private data being fetched from the private transaction manager cache.","title":"Private transaction manager cache"},{"location":"concepts/qlight-node/#new-api-methods-on-qlight-server","text":"admin.qnodeInfo : Returns details of the qlight configuration. admin.qpeers : Returns details of the qlight clients that are connected.","title":"New API methods (on qlight server)"},{"location":"concepts/security-framework/","text":"Security framework \u00b6 This topic describes high-level security best practices for: Managing a GoQuorum consortium . Securing the components of a GoQuorum node . Monitoring a GoQuorum network. Using the Tessera transaction manager . You can view a list of additional network and dapp security resources . Consortium \u00b6 A consortium network connects multiple independent networks. Consortiums come with risks such as accidental data exposure and potential liabilities that must be managed. They require governance structures that fulfill the concerns of participants equally. Note In a consortium network, every member does not need to be a validator. Each non-validating member will still have a full copy of the chain data and has full ability to transact (private or public) on the network. To prevent the network halting, all validators have additional responsibility to ensure that their node does not go down and is available per SLAs of the consortium agreements. Security checklist \u00b6 Use a Byzantine fault tolerant consensus protocol in case nodes are managed by non-trusted participants. Ensure consortium members provide a reasonable network service-level agreement (SLA). Ensure private and public payload data is stored in an appropriate geographical legislation area. Document: The organizational and technological requirements to join the consortium. The consortium governance structure. Ownership of intellectual property and assets. Liability. Memberships. Activities. Ensure consortium members are known to every participant in the network. Ensure private and public payload data is compliant with privacy policies. GoQuorum node \u00b6 The GoQuorum client is an Ethereum client that uses a transaction manager to encrypt and decrypt private transaction payloads. GoQuorum and its dependencies use the TCP/UDP transport layer to communicate. GoQuorum\u2019s security depends on the security of the client host, transaction manager host, encryption keys, consensus runtime, and network access controls. Host security checklist \u00b6 Harden the GoQuorum host operating system following industry best practices (for example, remove irrelevant services and root access). Disable direct remote network access to the GoQuorum host management interface in production. Use a host-based intrusion detection system (HIDS) to monitor the GoQuorum node host. Enable host-based firewall rules that limit network access to the JSON-RPC interface to only pre-identified, trusted, and required systems. Implement a robust patch management program, and always keep the host updated to the latest stable version. Ensure host-level isolation of responsibility between the GoQuorum client and its dependencies (for example, don\u2019t run the transaction manager and its database in the same host). Run GoQuorum network hosts with service level agreements (SLAs) that defend against non-vulnerability-based denial of service. Client security checklist \u00b6 Encrypt all communications to and from the JSON-RPC interface using TLS to prevent data leakage and man-in-the-middle (MITM) attacks. Enable an enterprise JSON-RPC authorization model to enforce atomic access controls to ledger module functionalities (for example, personal.OpenWallet ). Implement a robust patch management program, and always keep the client updated to latest stable version. Don\u2019t start the GoQuorum client run configuration with unlocked accounts. Configure cross-domain access to the JSON-RPC interface appropriately. Set peer discovery based on the consortium requirements. In Raft consensus, there\u2019s no guarantee a leader isn\u2019t acting maliciously, so don\u2019t use Raft in an environment where the network ledger is managed by third-party authorities. Run GoQuorum with metrics collection enabled to preserve operational security. User security checklist \u00b6 Ensure accounts\u2019 private-key-encrypted passwords are never stored in the ledger host in any form. In an architecture where accounts\u2019 private keys are not offloaded to ledger node clients, regularly back up the encrypted private keys. Monitoring \u00b6 The GoQuorum network produces logs that should be monitored for security anomalies. Security checklist \u00b6 Log all activities of GoQuorum hosts to a centralized log system. Ensure the centralized log system can answer queries about: Ethereum accounts on the network. Active ledger and transaction manager nodes in the network. Public and private transaction rates per account in the network. Number of public smart contracts in the network. Network connections to ledger nodes and metadata. Consensus protocol metadata (for example, block creation rate and source). Back up and verify logs. Implement an alerting system to monitor consensus protocol anomalies. Transaction manager \u00b6 Tessera is GoQuorum\u2019s transaction manager. GoQuorum privacy features depend on Tessera to encrypt, decrypt, and broadcast the orchestrations of private transaction payloads. Tessera encryption keys are the most critical element of the privacy model; if they\u2019re compromised, the network loses its privacy. Tessera supports integration with trusted platform modules (TPMs) and hardware security modules (HSM) to reduce surface attacks and provide a secure environment. Security checklist \u00b6 Run Tessera in an independent network segment in production. Use certificate-based mutual authentication (mTLS) with Tessera\u2019s dependencies. Store encryption keys in secure environments such an HSM. Ensure the secret storage services support key rotation. Depending on the deployment model, back up encryption keys in offline secured locations. Ensure the secret storage service is in complete isolation of the external network. Don\u2019t store Tessera connection strings in plaintext in configuration files. When deploying secret storage in the cloud, use a single tenancy model. Enable host firewall rules to limit inbound and outbound traffic to only consumers of vault services. This includes essential host services like DNS and NTP. Limit remote access to the secret storage instance to only allowlisted IP addresses, and enable MFA. Disable remote root access to Tessera/secret storage hosts. Enable remote centralized logging for Tessera and its dependencies. Disable core dumps in Tessera hosts. Upgrade Tessera frequently, and use an immutable strategy when upgrading. Resources \u00b6 The following are additional resources for blockchain network and dapp security best practices. Decentralized Application Security Project Solidity documentation Smart Contract Federated Identity Management without Third Party Authentication Services Advancing Blockchain Cybersecurity: Technical and Policy Considerations for the Financial Services Industry Framework for Improving Critical Infrastructure Cybersecurity Recommendation for Key Management: Part 2 - Best Practices for Key Management Organizations","title":"Security framework"},{"location":"concepts/security-framework/#security-framework","text":"This topic describes high-level security best practices for: Managing a GoQuorum consortium . Securing the components of a GoQuorum node . Monitoring a GoQuorum network. Using the Tessera transaction manager . You can view a list of additional network and dapp security resources .","title":"Security framework"},{"location":"concepts/security-framework/#consortium","text":"A consortium network connects multiple independent networks. Consortiums come with risks such as accidental data exposure and potential liabilities that must be managed. They require governance structures that fulfill the concerns of participants equally. Note In a consortium network, every member does not need to be a validator. Each non-validating member will still have a full copy of the chain data and has full ability to transact (private or public) on the network. To prevent the network halting, all validators have additional responsibility to ensure that their node does not go down and is available per SLAs of the consortium agreements.","title":"Consortium"},{"location":"concepts/security-framework/#security-checklist","text":"Use a Byzantine fault tolerant consensus protocol in case nodes are managed by non-trusted participants. Ensure consortium members provide a reasonable network service-level agreement (SLA). Ensure private and public payload data is stored in an appropriate geographical legislation area. Document: The organizational and technological requirements to join the consortium. The consortium governance structure. Ownership of intellectual property and assets. Liability. Memberships. Activities. Ensure consortium members are known to every participant in the network. Ensure private and public payload data is compliant with privacy policies.","title":"Security checklist"},{"location":"concepts/security-framework/#goquorum-node","text":"The GoQuorum client is an Ethereum client that uses a transaction manager to encrypt and decrypt private transaction payloads. GoQuorum and its dependencies use the TCP/UDP transport layer to communicate. GoQuorum\u2019s security depends on the security of the client host, transaction manager host, encryption keys, consensus runtime, and network access controls.","title":"GoQuorum node"},{"location":"concepts/security-framework/#host-security-checklist","text":"Harden the GoQuorum host operating system following industry best practices (for example, remove irrelevant services and root access). Disable direct remote network access to the GoQuorum host management interface in production. Use a host-based intrusion detection system (HIDS) to monitor the GoQuorum node host. Enable host-based firewall rules that limit network access to the JSON-RPC interface to only pre-identified, trusted, and required systems. Implement a robust patch management program, and always keep the host updated to the latest stable version. Ensure host-level isolation of responsibility between the GoQuorum client and its dependencies (for example, don\u2019t run the transaction manager and its database in the same host). Run GoQuorum network hosts with service level agreements (SLAs) that defend against non-vulnerability-based denial of service.","title":"Host security checklist"},{"location":"concepts/security-framework/#client-security-checklist","text":"Encrypt all communications to and from the JSON-RPC interface using TLS to prevent data leakage and man-in-the-middle (MITM) attacks. Enable an enterprise JSON-RPC authorization model to enforce atomic access controls to ledger module functionalities (for example, personal.OpenWallet ). Implement a robust patch management program, and always keep the client updated to latest stable version. Don\u2019t start the GoQuorum client run configuration with unlocked accounts. Configure cross-domain access to the JSON-RPC interface appropriately. Set peer discovery based on the consortium requirements. In Raft consensus, there\u2019s no guarantee a leader isn\u2019t acting maliciously, so don\u2019t use Raft in an environment where the network ledger is managed by third-party authorities. Run GoQuorum with metrics collection enabled to preserve operational security.","title":"Client security checklist"},{"location":"concepts/security-framework/#user-security-checklist","text":"Ensure accounts\u2019 private-key-encrypted passwords are never stored in the ledger host in any form. In an architecture where accounts\u2019 private keys are not offloaded to ledger node clients, regularly back up the encrypted private keys.","title":"User security checklist"},{"location":"concepts/security-framework/#monitoring","text":"The GoQuorum network produces logs that should be monitored for security anomalies.","title":"Monitoring"},{"location":"concepts/security-framework/#security-checklist_1","text":"Log all activities of GoQuorum hosts to a centralized log system. Ensure the centralized log system can answer queries about: Ethereum accounts on the network. Active ledger and transaction manager nodes in the network. Public and private transaction rates per account in the network. Number of public smart contracts in the network. Network connections to ledger nodes and metadata. Consensus protocol metadata (for example, block creation rate and source). Back up and verify logs. Implement an alerting system to monitor consensus protocol anomalies.","title":"Security checklist"},{"location":"concepts/security-framework/#transaction-manager","text":"Tessera is GoQuorum\u2019s transaction manager. GoQuorum privacy features depend on Tessera to encrypt, decrypt, and broadcast the orchestrations of private transaction payloads. Tessera encryption keys are the most critical element of the privacy model; if they\u2019re compromised, the network loses its privacy. Tessera supports integration with trusted platform modules (TPMs) and hardware security modules (HSM) to reduce surface attacks and provide a secure environment.","title":"Transaction manager"},{"location":"concepts/security-framework/#security-checklist_2","text":"Run Tessera in an independent network segment in production. Use certificate-based mutual authentication (mTLS) with Tessera\u2019s dependencies. Store encryption keys in secure environments such an HSM. Ensure the secret storage services support key rotation. Depending on the deployment model, back up encryption keys in offline secured locations. Ensure the secret storage service is in complete isolation of the external network. Don\u2019t store Tessera connection strings in plaintext in configuration files. When deploying secret storage in the cloud, use a single tenancy model. Enable host firewall rules to limit inbound and outbound traffic to only consumers of vault services. This includes essential host services like DNS and NTP. Limit remote access to the secret storage instance to only allowlisted IP addresses, and enable MFA. Disable remote root access to Tessera/secret storage hosts. Enable remote centralized logging for Tessera and its dependencies. Disable core dumps in Tessera hosts. Upgrade Tessera frequently, and use an immutable strategy when upgrading.","title":"Security checklist"},{"location":"concepts/security-framework/#resources","text":"The following are additional resources for blockchain network and dapp security best practices. Decentralized Application Security Project Solidity documentation Smart Contract Federated Identity Management without Third Party Authentication Services Advancing Blockchain Cybersecurity: Technical and Policy Considerations for the Financial Services Industry Framework for Improving Critical Infrastructure Cybersecurity Recommendation for Key Management: Part 2 - Best Practices for Key Management Organizations","title":"Resources"},{"location":"concepts/blockchain-basics/","text":"Blockchain basics \u00b6 This section introduces the concept of a blockchain. Learn more about blockchain components . What is a blockchain? \u00b6 A blockchain is a shared, immutable electronic ledger (or digital database) that keeps a record of transactional data. Blockchains are decentralized, which means that they store data across a network of members who collaborate to monitor and run the network. The system as such cannot be owned a single entity, but rather by everyone on the network. The block in blockchain refers to a block of transactions that has been broadcast to the network. The chain refers to a string of these blocks in chronological order. When a new block of transactions is securely validated by the network, it is attached to the end of an existing chain. This chain of blocks is an ever-growing ledger of transactions, each of which can be traced, providing accountability and transparency unavailable on traditional ledgers. What problems do blockchains solve? \u00b6 We live in a highly transactional world, where we must constantly trust one another with sensitive data, transactions, and records. Most of our interactions on the Internet run on centralized web servers (for example, banks) and massive amounts of user data often exist in a single database. This poses a few risks, as current databases are designed to be controlled by trusted administrators who can read, alter, block, or delete data. In addition, the centralized architecture of the Internet today is vulnerable to censorship and targeted attacks by both hackers and internal bad actors. The value of a blockchain is the certainty of the network: participants can establish a trusted and immutable record of transactions without the need for intermediaries. The decentralized architecture of a blockchain\u2014a global network of computers simultaneously running the software and validating the chain of transactions\u2014is what ensures that the transaction record is never compromised. It makes a blockchain network less likely to fail and harder to attack. Why do I need a blockchain for my business? \u00b6 Blockchains introduce a new model of doing business, where networks have standard methods for transactions, data storage, and establishing identities of all participants. Blockchains foster trust between participants, with decentralization and improved security. Participants\u2019 privacy concerns are addressed by anonymizing data and requiring permissions to limit access. Transaction visibility enables businesses to track the origins of an asset accurately, and maintain inventory and quality of goods. The biggest benefit of blockchains is the opportunities that arise for businesses to grow and collaborate. Multiple organizations can come together to create a consortium network working towards a shared goal, where terms and permissions are agreed upon and deployed to the blockchain. These policies can evolve over time, updating through participant-based governance. Blockchains can help make your business smoother and more efficient, allowing you to focus on growing your business.","title":"Blockchain basics"},{"location":"concepts/blockchain-basics/#blockchain-basics","text":"This section introduces the concept of a blockchain. Learn more about blockchain components .","title":"Blockchain basics"},{"location":"concepts/blockchain-basics/#what-is-a-blockchain","text":"A blockchain is a shared, immutable electronic ledger (or digital database) that keeps a record of transactional data. Blockchains are decentralized, which means that they store data across a network of members who collaborate to monitor and run the network. The system as such cannot be owned a single entity, but rather by everyone on the network. The block in blockchain refers to a block of transactions that has been broadcast to the network. The chain refers to a string of these blocks in chronological order. When a new block of transactions is securely validated by the network, it is attached to the end of an existing chain. This chain of blocks is an ever-growing ledger of transactions, each of which can be traced, providing accountability and transparency unavailable on traditional ledgers.","title":"What is a blockchain?"},{"location":"concepts/blockchain-basics/#what-problems-do-blockchains-solve","text":"We live in a highly transactional world, where we must constantly trust one another with sensitive data, transactions, and records. Most of our interactions on the Internet run on centralized web servers (for example, banks) and massive amounts of user data often exist in a single database. This poses a few risks, as current databases are designed to be controlled by trusted administrators who can read, alter, block, or delete data. In addition, the centralized architecture of the Internet today is vulnerable to censorship and targeted attacks by both hackers and internal bad actors. The value of a blockchain is the certainty of the network: participants can establish a trusted and immutable record of transactions without the need for intermediaries. The decentralized architecture of a blockchain\u2014a global network of computers simultaneously running the software and validating the chain of transactions\u2014is what ensures that the transaction record is never compromised. It makes a blockchain network less likely to fail and harder to attack.","title":"What problems do blockchains solve?"},{"location":"concepts/blockchain-basics/#why-do-i-need-a-blockchain-for-my-business","text":"Blockchains introduce a new model of doing business, where networks have standard methods for transactions, data storage, and establishing identities of all participants. Blockchains foster trust between participants, with decentralization and improved security. Participants\u2019 privacy concerns are addressed by anonymizing data and requiring permissions to limit access. Transaction visibility enables businesses to track the origins of an asset accurately, and maintain inventory and quality of goods. The biggest benefit of blockchains is the opportunities that arise for businesses to grow and collaborate. Multiple organizations can come together to create a consortium network working towards a shared goal, where terms and permissions are agreed upon and deployed to the blockchain. These policies can evolve over time, updating through participant-based governance. Blockchains can help make your business smoother and more efficient, allowing you to focus on growing your business.","title":"Why do I need a blockchain for my business?"},{"location":"concepts/blockchain-basics/blockchain-components/","text":"Blockchain components \u00b6 This section introduces the components of blockchains . Nodes \u00b6 Blockchains are decentralized, which means that they store data across a network of members who collaborate to monitor and run the network. Blockchain participants run a blockchain client, such as GoQuorum, and connect it to the network as a node . Consensus \u00b6 To ensure that transactions are written to the chain, and that there is agreement on the data and state of the network, blockchains use a consensus mechanism that is a fault-tolerant. Consensus mechanisms include: Proof of work (PoW) - PoW is a consensus mechanism used in Bitcoin that is both time- and computation-intensive. PoW blocks are created by nodes called miners . Proof of authority (PoA) - PoA involves a set of trusted nodes that validate transactions and create blocks. These trusted nodes are called validators , and other nodes in the network are called non-validating nodes . Non-validating nodes still validate the blocks that the validators create, but they don\u2019t produce them. GoQuorum supports the PoA algorithms IBFT, QBFT, Raft, and Clique. Smart contracts \u00b6 Smart contracts provide controlled access and a range of functions (such as querying, transacting, and updating state) to blockchain users. Smart contracts encapsulate data and keep it consistent across the network. They can allow or restrict participants from executing certain functions, and can restrict access to the network itself. Smart contracts are written in Solidity (the most popular smart contract language), Vyper, and Serpent. Dapps \u00b6 Decentralized applications (dapps) are just like any other software application can be on a website or mobile app. Dapps are built on a decentralized network (Ethereum) and interact with smart contracts deployed to the network. They can be thought of as a GUI (front end) for a smart contract (back end), and can be written in any language (for example, JavaScript). Permissioning \u00b6 Permissioning involves a distributed network of trust across a blockchain network, in which participants agree to follow certain rules. If one bad actor doesn\u2019t follow the rules other nodes can restrict the bad actor from writing to the blockchain. GoQuorum has support for node permissioning and account permissioning, allowing only specific nodes and accounts to\\ access the network. Privacy \u00b6 In a blockchain network, privacy refers to the ability to keep transactions private between the involved participants. Often in a consortium network, some of the participants prefer to restrict how much information they share or who they transact with. In other cases, this may not be a concern at all. GoQuorum supports privacy using a private transaction manager (PTM) paired to your member node, typically Tessera . Tessera uses an enclave for cryptographic functionality and stores and allows access to encrypted transaction data, and exchanges encrypted payloads with other Tessera nodes. Tessera is restful/stateless and can be load balanced easily. Forks \u00b6 Forks are splits in the blockchain network, or mechanisms to add functionality ( EIPs ) to the blockchain protocol from a community-agreed-upon block. Hard forks are radical changes to the network that may change the validity of a block (or a certain chain of blocks). Hard forks require all nodes to upgrade to the latest version of the client. These are permanent deviations from the main chain.","title":"Components"},{"location":"concepts/blockchain-basics/blockchain-components/#blockchain-components","text":"This section introduces the components of blockchains .","title":"Blockchain components"},{"location":"concepts/blockchain-basics/blockchain-components/#nodes","text":"Blockchains are decentralized, which means that they store data across a network of members who collaborate to monitor and run the network. Blockchain participants run a blockchain client, such as GoQuorum, and connect it to the network as a node .","title":"Nodes"},{"location":"concepts/blockchain-basics/blockchain-components/#consensus","text":"To ensure that transactions are written to the chain, and that there is agreement on the data and state of the network, blockchains use a consensus mechanism that is a fault-tolerant. Consensus mechanisms include: Proof of work (PoW) - PoW is a consensus mechanism used in Bitcoin that is both time- and computation-intensive. PoW blocks are created by nodes called miners . Proof of authority (PoA) - PoA involves a set of trusted nodes that validate transactions and create blocks. These trusted nodes are called validators , and other nodes in the network are called non-validating nodes . Non-validating nodes still validate the blocks that the validators create, but they don\u2019t produce them. GoQuorum supports the PoA algorithms IBFT, QBFT, Raft, and Clique.","title":"Consensus"},{"location":"concepts/blockchain-basics/blockchain-components/#smart-contracts","text":"Smart contracts provide controlled access and a range of functions (such as querying, transacting, and updating state) to blockchain users. Smart contracts encapsulate data and keep it consistent across the network. They can allow or restrict participants from executing certain functions, and can restrict access to the network itself. Smart contracts are written in Solidity (the most popular smart contract language), Vyper, and Serpent.","title":"Smart contracts"},{"location":"concepts/blockchain-basics/blockchain-components/#dapps","text":"Decentralized applications (dapps) are just like any other software application can be on a website or mobile app. Dapps are built on a decentralized network (Ethereum) and interact with smart contracts deployed to the network. They can be thought of as a GUI (front end) for a smart contract (back end), and can be written in any language (for example, JavaScript).","title":"Dapps"},{"location":"concepts/blockchain-basics/blockchain-components/#permissioning","text":"Permissioning involves a distributed network of trust across a blockchain network, in which participants agree to follow certain rules. If one bad actor doesn\u2019t follow the rules other nodes can restrict the bad actor from writing to the blockchain. GoQuorum has support for node permissioning and account permissioning, allowing only specific nodes and accounts to\\ access the network.","title":"Permissioning"},{"location":"concepts/blockchain-basics/blockchain-components/#privacy","text":"In a blockchain network, privacy refers to the ability to keep transactions private between the involved participants. Often in a consortium network, some of the participants prefer to restrict how much information they share or who they transact with. In other cases, this may not be a concern at all. GoQuorum supports privacy using a private transaction manager (PTM) paired to your member node, typically Tessera . Tessera uses an enclave for cryptographic functionality and stores and allows access to encrypted transaction data, and exchanges encrypted payloads with other Tessera nodes. Tessera is restful/stateless and can be load balanced easily.","title":"Privacy"},{"location":"concepts/blockchain-basics/blockchain-components/#forks","text":"Forks are splits in the blockchain network, or mechanisms to add functionality ( EIPs ) to the blockchain protocol from a community-agreed-upon block. Hard forks are radical changes to the network that may change the validity of a block (or a certain chain of blocks). Hard forks require all nodes to upgrade to the latest version of the client. These are permanent deviations from the main chain.","title":"Forks"},{"location":"concepts/consensus/","text":"Consensus protocols \u00b6 GoQuorum implements the following proof of authority (PoA) consensus protocols: QBFT - The recommended enterprise-grade consensus protocol for private networks. IBFT - Supported for existing private networks, but you can migrate a network using IBFT to QBFT . Raft - Not recommended for production networks. You can migrate a network using Raft to another consensus protocol . Clique - Not recommended for production networks. You can migrate a network using Clique to another consensus protocol . See a comparison of the PoA consensus protocols . Note You can\u2019t create a network of GoQuorum nodes using different consensus protocols. GoQuorum nodes configured with one consensus protocol can only work correctly with other nodes running the same protocol.","title":"Consensus protocols"},{"location":"concepts/consensus/#consensus-protocols","text":"GoQuorum implements the following proof of authority (PoA) consensus protocols: QBFT - The recommended enterprise-grade consensus protocol for private networks. IBFT - Supported for existing private networks, but you can migrate a network using IBFT to QBFT . Raft - Not recommended for production networks. You can migrate a network using Raft to another consensus protocol . Clique - Not recommended for production networks. You can migrate a network using Clique to another consensus protocol . See a comparison of the PoA consensus protocols . Note You can\u2019t create a network of GoQuorum nodes using different consensus protocols. GoQuorum nodes configured with one consensus protocol can only work correctly with other nodes running the same protocol.","title":"Consensus protocols"},{"location":"concepts/consensus/comparing-poa/","text":"Comparing proof of authority consensus protocols \u00b6 GoQuorum implements the QBFT , IBFT , Raft , and Clique proof of authority (PoA) consensus protocols . PoA consensus protocols work when participants know each other and there is a level of trust between them (for example, in a permissioned consortium network). PoA consensus protocols have faster block times and a much greater transaction throughput than the Ethash proof of work consensus protocol used on Ethereum Mainnet. In the GoQuorum PoA consensus protocols, a group of nodes in the network act as validators (QBFT and IBFT), verifiers (Raft), or signers (Clique). Existing validators, verifiers, or signers vote to add or remove network nodes. Note For the rest of this page, the term \u201cvalidator\u201d is used to refer to validators, verifiers, and signers. Properties \u00b6 Properties to consider when comparing the PoA consensus protocols are: Immediate finality. Minimum number of validators. Liveness. Speed. Immediate finality \u00b6 QBFT and Raft have immediate finality. When using QBFT and Raft there are no forks and all valid blocks get included in the main chain. IBFT and Clique do not have immediate finality. Implementations using IBFT and Clique must be aware of forks and chain reorganizations occurring. Minimum number of validators \u00b6 To be Byzantine fault tolerant, QBFT and IBFT require a minimum of four validators. Byzantine fault tolerance is the ability to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers. Raft and Clique can operate with a single validator but operating with a single validator offers no redundancy if the validator fails. Liveness \u00b6 Raft and Clique are more fault tolerant than QBFT and IBFT. Raft and Clique tolerate up to half of the validators failing. Important While Clique is Byzantine fault tolerant, Raft is only crash fault tolerant because the Raft leader is assumed to always act correctly. QBFT and IBFT networks require greater than or equal to two-thirds of validators to be operating to create blocks. For example, a QBFT network of: Four to five validators tolerates one unresponsive validator. Six to eight validators tolerates two unresponsive validators. Networks with three or fewer validators can produce blocks but do not guarantee finality when operating in adversarial environments. Important We recommend using QBFT and IBFT networks with at least four nodes in production environments. Speed \u00b6 Reaching consensus and adding blocks is fastest in Raft networks, then in Clique networks. For Clique, the probability of a fork increases as the number of validators increases. For QBFT and IBFT, the time to add new blocks increases as the number of validators increases.","title":"Comparing PoA consensus protocols"},{"location":"concepts/consensus/comparing-poa/#comparing-proof-of-authority-consensus-protocols","text":"GoQuorum implements the QBFT , IBFT , Raft , and Clique proof of authority (PoA) consensus protocols . PoA consensus protocols work when participants know each other and there is a level of trust between them (for example, in a permissioned consortium network). PoA consensus protocols have faster block times and a much greater transaction throughput than the Ethash proof of work consensus protocol used on Ethereum Mainnet. In the GoQuorum PoA consensus protocols, a group of nodes in the network act as validators (QBFT and IBFT), verifiers (Raft), or signers (Clique). Existing validators, verifiers, or signers vote to add or remove network nodes. Note For the rest of this page, the term \u201cvalidator\u201d is used to refer to validators, verifiers, and signers.","title":"Comparing proof of authority consensus protocols"},{"location":"concepts/consensus/comparing-poa/#properties","text":"Properties to consider when comparing the PoA consensus protocols are: Immediate finality. Minimum number of validators. Liveness. Speed.","title":"Properties"},{"location":"concepts/consensus/comparing-poa/#immediate-finality","text":"QBFT and Raft have immediate finality. When using QBFT and Raft there are no forks and all valid blocks get included in the main chain. IBFT and Clique do not have immediate finality. Implementations using IBFT and Clique must be aware of forks and chain reorganizations occurring.","title":"Immediate finality"},{"location":"concepts/consensus/comparing-poa/#minimum-number-of-validators","text":"To be Byzantine fault tolerant, QBFT and IBFT require a minimum of four validators. Byzantine fault tolerance is the ability to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers. Raft and Clique can operate with a single validator but operating with a single validator offers no redundancy if the validator fails.","title":"Minimum number of validators"},{"location":"concepts/consensus/comparing-poa/#liveness","text":"Raft and Clique are more fault tolerant than QBFT and IBFT. Raft and Clique tolerate up to half of the validators failing. Important While Clique is Byzantine fault tolerant, Raft is only crash fault tolerant because the Raft leader is assumed to always act correctly. QBFT and IBFT networks require greater than or equal to two-thirds of validators to be operating to create blocks. For example, a QBFT network of: Four to five validators tolerates one unresponsive validator. Six to eight validators tolerates two unresponsive validators. Networks with three or fewer validators can produce blocks but do not guarantee finality when operating in adversarial environments. Important We recommend using QBFT and IBFT networks with at least four nodes in production environments.","title":"Liveness"},{"location":"concepts/consensus/comparing-poa/#speed","text":"Reaching consensus and adding blocks is fastest in Raft networks, then in Clique networks. For Clique, the probability of a fork increases as the number of validators increases. For QBFT and IBFT, the time to add new blocks increases as the number of validators increases.","title":"Speed"},{"location":"concepts/privacy/","text":"Privacy \u00b6 Privacy refers to the ability to keep transactions private between the involved participants. Other participants can\u2019t access the transaction content. Private transaction manager \u00b6 GoQuorum uses Tessera as the private transaction manager to implement private transactions. Tessera: Stores and allows access to encrypted transaction data. Exchanges encrypted payloads with other Tessera nodes. Doesn\u2019t have access to any private keys. Uses an enclave for cryptographic functionality. The private transaction manager itself can optionally host an enclave. Is restful/stateless and can be load balanced. Configure a connection to the private transaction manager to enable private transactions. Enclave \u00b6 The enclave provides cryptographic functionality to the private transaction manager by managing the encryption and decryption in isolation. The enclave holds private keys and is essentially a virtual HSM isolated from other components. The separation of duties between the private transaction manager and enclave provide performance improvements and strengthens privacy. Public and private state \u00b6 GoQuorum supports two states: Public state, which is accessible by all nodes within the network Private state, which is only accessible by nodes with the correct permissions Public state transactions have non-encrypted payloads, while private state transactions have encrypted payloads. Nodes can only execute private transactions if they can access and decrypt the payload. All nodes share a common public state created through public transactions and have a local unique private state. Privacy enhancements and private state validation \u00b6 When privacy enhancements are enabled and private state validation (PSV) transactions are used, the GoQuorum node automatically verifies a contract\u2019s state across participating nodes. Privacy marker transactions \u00b6 Privacy marker transactions (PMTs) creates public PMTs and internal private transactions, and is an alternative to normal private transactions. A PMT allows for the corresponding internal private transaction to be kept off chain, with its contents and receipt hidden from public view. Contract state extension \u00b6 Contract state extension allows you to extend access to a private contract beyond its initial set of participants.","title":"Privacy"},{"location":"concepts/privacy/#privacy","text":"Privacy refers to the ability to keep transactions private between the involved participants. Other participants can\u2019t access the transaction content.","title":"Privacy"},{"location":"concepts/privacy/#private-transaction-manager","text":"GoQuorum uses Tessera as the private transaction manager to implement private transactions. Tessera: Stores and allows access to encrypted transaction data. Exchanges encrypted payloads with other Tessera nodes. Doesn\u2019t have access to any private keys. Uses an enclave for cryptographic functionality. The private transaction manager itself can optionally host an enclave. Is restful/stateless and can be load balanced. Configure a connection to the private transaction manager to enable private transactions.","title":"Private transaction manager"},{"location":"concepts/privacy/#enclave","text":"The enclave provides cryptographic functionality to the private transaction manager by managing the encryption and decryption in isolation. The enclave holds private keys and is essentially a virtual HSM isolated from other components. The separation of duties between the private transaction manager and enclave provide performance improvements and strengthens privacy.","title":"Enclave"},{"location":"concepts/privacy/#public-and-private-state","text":"GoQuorum supports two states: Public state, which is accessible by all nodes within the network Private state, which is only accessible by nodes with the correct permissions Public state transactions have non-encrypted payloads, while private state transactions have encrypted payloads. Nodes can only execute private transactions if they can access and decrypt the payload. All nodes share a common public state created through public transactions and have a local unique private state.","title":"Public and private state"},{"location":"concepts/privacy/#privacy-enhancements-and-private-state-validation","text":"When privacy enhancements are enabled and private state validation (PSV) transactions are used, the GoQuorum node automatically verifies a contract\u2019s state across participating nodes.","title":"Privacy enhancements and private state validation"},{"location":"concepts/privacy/#privacy-marker-transactions","text":"Privacy marker transactions (PMTs) creates public PMTs and internal private transactions, and is an alternative to normal private transactions. A PMT allows for the corresponding internal private transaction to be kept off chain, with its contents and receipt hidden from public view.","title":"Privacy marker transactions"},{"location":"concepts/privacy/#contract-state-extension","text":"Contract state extension allows you to extend access to a private contract beyond its initial set of participants.","title":"Contract state extension"},{"location":"concepts/privacy/contract-extension/","text":"Contract state extension \u00b6 A private contract is only available on the nodes on which it was initially deployed. New nodes don\u2019t have access to the private contract because they don\u2019t have the code and state associated with the contract. Contract state extension allows you to extend a private contract deployed to set of initial participant nodes to a new node. When extending a contract state to a node, the contract state at the time of the extension is shared, meaning the new recipient can\u2019t view the contract history. This also means events are not shared, as the transactions are not shared and no state transitions are calculated. Note Mandatory recipients are defined at contract creation time and can\u2019t be updated. However, contracts containing mandatory recipients can be extended to other nodes in the network. Enhanced network permissioning \u00b6 If the network is running with enhanced network permissioning , only a network or organization administrator can initiate or accept a contract extension. Flow \u00b6 The following diagram describes the flow of contract state extension. In this example, Node A extends an existing private contract to Nodes C that was initially deployed only between Nodes A and B. User in node A proposes the extension of the contract, citing node C\u2019s Private Transaction Manager(PTM) public keys as private participants of this extension, node C\u2019s public Ethereum key as a receiving address of this extension, and node C\u2019s PTM public key as the target receiver. 1a - Node A identifies all participants for the contract being extended and creates the extension contract with user given inputs and PTM public keys of all participants. 1b - the private transaction payload is shared with PTMs of participants. 1c - The public state is propagated across all nodes. All participant nodes see an emitted log, and start watching the contract address that emitted the event for subsequent events that may happen. This contract address is the management contract for the extension process. A new management contract is created with each extension. Node A automatically approves the contract extension by virtue of creating the extension contract. In the approval process: 2a - Node A calls its local Tessera node to encrypt the management contract address. 2b - Node A sends a private transaction to all participants with the encrypted payload from the previous step to generate a random hash for the approval process. 2c - The private transaction is propagated to the Tessera nodes of all participants. 2d - Node A approves the extension with the hash generated (in step 2b). 2e & 2f - Private transaction payload is shared with the Tessera nodes of all participants. Public state is propagated across all nodes. Since the state sharing does not execute the transactions that generate the state (in order to keep history private), there is no proof that can be provided by the proposer that the state is correct. In order to remedy this, the receiver must accept the proposal for the contract as the proof. In this step, the user of node C, as the receiving address, approves the contract extension using GoQuorum APIs. 3a - Node C calls its local Tessera node to encrypt the management contract address. 3b - Node C sends a private transaction to all participants with the encrypted payload from the previous step to generate a random hash for the approval process. 3c - The private transaction is propagated to the Tessera nodes of all participants. 3d - Node C approves the extension with the hash generated in step 3b. 3e & 3f - Private transaction payload is shared with the Tessera nodes of all participants. Public state is propagated across all nodes. Node A monitors for acceptance of contract extension by Node C. 4a & 4b - Node A fetches the state of the contract and sends it as a \u201cprivate transaction\u201d to Node C. It then submits the PTM hash of that state to the contract, including the recipient\u2019s PTM public key. 4c - Node A submits a transactions to mark completion of state share. This transaction emits a log that is picked up by the receiver when processing the transaction. 4d & 4e - Private transaction payload is shared with Tessera nodes C. Public state is propagated across all nodes. Node A & B monitors for state share event. 5a - Upon noticing the state share event as a part of block processing, node A & B update the privacy metadata for the contract being extended. This step is executed only for party protection or private state validation type of contracts. Node C monitors for state share event. 6a - Upon noticing the state share event as a part of block processing, node C fetches the contract private state data from its local Tessera node. 6b - Node C applies the fetched state to the contract address and becomes party of the private contract. Note Steps (2a, 2b, 2c) and (3a, 3b. 3c) are required to handle data recovery of transaction manager data. In original extension design, the node accepting the extension does so by voting with a hash which is generated by sending a private transaction with management contract address as the payload to self. This hash is further verified at the time of extension to validate the rightful node for extension. In the event if the node loses its transaction manager and has to recover transactions using resend from other nodes in the network, this self voting transaction is never recoverable. Subsequently if that node ever recovers the chain then it is never able to process the past contract extension transactions and set state for the private contract.","title":"Contract state extension"},{"location":"concepts/privacy/contract-extension/#contract-state-extension","text":"A private contract is only available on the nodes on which it was initially deployed. New nodes don\u2019t have access to the private contract because they don\u2019t have the code and state associated with the contract. Contract state extension allows you to extend a private contract deployed to set of initial participant nodes to a new node. When extending a contract state to a node, the contract state at the time of the extension is shared, meaning the new recipient can\u2019t view the contract history. This also means events are not shared, as the transactions are not shared and no state transitions are calculated. Note Mandatory recipients are defined at contract creation time and can\u2019t be updated. However, contracts containing mandatory recipients can be extended to other nodes in the network.","title":"Contract state extension"},{"location":"concepts/privacy/contract-extension/#enhanced-network-permissioning","text":"If the network is running with enhanced network permissioning , only a network or organization administrator can initiate or accept a contract extension.","title":"Enhanced network permissioning"},{"location":"concepts/privacy/contract-extension/#flow","text":"The following diagram describes the flow of contract state extension. In this example, Node A extends an existing private contract to Nodes C that was initially deployed only between Nodes A and B. User in node A proposes the extension of the contract, citing node C\u2019s Private Transaction Manager(PTM) public keys as private participants of this extension, node C\u2019s public Ethereum key as a receiving address of this extension, and node C\u2019s PTM public key as the target receiver. 1a - Node A identifies all participants for the contract being extended and creates the extension contract with user given inputs and PTM public keys of all participants. 1b - the private transaction payload is shared with PTMs of participants. 1c - The public state is propagated across all nodes. All participant nodes see an emitted log, and start watching the contract address that emitted the event for subsequent events that may happen. This contract address is the management contract for the extension process. A new management contract is created with each extension. Node A automatically approves the contract extension by virtue of creating the extension contract. In the approval process: 2a - Node A calls its local Tessera node to encrypt the management contract address. 2b - Node A sends a private transaction to all participants with the encrypted payload from the previous step to generate a random hash for the approval process. 2c - The private transaction is propagated to the Tessera nodes of all participants. 2d - Node A approves the extension with the hash generated (in step 2b). 2e & 2f - Private transaction payload is shared with the Tessera nodes of all participants. Public state is propagated across all nodes. Since the state sharing does not execute the transactions that generate the state (in order to keep history private), there is no proof that can be provided by the proposer that the state is correct. In order to remedy this, the receiver must accept the proposal for the contract as the proof. In this step, the user of node C, as the receiving address, approves the contract extension using GoQuorum APIs. 3a - Node C calls its local Tessera node to encrypt the management contract address. 3b - Node C sends a private transaction to all participants with the encrypted payload from the previous step to generate a random hash for the approval process. 3c - The private transaction is propagated to the Tessera nodes of all participants. 3d - Node C approves the extension with the hash generated in step 3b. 3e & 3f - Private transaction payload is shared with the Tessera nodes of all participants. Public state is propagated across all nodes. Node A monitors for acceptance of contract extension by Node C. 4a & 4b - Node A fetches the state of the contract and sends it as a \u201cprivate transaction\u201d to Node C. It then submits the PTM hash of that state to the contract, including the recipient\u2019s PTM public key. 4c - Node A submits a transactions to mark completion of state share. This transaction emits a log that is picked up by the receiver when processing the transaction. 4d & 4e - Private transaction payload is shared with Tessera nodes C. Public state is propagated across all nodes. Node A & B monitors for state share event. 5a - Upon noticing the state share event as a part of block processing, node A & B update the privacy metadata for the contract being extended. This step is executed only for party protection or private state validation type of contracts. Node C monitors for state share event. 6a - Upon noticing the state share event as a part of block processing, node C fetches the contract private state data from its local Tessera node. 6b - Node C applies the fetched state to the contract address and becomes party of the private contract. Note Steps (2a, 2b, 2c) and (3a, 3b. 3c) are required to handle data recovery of transaction manager data. In original extension design, the node accepting the extension does so by voting with a hash which is generated by sending a private transaction with management contract address as the payload to self. This hash is further verified at the time of extension to validate the rightful node for extension. In the event if the node loses its transaction manager and has to recover transactions using resend from other nodes in the network, this self voting transaction is never recoverable. Subsequently if that node ever recovers the chain then it is never able to process the past contract extension transactions and set state for the private contract.","title":"Flow"},{"location":"concepts/privacy/privacy-enhancements/","text":"Privacy enhancements \u00b6 In addition to standard privacy ( SP ) , GoQuorum provides three kinds of privacy enhancements: Counter-party protection ( PP ) Mandatory party protection ( MPP ) Private state validation ( PSV ) Counter-party protection \u00b6 Counter-party protection prevents non-participants from interacting with a private contract, without using access controls. For example, a private contract is deployed between nodes 1 and 2. Without counter-party protection, if node 3 discovers the private contract address, it can send a transaction with privateFor set to node 2. The transaction isn\u2019t applied to node 3\u2019s private state because node 3 isn\u2019t a participant in the private transaction, but the transaction is applied to node 2\u2019s private state. To enable counter-party protection, enable enhanced privacy and set privacyFlag to 1 when using send API methods . Mandatory party protection \u00b6 Mandatory party protection inherits all features of counter-party protection, and also allows you to define one or more recipients as mandatory for a private contract. The mandatory recipient is included in all subsequent transactions to the contract and has full private state, while normal recipients may only have partial state of the contract. Use mandatory party protection if you need governing or central nodes to have full private state for any contracts deployed in the network. To enable mandatory party protection, enable enhanced privacy and set privacyFlag to 2 and the mandatoryFor parameter to a list of mandatory recipients when using send API methods . Private state validation \u00b6 Private state validation prevents state divergence by ensuring that any private transaction for the contract is always sent to all participants. For example, a private contract is deployed between nodes 1 and 2. Without private state validation, node 1 can send a transaction to the private contract with a privateFor of [] . The transaction changes the private state of node 1 but not node 2, and the private states of 1 and 2 no longer match. With private state validation, a transaction from node 1 with a privateFor of [] is rejected and the transaction is processed only when privateFor contains both 1 and 2. Private state validation shares the full participant list among all participants, and validates against all subsequent transactions. Transactions sent to a subset of participants fail. In standard privacy or when only using counter-party protection , only the sender knows the full participant list. To enable private state validation, enable enhanced privacy and set privacyFlag to 3 when using send API methods . Using privacy enhancements \u00b6 Limitations \u00b6 Depending on the complexity of the contracts and the throughput of the network, the state at simulation time may differ from the chain state at the time the proposed transaction is published. If the state at publishing time is changed from simulation time, the corresponding PP , MPP , and PSV transactions fail on all participants. Furthermore, since state divergence is expected in PP and MPP contracts, it\u2019s possible (depending on contract design) for PP and MPP transactions to fail on some participants. Concurrency may also present a problem for PSV contracts. The execution hash calculation is based on the chain state at simulation time. Submitting multiple transactions to the same PSV contract from multiple nodes concurrently may result in most of the transactions failing. Important Because of these limitations, use privacy-enhanced transactions only when the enhanced privacy is necessary and the extra privacy benefits outweigh the potential shortfalls. Transaction interactions \u00b6 No interactions are allowed between the different types of private transactions. The only allowed interaction is for private contracts ( SP , PP , MPP , and PSV ) to read from public contracts. The privacy enhancements feature only performs its checks on published transactions. None of the limitations apply to calls (read only transactions); calls are contract method invocations executed locally and don\u2019t result in published transactions. Enabling privacy enhancements \u00b6 To enable privacy enhancements in Tessera, set the enablePrivacyEnhancements parameter in the Tessera configuration file to true . To enable privacy enhancements in GoQuorum, set the privacyEnhancementsBlock in the GoQuorum genesis file config object to a future block, when the entire network is ready to transact with privacy-enhanced transactions. All GoQuorum nodes in the network must be initialized with the same privacyEnhancementsBlock value. Note You need to re-run geth init when you update the genesis file to incorporate the changes. This does not delete or modify any current sync process or saved blocks. You can disable enablePrivacyEnhancements in the Tessera configuration if your GoQuorum node is not ready to support privacy enhancements. This allows the GoQuorum node to reject PP , MPP , and PSV transactions from other nodes until the node is ready to support privacy-enhanced transactions. Backward compatibility \u00b6 An upgraded GoQuorum node can coexist on a network where other nodes are running earlier GoQuorum versions. However, it can\u2019t support privacy-enhanced contracts until all interested nodes are upgraded and enable privacy. Important If an upgraded but non-privacy-enabled GoQuorum node receives a PP , MPP , or PSV transaction, the node logs a BAD BLOCK error. If the consensus algorithm is Raft, the node stops. If the consensus algorithm is IBFT or QBFT, the node keeps trying to add the bad block, and reprints the errors. It won\u2019t catch up with rest of nodes until restarted and reinitialized with the correct privacyEnhancementsBlock . If you set the enablePrivacyEnhancements flag to true in Tessera without enabling privacy in GoQuorum, the node can crash, as the Tessera node accepts PP , MPP , and PSV transactions. An upgraded Tessera node can continue to communicate with Tessera nodes running on previous versions using SP transactions.","title":"Privacy enhancements"},{"location":"concepts/privacy/privacy-enhancements/#privacy-enhancements","text":"In addition to standard privacy ( SP ) , GoQuorum provides three kinds of privacy enhancements: Counter-party protection ( PP ) Mandatory party protection ( MPP ) Private state validation ( PSV )","title":"Privacy enhancements"},{"location":"concepts/privacy/privacy-enhancements/#counter-party-protection","text":"Counter-party protection prevents non-participants from interacting with a private contract, without using access controls. For example, a private contract is deployed between nodes 1 and 2. Without counter-party protection, if node 3 discovers the private contract address, it can send a transaction with privateFor set to node 2. The transaction isn\u2019t applied to node 3\u2019s private state because node 3 isn\u2019t a participant in the private transaction, but the transaction is applied to node 2\u2019s private state. To enable counter-party protection, enable enhanced privacy and set privacyFlag to 1 when using send API methods .","title":"Counter-party protection"},{"location":"concepts/privacy/privacy-enhancements/#mandatory-party-protection","text":"Mandatory party protection inherits all features of counter-party protection, and also allows you to define one or more recipients as mandatory for a private contract. The mandatory recipient is included in all subsequent transactions to the contract and has full private state, while normal recipients may only have partial state of the contract. Use mandatory party protection if you need governing or central nodes to have full private state for any contracts deployed in the network. To enable mandatory party protection, enable enhanced privacy and set privacyFlag to 2 and the mandatoryFor parameter to a list of mandatory recipients when using send API methods .","title":"Mandatory party protection"},{"location":"concepts/privacy/privacy-enhancements/#private-state-validation","text":"Private state validation prevents state divergence by ensuring that any private transaction for the contract is always sent to all participants. For example, a private contract is deployed between nodes 1 and 2. Without private state validation, node 1 can send a transaction to the private contract with a privateFor of [] . The transaction changes the private state of node 1 but not node 2, and the private states of 1 and 2 no longer match. With private state validation, a transaction from node 1 with a privateFor of [] is rejected and the transaction is processed only when privateFor contains both 1 and 2. Private state validation shares the full participant list among all participants, and validates against all subsequent transactions. Transactions sent to a subset of participants fail. In standard privacy or when only using counter-party protection , only the sender knows the full participant list. To enable private state validation, enable enhanced privacy and set privacyFlag to 3 when using send API methods .","title":"Private state validation"},{"location":"concepts/privacy/privacy-enhancements/#using-privacy-enhancements","text":"","title":"Using privacy enhancements"},{"location":"concepts/privacy/privacy-enhancements/#limitations","text":"Depending on the complexity of the contracts and the throughput of the network, the state at simulation time may differ from the chain state at the time the proposed transaction is published. If the state at publishing time is changed from simulation time, the corresponding PP , MPP , and PSV transactions fail on all participants. Furthermore, since state divergence is expected in PP and MPP contracts, it\u2019s possible (depending on contract design) for PP and MPP transactions to fail on some participants. Concurrency may also present a problem for PSV contracts. The execution hash calculation is based on the chain state at simulation time. Submitting multiple transactions to the same PSV contract from multiple nodes concurrently may result in most of the transactions failing. Important Because of these limitations, use privacy-enhanced transactions only when the enhanced privacy is necessary and the extra privacy benefits outweigh the potential shortfalls.","title":"Limitations"},{"location":"concepts/privacy/privacy-enhancements/#transaction-interactions","text":"No interactions are allowed between the different types of private transactions. The only allowed interaction is for private contracts ( SP , PP , MPP , and PSV ) to read from public contracts. The privacy enhancements feature only performs its checks on published transactions. None of the limitations apply to calls (read only transactions); calls are contract method invocations executed locally and don\u2019t result in published transactions.","title":"Transaction interactions"},{"location":"concepts/privacy/privacy-enhancements/#enabling-privacy-enhancements","text":"To enable privacy enhancements in Tessera, set the enablePrivacyEnhancements parameter in the Tessera configuration file to true . To enable privacy enhancements in GoQuorum, set the privacyEnhancementsBlock in the GoQuorum genesis file config object to a future block, when the entire network is ready to transact with privacy-enhanced transactions. All GoQuorum nodes in the network must be initialized with the same privacyEnhancementsBlock value. Note You need to re-run geth init when you update the genesis file to incorporate the changes. This does not delete or modify any current sync process or saved blocks. You can disable enablePrivacyEnhancements in the Tessera configuration if your GoQuorum node is not ready to support privacy enhancements. This allows the GoQuorum node to reject PP , MPP , and PSV transactions from other nodes until the node is ready to support privacy-enhanced transactions.","title":"Enabling privacy enhancements"},{"location":"concepts/privacy/privacy-enhancements/#backward-compatibility","text":"An upgraded GoQuorum node can coexist on a network where other nodes are running earlier GoQuorum versions. However, it can\u2019t support privacy-enhanced contracts until all interested nodes are upgraded and enable privacy. Important If an upgraded but non-privacy-enabled GoQuorum node receives a PP , MPP , or PSV transaction, the node logs a BAD BLOCK error. If the consensus algorithm is Raft, the node stops. If the consensus algorithm is IBFT or QBFT, the node keeps trying to add the bad block, and reprints the errors. It won\u2019t catch up with rest of nodes until restarted and reinitialized with the correct privacyEnhancementsBlock . If you set the enablePrivacyEnhancements flag to true in Tessera without enabling privacy in GoQuorum, the node can crash, as the Tessera node accepts PP , MPP , and PSV transactions. An upgraded Tessera node can continue to communicate with Tessera nodes running on previous versions using SP transactions.","title":"Backward compatibility"},{"location":"concepts/privacy/privacy-marker-transactions/","text":"Privacy marker transactions \u00b6 You can use privacy marker transactions (PMTs) instead of normal private transactions . PMTs are public transactions. PMTs each have a corresponding internal private transaction stored in the private transaction manager (Tessera) and only available to participants. The advantages of using a PMT over a normal private transaction are: The contract address is hidden from public view. The private transaction receipt is only visible to participants of the private transaction. The private transaction itself is stored in the private transaction manager and is only visible to participants. PMTs use a privacy precompile contract, which retrieves the internal private transaction from Tessera and executes it. See the PMT high-level lifecycle . Privacy marker transaction \u00b6 A PMT is a public transaction with the following parameters: to - privacy precompile contract address input or data - sender address and Tessera hash of the encrypted internal private transaction from - the same signing account as the internal private transaction contractAddress - (in receipt if the PMT is a contract creation transaction) null logs and logsBloom (in receipt) - empty Example PMT and its receipt > e t h.ge t Tra nsa c t io n ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { ... blockNumber : 121 , hash : \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : \"0x000000000000000000000000000000000000007a\" , i n pu t : \"0xd174e0b4ddc86936479655ec5c218530c0270afcff1c337caa81e12610f2182d95c642bf297d65592078d7c5509dc0cb0d3c01ea1a5bc4110c004603702d3d8c\" , n o n ce : 2 , r : \"0x35ea14362403065174863c07d8de5e9f85c365f19ddde7f907f44ebacba6f63a\" , s : \"0x1d3c2a8b8342fc086501a9e95361430b221d80e2f4076b6c37f52dac47fff0f0\" , v : \"0x38\" , transa c t io n I n dex : 0 , ... } > e t h.ge t Tra nsa c t io n Receip t ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { ... blockNumber : 121 , transa c t io n Hash : \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" , co ntra c t Address : null , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : \"0x000000000000000000000000000000000000007a\" , logs : [], logsBloom : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , s tatus : \"0x1\" , transa c t io n I n dex : 0 , ... } Internal private transaction \u00b6 Each PMT has a corresponding internal private transaction. The content of this private transaction is the same as the content of a normal private transaction , except it has the same from and nonce values as the PMT. Only the hash of the encrypted internal private transaction is stored on chain (as part of the data field of the PMT). The internal private transaction is stored and encrypted in each participant\u2019s Tessera node. As a result, the internal private transaction is only available to participants of the private transaction. At execution time, GoQuorum retrieves the internal private transaction from Tessera. Example internal private transaction and its receipt > e t h.ge t Priva te Tra nsa c t io n ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { ... blockNumber : 121 , hash : \"0xbf71ea018f64b6449319b733baa188f5f1e6093306604004cf30d1688c940865\" , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : null , i n pu t : \"0x15b446504790aec35713ebf947490e8674a018958ced63841ebe1ffc447ce52f2c8654f6affb907d5a744606293f6e9f4cf4a210a44041b5ec3696e01d917f3a\" , n o n ce : 3 , r : \"0x32d982ba0a48083821c0ff013119dce988205a2699485e7a4019911030bddabc\" , s : \"0x41870f25243701e4187bb24b69d71b711de6cac742445e0cef501d0705119f1a\" , v : \"0x25\" , transa c t io n I n dex : 0 , ... } > e t h.ge t Priva te Tra nsa c t io n Receip t ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { blockNumber : 121 , transa c t io n Hash : \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" , co ntra c t Address : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : null , logs : [{ ... , address : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , blockNumber : 121 , da ta : \"0x000000000000000000000000000000000000000000000000000000000000000a\" , logI n dex : 0 , t opics : [ \"0x6c2b4666ba8da5a95717621d879a77de725f3d816709b9cbe9f059b8f875e284\" ], transa c t io n Hash : \"0xbf71ea018f64b6449319b733baa188f5f1e6093306604004cf30d1688c940865\" , transa c t io n I n dex : 0 , ... }], logsBloom : \"0x00000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000400000000000000000000000001000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , s tatus : \"0x1\" , transa c t io n I n dex : 0 , ... } Using privacy marker transactions \u00b6 To enable PMTs in GoQuorum, set the privacyPrecompileBlock in the GoQuorum genesis file config object to a block where the network is ready to support the privacy precompile. Once the fork block is reached, the node can process and use PMTs. All GoQuorum nodes in the network should be initialized with the same privacyPrecompileBlock value. Use the --privacymarker.enable command line option when starting GoQuorum to enable PMTs. Note Once the privacyPrecompileBlock is reached, a node without the --privacymarker.enable CLI flag can still receive and correctly process PMTs sent from other nodes. Use the following API methods to interact with PMTs: eth_distributePrivateTransaction eth_getPrivacyPrecompileAddress eth_getPrivateTransactionByHash eth_getPrivateTransactionReceipt Important The PMT and internal private transaction are separate transactions and have separate transaction receipts. Sending unsigned private transactions \u00b6 To send an unsigned private transaction as a PMT, use the same API methods as with normal private transactions, such as eth_sendTransaction . If the following conditions are met, the private transaction is created as a PMT and internal private transaction: privateFor is provided. The privacyPrecompileBlock has been reached. The GoQuorum node is started with the --privacymarker.enable option. Sending signed private transactions \u00b6 Use eth_fillTransaction or Tessera\u2019s third party /storeraw API to encrypt the private transaction payload. Create the private transaction, replacing the data value with the hash of the encrypted private transaction payload from Tessera. Externally sign the private transaction. Use eth_distributePrivateTransaction to encrypt the signed private transaction and share with all participants. Create the PMT, with the data value set to the hash returned by eth_distributePrivateTransaction . The from and nonce values must be the same as the private transaction. Send the PMT using the same APIs as with normal private transactions, such as eth_sendTransaction .","title":"Privacy marker transactions"},{"location":"concepts/privacy/privacy-marker-transactions/#privacy-marker-transactions","text":"You can use privacy marker transactions (PMTs) instead of normal private transactions . PMTs are public transactions. PMTs each have a corresponding internal private transaction stored in the private transaction manager (Tessera) and only available to participants. The advantages of using a PMT over a normal private transaction are: The contract address is hidden from public view. The private transaction receipt is only visible to participants of the private transaction. The private transaction itself is stored in the private transaction manager and is only visible to participants. PMTs use a privacy precompile contract, which retrieves the internal private transaction from Tessera and executes it. See the PMT high-level lifecycle .","title":"Privacy marker transactions"},{"location":"concepts/privacy/privacy-marker-transactions/#privacy-marker-transaction","text":"A PMT is a public transaction with the following parameters: to - privacy precompile contract address input or data - sender address and Tessera hash of the encrypted internal private transaction from - the same signing account as the internal private transaction contractAddress - (in receipt if the PMT is a contract creation transaction) null logs and logsBloom (in receipt) - empty Example PMT and its receipt > e t h.ge t Tra nsa c t io n ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { ... blockNumber : 121 , hash : \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : \"0x000000000000000000000000000000000000007a\" , i n pu t : \"0xd174e0b4ddc86936479655ec5c218530c0270afcff1c337caa81e12610f2182d95c642bf297d65592078d7c5509dc0cb0d3c01ea1a5bc4110c004603702d3d8c\" , n o n ce : 2 , r : \"0x35ea14362403065174863c07d8de5e9f85c365f19ddde7f907f44ebacba6f63a\" , s : \"0x1d3c2a8b8342fc086501a9e95361430b221d80e2f4076b6c37f52dac47fff0f0\" , v : \"0x38\" , transa c t io n I n dex : 0 , ... } > e t h.ge t Tra nsa c t io n Receip t ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { ... blockNumber : 121 , transa c t io n Hash : \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" , co ntra c t Address : null , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : \"0x000000000000000000000000000000000000007a\" , logs : [], logsBloom : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , s tatus : \"0x1\" , transa c t io n I n dex : 0 , ... }","title":"Privacy marker transaction"},{"location":"concepts/privacy/privacy-marker-transactions/#internal-private-transaction","text":"Each PMT has a corresponding internal private transaction. The content of this private transaction is the same as the content of a normal private transaction , except it has the same from and nonce values as the PMT. Only the hash of the encrypted internal private transaction is stored on chain (as part of the data field of the PMT). The internal private transaction is stored and encrypted in each participant\u2019s Tessera node. As a result, the internal private transaction is only available to participants of the private transaction. At execution time, GoQuorum retrieves the internal private transaction from Tessera. Example internal private transaction and its receipt > e t h.ge t Priva te Tra nsa c t io n ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { ... blockNumber : 121 , hash : \"0xbf71ea018f64b6449319b733baa188f5f1e6093306604004cf30d1688c940865\" , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : null , i n pu t : \"0x15b446504790aec35713ebf947490e8674a018958ced63841ebe1ffc447ce52f2c8654f6affb907d5a744606293f6e9f4cf4a210a44041b5ec3696e01d917f3a\" , n o n ce : 3 , r : \"0x32d982ba0a48083821c0ff013119dce988205a2699485e7a4019911030bddabc\" , s : \"0x41870f25243701e4187bb24b69d71b711de6cac742445e0cef501d0705119f1a\" , v : \"0x25\" , transa c t io n I n dex : 0 , ... } > e t h.ge t Priva te Tra nsa c t io n Receip t ( \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" ) { blockNumber : 121 , transa c t io n Hash : \"0x5b7f615e47a8a607ba2b11598f3eccb9be7ac43875f50abd54bdbbcfaeccbb79\" , co ntra c t Address : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , t o : null , logs : [{ ... , address : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , blockNumber : 121 , da ta : \"0x000000000000000000000000000000000000000000000000000000000000000a\" , logI n dex : 0 , t opics : [ \"0x6c2b4666ba8da5a95717621d879a77de725f3d816709b9cbe9f059b8f875e284\" ], transa c t io n Hash : \"0xbf71ea018f64b6449319b733baa188f5f1e6093306604004cf30d1688c940865\" , transa c t io n I n dex : 0 , ... }], logsBloom : \"0x00000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000400000000000000000000000001000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , s tatus : \"0x1\" , transa c t io n I n dex : 0 , ... }","title":"Internal private transaction"},{"location":"concepts/privacy/privacy-marker-transactions/#using-privacy-marker-transactions","text":"To enable PMTs in GoQuorum, set the privacyPrecompileBlock in the GoQuorum genesis file config object to a block where the network is ready to support the privacy precompile. Once the fork block is reached, the node can process and use PMTs. All GoQuorum nodes in the network should be initialized with the same privacyPrecompileBlock value. Use the --privacymarker.enable command line option when starting GoQuorum to enable PMTs. Note Once the privacyPrecompileBlock is reached, a node without the --privacymarker.enable CLI flag can still receive and correctly process PMTs sent from other nodes. Use the following API methods to interact with PMTs: eth_distributePrivateTransaction eth_getPrivacyPrecompileAddress eth_getPrivateTransactionByHash eth_getPrivateTransactionReceipt Important The PMT and internal private transaction are separate transactions and have separate transaction receipts.","title":"Using privacy marker transactions"},{"location":"concepts/privacy/privacy-marker-transactions/#sending-unsigned-private-transactions","text":"To send an unsigned private transaction as a PMT, use the same API methods as with normal private transactions, such as eth_sendTransaction . If the following conditions are met, the private transaction is created as a PMT and internal private transaction: privateFor is provided. The privacyPrecompileBlock has been reached. The GoQuorum node is started with the --privacymarker.enable option.","title":"Sending unsigned private transactions"},{"location":"concepts/privacy/privacy-marker-transactions/#sending-signed-private-transactions","text":"Use eth_fillTransaction or Tessera\u2019s third party /storeraw API to encrypt the private transaction payload. Create the private transaction, replacing the data value with the hash of the encrypted private transaction payload from Tessera. Externally sign the private transaction. Use eth_distributePrivateTransaction to encrypt the signed private transaction and share with all participants. Create the PMT, with the data value set to the hash returned by eth_distributePrivateTransaction . The from and nonce values must be the same as the private transaction. Send the PMT using the same APIs as with normal private transactions, such as eth_sendTransaction .","title":"Sending signed private transactions"},{"location":"concepts/privacy/private-and-public/","text":"Public and private transactions \u00b6 GoQuorum achieves transaction privacy by: Enabling transaction senders to create private transactions by marking who is privy to a transaction via the privateFor parameter. Storing encrypted private data off-chain in a separate component called the private transaction manager . The private transaction manager encrypts private data, distributes the encrypted data to other parties that are privy to the transaction, and returns the decrypted payload to those parties. Replacing the payload of a private transaction with a key for the location of the encrypted payload, such that the original payload isn\u2019t visible to participants who aren\u2019t privy to the transaction. Note While GoQuorum introduces the notion of \u201cpublic transactions\u201d and \u201cprivate transactions,\u201d it does not introduce new transaction types. Rather, it extends the Ethereum transaction model to include an optional privateFor parameter (the inclusion of which results in GoQuorum treating a transaction as private) and the transaction type has a new IsPrivate method to identify private transactions. Public transactions \u00b6 Public transactions have payloads that are visible to all participants of the same network. These are created as standard Ethereum transactions . Examples of public transactions include market data updates from a service provider, or a reference data update such as a correction to a bond security definition. Note GoQuorum public transactions are not transactions from the public Ethereum network. Perhaps a more appropriate term would be \u201ccommon\u201d or \u201cglobal\u201d transactions, but \u201cpublic\u201d is used to contrast with \u201cprivate\u201d transactions. Private transactions \u00b6 Private transactions have payloads that are visible only to the network participants whose public keys are specified in the privateFor parameter of the transaction. privateFor can take multiple addresses in a comma-separated list. When a GoQuorum node encounters a transaction with a non-null privateFor value, it sets the v value of the transaction signature to 37 or 38 (as opposed to public transactions, whose v values are set according to EIP-155 ). Notes privateFor is not shared with other participants; it\u2019s only used to identify which nodes to send the encrypted payload to. There\u2019s no direct restriction on private transaction size. As with public transactions, the only restriction is the gas limit. See the private transaction high-level lifecycle . You can enable private transactions by configuring the private transaction manager connection , and you can send private transactions . Public vs. private transaction handling \u00b6 Public transactions are executed in the standard Ethereum way. If a public transaction is sent to an account that holds contract code, each participant executes the same code, and their state databases are updated accordingly. Private transactions are executed differently: before the sender\u2019s GoQuorum node propagates the transaction to the rest of the network, the node substitutes the original transaction payload with a key for the location of the encrypted payload received from Tessera. Participants privy to the transaction can replace the hash with the original payload via their Tessera instance, while participants not privy only see the hash. If a private transaction is sent to an account that holds contract code, participants not privy to the transaction skip the transaction and don\u2019t execute the contract code. Participants privy to the transaction replace the hash and call the virtual machine for execution, and their state databases update accordingly. Note See the private transaction high-level lifecycle for an illustrated example. As a result, these two sets of participants end up with different state databases and can\u2019t reach consensus. To support this forking of contract state, GoQuorum stores the state of public contracts in a public state trie that is globally synchronized, and the state of private contracts in a private state trie not globally synchronized. State verification \u00b6 Block validation includes a check on the root of the public state trie to determine if the public state is synchronized across nodes. It also includes a check the global transaction hash, which is a hash of all public and private transactions in a block. This means that each node can validate that it has the same set of transactions as other nodes. Synchronization of the public state root and private transaction inputs (through the global transaction hash) can imply synchronization of the private state across participating nodes. To further validate that the private state change from a private transaction is the same across all participants, use eth_storageRoot specifying the private smart contract address and block height. If the state is in sync across all participating nodes, they return the same root hash. Limitations \u00b6 This model imposes a restriction on the ability to change public state in private transactions. Since a common use case for a private contract is to read data from a public contract, the virtual machine changes to read only mode for each call from a private contract to a public contract. If the virtual machine is in read only mode, and the code tries to make a state change, the virtual machine stops execution and throws an exception.","title":"Public and private transactions"},{"location":"concepts/privacy/private-and-public/#public-and-private-transactions","text":"GoQuorum achieves transaction privacy by: Enabling transaction senders to create private transactions by marking who is privy to a transaction via the privateFor parameter. Storing encrypted private data off-chain in a separate component called the private transaction manager . The private transaction manager encrypts private data, distributes the encrypted data to other parties that are privy to the transaction, and returns the decrypted payload to those parties. Replacing the payload of a private transaction with a key for the location of the encrypted payload, such that the original payload isn\u2019t visible to participants who aren\u2019t privy to the transaction. Note While GoQuorum introduces the notion of \u201cpublic transactions\u201d and \u201cprivate transactions,\u201d it does not introduce new transaction types. Rather, it extends the Ethereum transaction model to include an optional privateFor parameter (the inclusion of which results in GoQuorum treating a transaction as private) and the transaction type has a new IsPrivate method to identify private transactions.","title":"Public and private transactions"},{"location":"concepts/privacy/private-and-public/#public-transactions","text":"Public transactions have payloads that are visible to all participants of the same network. These are created as standard Ethereum transactions . Examples of public transactions include market data updates from a service provider, or a reference data update such as a correction to a bond security definition. Note GoQuorum public transactions are not transactions from the public Ethereum network. Perhaps a more appropriate term would be \u201ccommon\u201d or \u201cglobal\u201d transactions, but \u201cpublic\u201d is used to contrast with \u201cprivate\u201d transactions.","title":"Public transactions"},{"location":"concepts/privacy/private-and-public/#private-transactions","text":"Private transactions have payloads that are visible only to the network participants whose public keys are specified in the privateFor parameter of the transaction. privateFor can take multiple addresses in a comma-separated list. When a GoQuorum node encounters a transaction with a non-null privateFor value, it sets the v value of the transaction signature to 37 or 38 (as opposed to public transactions, whose v values are set according to EIP-155 ). Notes privateFor is not shared with other participants; it\u2019s only used to identify which nodes to send the encrypted payload to. There\u2019s no direct restriction on private transaction size. As with public transactions, the only restriction is the gas limit. See the private transaction high-level lifecycle . You can enable private transactions by configuring the private transaction manager connection , and you can send private transactions .","title":"Private transactions"},{"location":"concepts/privacy/private-and-public/#public-vs-private-transaction-handling","text":"Public transactions are executed in the standard Ethereum way. If a public transaction is sent to an account that holds contract code, each participant executes the same code, and their state databases are updated accordingly. Private transactions are executed differently: before the sender\u2019s GoQuorum node propagates the transaction to the rest of the network, the node substitutes the original transaction payload with a key for the location of the encrypted payload received from Tessera. Participants privy to the transaction can replace the hash with the original payload via their Tessera instance, while participants not privy only see the hash. If a private transaction is sent to an account that holds contract code, participants not privy to the transaction skip the transaction and don\u2019t execute the contract code. Participants privy to the transaction replace the hash and call the virtual machine for execution, and their state databases update accordingly. Note See the private transaction high-level lifecycle for an illustrated example. As a result, these two sets of participants end up with different state databases and can\u2019t reach consensus. To support this forking of contract state, GoQuorum stores the state of public contracts in a public state trie that is globally synchronized, and the state of private contracts in a private state trie not globally synchronized.","title":"Public vs. private transaction handling"},{"location":"concepts/privacy/private-and-public/#state-verification","text":"Block validation includes a check on the root of the public state trie to determine if the public state is synchronized across nodes. It also includes a check the global transaction hash, which is a hash of all public and private transactions in a block. This means that each node can validate that it has the same set of transactions as other nodes. Synchronization of the public state root and private transaction inputs (through the global transaction hash) can imply synchronization of the private state across participating nodes. To further validate that the private state change from a private transaction is the same across all participants, use eth_storageRoot specifying the private smart contract address and block height. If the state is in sync across all participating nodes, they return the same root hash.","title":"State verification"},{"location":"concepts/privacy/private-and-public/#limitations","text":"This model imposes a restriction on the ability to change public state in private transactions. Since a common use case for a private contract is to read data from a public contract, the virtual machine changes to read only mode for each call from a private contract to a public contract. If the virtual machine is in read only mode, and the code tries to make a state change, the virtual machine stops execution and throws an exception.","title":"Limitations"},{"location":"concepts/privacy/private-transaction-lifecycle/","text":"Private transaction lifecycle \u00b6 This topic illustrates the high-level lifecycle of normal private transactions and privacy marker transactions (PMTs) . In both examples, participants A and B are party to the transaction and participant C is not. Normal private transactions \u00b6 Participant A sends a private transaction to their GoQuorum node A. GoQuorum serializes the private transaction data value to JSON and sends it to Tessera node A with participant details. Tessera encrypts the data and distributes it to transaction participants. Tessera returns the hash of the encrypted data to GoQuorum node A. GoQuorum replaces the private transaction data value with the hash. GoQuorum signs the private transaction and sets the v value to 37 or 38 to mark the transaction as private. GoQuorum distributes the private transaction throughout the network. All nodes can see the transaction. Only transaction participants (participants A and B) can get the decrypted data from Tessera and execute the transaction. Privacy marker transactions \u00b6 Participant A sends a private transaction to their GoQuorum node A. GoQuorum serializes the private transaction data value to JSON and sends it to Tessera node A with participant details. Tessera encrypts the data and distributes it to transaction participants. Tessera returns the hash of the encrypted data to GoQuorum node A. GoQuorum creates a public PMT with the data field set to the hash. GoQuorum signs the PMT. GoQuorum distributes the PMT throughout the network. All nodes can see the PMT. The PMT is processed in the same way as a standard public transaction. Since the PMT\u2019s to value is the address of the privacy precompile contract, that contract is called. GoQuorum nodes B and C call the privacy precompile with the PMT data . GoQuorum attempts to retrieve the decrypted private transaction from Tessera using the publicly available hash from the PMT. Action depends on whether the node is a transaction participant: Participant: GoQuorum gets the decrypted data of the private transaction from Tessera and the privacy precompile executes the private transaction. Non-participant: No private transaction is found, so the privacy precompile returns immediately.","title":"Private transaction lifecycle"},{"location":"concepts/privacy/private-transaction-lifecycle/#private-transaction-lifecycle","text":"This topic illustrates the high-level lifecycle of normal private transactions and privacy marker transactions (PMTs) . In both examples, participants A and B are party to the transaction and participant C is not.","title":"Private transaction lifecycle"},{"location":"concepts/privacy/private-transaction-lifecycle/#normal-private-transactions","text":"Participant A sends a private transaction to their GoQuorum node A. GoQuorum serializes the private transaction data value to JSON and sends it to Tessera node A with participant details. Tessera encrypts the data and distributes it to transaction participants. Tessera returns the hash of the encrypted data to GoQuorum node A. GoQuorum replaces the private transaction data value with the hash. GoQuorum signs the private transaction and sets the v value to 37 or 38 to mark the transaction as private. GoQuorum distributes the private transaction throughout the network. All nodes can see the transaction. Only transaction participants (participants A and B) can get the decrypted data from Tessera and execute the transaction.","title":"Normal private transactions"},{"location":"concepts/privacy/private-transaction-lifecycle/#privacy-marker-transactions","text":"Participant A sends a private transaction to their GoQuorum node A. GoQuorum serializes the private transaction data value to JSON and sends it to Tessera node A with participant details. Tessera encrypts the data and distributes it to transaction participants. Tessera returns the hash of the encrypted data to GoQuorum node A. GoQuorum creates a public PMT with the data field set to the hash. GoQuorum signs the PMT. GoQuorum distributes the PMT throughout the network. All nodes can see the PMT. The PMT is processed in the same way as a standard public transaction. Since the PMT\u2019s to value is the address of the privacy precompile contract, that contract is called. GoQuorum nodes B and C call the privacy precompile with the PMT data . GoQuorum attempts to retrieve the decrypted private transaction from Tessera using the publicly available hash from the PMT. Action depends on whether the node is a transaction participant: Participant: GoQuorum gets the decrypted data of the private transaction from Tessera and the privacy precompile executes the private transaction. Non-participant: No private transaction is found, so the privacy precompile returns immediately.","title":"Privacy marker transactions"},{"location":"configure-and-manage/configure/bootnodes/","text":"Configure bootnodes \u00b6 You can use bootnodes in GoQuorum to initially discover peers. Bootnodes are regular nodes used to discover other nodes. Tip Bootnodes and static nodes are parallel methods for finding peers. Depending on your use case, you can use only bootnodes, only static nodes, or both. To find peers, configure one or more bootnodes as described on this page. To configure a specific set of peer connections, use static nodes . Development and testing networks \u00b6 In private GoQuorum networks for development or testing purposes, specify at least one bootnode. In production networks, configure two or more nodes as bootnodes . Specifying a bootnode \u00b6 To start a node, specify a bootnode enode URL for P2P discovery, using the --bootnodes option. Example geth --datadir nodeDataPath --bootnodes enode://c35c3ec90a8a51fd5703594c6303382f3ae6b2ecb99bab2c04b3794f2bc3fc2631dabb0c08af795787a6c004d8f532230ae6e9925cbbefb0b28b79295d615f@127.0.0.1:30303 The default host and port advertised to other peers for P2P discovery is 127.0.0.1:30303 . To specify a different host or port, use the --discovery.dns and --port options. Production networks \u00b6 A GoQuorum network must have at least one operating bootnode. To allow for continuity in the event of failure, configure two or more bootnodes. We recommend putting bootnodes on the network itself and not behind a load balancer because the enode URL relates to the node public key, IP address, and discovery ports. Any changes to a bootnode enode prevents other nodes from being able to establish a connection with the bootnode. To ensure that a bootnode enode does not change when recovering from a complete bootnode failure: Create the node key pair (the private and public key) before starting the bootnode. When creating bootnodes in the cloud (for example, AWS or Azure), attempt to assign a static private IP address to them, and record this IP address. We recommend that you store the bootnode configuration under source control. Specifying multiple bootnodes \u00b6 To allow for continuity in the event of failure, specify all bootnodes in a comma-separated list using the --bootnodes option for each node, including the bootnodes. Example If your network has two bootnodes, pass the following parameter to all nodes, including the bootnodes. --bootnodes = enode://<publicKeyBootnode1>@<ipBootnode1>:30303,<publicKeyBootnode2>@<ipBootnode2>:30303 Tip Having each bootnode include the other bootnodes increases the speed of discovery. Nodes ignore their own enode in the bootnodes list so you can use the same bootnode list for all bootnodes. Adding and removing bootnodes \u00b6 Adding new bootnodes is a similar process to creating bootnodes. After creating the bootnodes and adding them to the network, update the --bootnodes command line option for each node to include the new bootnodes. When adding bootnodes, you don\u2019t need to restart running nodes. By updating the --bootnodes option, the next time you restart the nodes, the nodes connect to the new bootnodes. To remove bootnodes, remove them from the --bootnodes option for each node.","title":"Bootnodes"},{"location":"configure-and-manage/configure/bootnodes/#configure-bootnodes","text":"You can use bootnodes in GoQuorum to initially discover peers. Bootnodes are regular nodes used to discover other nodes. Tip Bootnodes and static nodes are parallel methods for finding peers. Depending on your use case, you can use only bootnodes, only static nodes, or both. To find peers, configure one or more bootnodes as described on this page. To configure a specific set of peer connections, use static nodes .","title":"Configure bootnodes"},{"location":"configure-and-manage/configure/bootnodes/#development-and-testing-networks","text":"In private GoQuorum networks for development or testing purposes, specify at least one bootnode. In production networks, configure two or more nodes as bootnodes .","title":"Development and testing networks"},{"location":"configure-and-manage/configure/bootnodes/#specifying-a-bootnode","text":"To start a node, specify a bootnode enode URL for P2P discovery, using the --bootnodes option. Example geth --datadir nodeDataPath --bootnodes enode://c35c3ec90a8a51fd5703594c6303382f3ae6b2ecb99bab2c04b3794f2bc3fc2631dabb0c08af795787a6c004d8f532230ae6e9925cbbefb0b28b79295d615f@127.0.0.1:30303 The default host and port advertised to other peers for P2P discovery is 127.0.0.1:30303 . To specify a different host or port, use the --discovery.dns and --port options.","title":"Specifying a bootnode"},{"location":"configure-and-manage/configure/bootnodes/#production-networks","text":"A GoQuorum network must have at least one operating bootnode. To allow for continuity in the event of failure, configure two or more bootnodes. We recommend putting bootnodes on the network itself and not behind a load balancer because the enode URL relates to the node public key, IP address, and discovery ports. Any changes to a bootnode enode prevents other nodes from being able to establish a connection with the bootnode. To ensure that a bootnode enode does not change when recovering from a complete bootnode failure: Create the node key pair (the private and public key) before starting the bootnode. When creating bootnodes in the cloud (for example, AWS or Azure), attempt to assign a static private IP address to them, and record this IP address. We recommend that you store the bootnode configuration under source control.","title":"Production networks"},{"location":"configure-and-manage/configure/bootnodes/#specifying-multiple-bootnodes","text":"To allow for continuity in the event of failure, specify all bootnodes in a comma-separated list using the --bootnodes option for each node, including the bootnodes. Example If your network has two bootnodes, pass the following parameter to all nodes, including the bootnodes. --bootnodes = enode://<publicKeyBootnode1>@<ipBootnode1>:30303,<publicKeyBootnode2>@<ipBootnode2>:30303 Tip Having each bootnode include the other bootnodes increases the speed of discovery. Nodes ignore their own enode in the bootnodes list so you can use the same bootnode list for all bootnodes.","title":"Specifying multiple bootnodes"},{"location":"configure-and-manage/configure/bootnodes/#adding-and-removing-bootnodes","text":"Adding new bootnodes is a similar process to creating bootnodes. After creating the bootnodes and adding them to the network, update the --bootnodes command line option for each node to include the new bootnodes. When adding bootnodes, you don\u2019t need to restart running nodes. By updating the --bootnodes option, the next time you restart the nodes, the nodes connect to the new bootnodes. To remove bootnodes, remove them from the --bootnodes option for each node.","title":"Adding and removing bootnodes"},{"location":"configure-and-manage/configure/dns/","text":"DNS for GoQuorum \u00b6 DNS support in GoQuorum can be used in the static nodes file and the node discovery protocol. You can use one and not the other, or both, as the use case requires. Static nodes \u00b6 Static nodes are nodes you keep reference to in a static-nodes.json file, even if the nodes are not alive. As the static nodes comes alive, you can connect to them. You can specify the static nodes by their IP addresses or their DNS names, which are resolved once at startup. If a static peer goes offline and its IP address changes, then it is expected that this peer re-establish the connection in a fully static network, or have discovery enabled. Discovery \u00b6 DNS is not supported for the discovery protocol. Use a bootnode instead, which can use a DNS name that is repeatedly resolved. Compatibility \u00b6 For Raft, the whole network must be on GoQuorum version 2.4.0 or later for DNS to function properly. DNS must be explicitly enabled using the --raftdnsenable option for each node once the node has migrated to version 2.4.0 or later. The network runs fine when some nodes are in version 2.4.0 or later and some in older versions as long as this feature is not enabled. For safe migration the following approach is recommended: Migrate the nodes to GoQuorum version 2.4.0 or later without using --raftdnsenable option. Once the network is fully migrated, restart the nodes with --raftdnsenable to enable the feature. In a partially migrated network (where some nodes are on version 2.4.0 or later and others on lower versions) with DNS feature enabled for migrated nodes, raft_addPeer should not be invoked with a DNS name until the entire network migrates to version 2.4.0 or later. If invoked, this call will crash all nodes running in older versions and these nodes will have to be restarted with GoQuorum version 2.4.0 or later. raft_addPeer can still be invoked with an IP address without affecting nodes running older versions of GoQuorum. Note In a network where all nodes are running on GoQuorum version 2.4.0, with few nodes enabled for DNS, we recommend --verbosity to be 3 or below. Nodes not enabled for DNS fail to restart if raft.addPeer is invoked with a DNS name and --verbosity is set above 3.","title":"DNS"},{"location":"configure-and-manage/configure/dns/#dns-for-goquorum","text":"DNS support in GoQuorum can be used in the static nodes file and the node discovery protocol. You can use one and not the other, or both, as the use case requires.","title":"DNS for GoQuorum"},{"location":"configure-and-manage/configure/dns/#static-nodes","text":"Static nodes are nodes you keep reference to in a static-nodes.json file, even if the nodes are not alive. As the static nodes comes alive, you can connect to them. You can specify the static nodes by their IP addresses or their DNS names, which are resolved once at startup. If a static peer goes offline and its IP address changes, then it is expected that this peer re-establish the connection in a fully static network, or have discovery enabled.","title":"Static nodes"},{"location":"configure-and-manage/configure/dns/#discovery","text":"DNS is not supported for the discovery protocol. Use a bootnode instead, which can use a DNS name that is repeatedly resolved.","title":"Discovery"},{"location":"configure-and-manage/configure/dns/#compatibility","text":"For Raft, the whole network must be on GoQuorum version 2.4.0 or later for DNS to function properly. DNS must be explicitly enabled using the --raftdnsenable option for each node once the node has migrated to version 2.4.0 or later. The network runs fine when some nodes are in version 2.4.0 or later and some in older versions as long as this feature is not enabled. For safe migration the following approach is recommended: Migrate the nodes to GoQuorum version 2.4.0 or later without using --raftdnsenable option. Once the network is fully migrated, restart the nodes with --raftdnsenable to enable the feature. In a partially migrated network (where some nodes are on version 2.4.0 or later and others on lower versions) with DNS feature enabled for migrated nodes, raft_addPeer should not be invoked with a DNS name until the entire network migrates to version 2.4.0 or later. If invoked, this call will crash all nodes running in older versions and these nodes will have to be restarted with GoQuorum version 2.4.0 or later. raft_addPeer can still be invoked with an IP address without affecting nodes running older versions of GoQuorum. Note In a network where all nodes are running on GoQuorum version 2.4.0, with few nodes enabled for DNS, we recommend --verbosity to be 3 or below. Nodes not enabled for DNS fail to restart if raft.addPeer is invoked with a DNS name and --verbosity is set above 3.","title":"Compatibility"},{"location":"configure-and-manage/configure/high-availability/","text":"GoQuorum high availability \u00b6 You can configure GoQuorum for end-to-end high availability (HA). This section covers the HA configuration requirements for GoQuorum and Tessera. GoQuorum HA configuration requirements \u00b6 Two or more GoQuorum nodes serve as one client via a load balancer which handles incoming requests. The GoQuorum nodes must share the same private transaction manager public key for transaction signing, and must have shared access to the key store directory or key vaults. The GoQuorum nodes must share the same private state. They can connect to a local Tessera node, or highly available Tessera nodes via a load balancer. The GoQuorum nodes must have different node keys. Tessera HA configuration requirements \u00b6 Two or more Tessera nodes serve as the privacy manager for a GoQuorum node. The Tessera nodes share the same public and private key pair in password protected files or external vaults. The Quorum-to-Tessera (Q2T) server configuration uses HTTP or HTTPS. The Tessera nodes share the same database. Important We recommend using a relational database that is configured for HA. If you are maintaining the database yourself, ensure mirroring is set up, and the supplied JDBC url includes the failover connection details. In a cloud environment this is taken care of by the providers; we recommend using AWS RDS or Azure Database.","title":"High availability"},{"location":"configure-and-manage/configure/high-availability/#goquorum-high-availability","text":"You can configure GoQuorum for end-to-end high availability (HA). This section covers the HA configuration requirements for GoQuorum and Tessera.","title":"GoQuorum high availability"},{"location":"configure-and-manage/configure/high-availability/#goquorum-ha-configuration-requirements","text":"Two or more GoQuorum nodes serve as one client via a load balancer which handles incoming requests. The GoQuorum nodes must share the same private transaction manager public key for transaction signing, and must have shared access to the key store directory or key vaults. The GoQuorum nodes must share the same private state. They can connect to a local Tessera node, or highly available Tessera nodes via a load balancer. The GoQuorum nodes must have different node keys.","title":"GoQuorum HA configuration requirements"},{"location":"configure-and-manage/configure/high-availability/#tessera-ha-configuration-requirements","text":"Two or more Tessera nodes serve as the privacy manager for a GoQuorum node. The Tessera nodes share the same public and private key pair in password protected files or external vaults. The Quorum-to-Tessera (Q2T) server configuration uses HTTP or HTTPS. The Tessera nodes share the same database. Important We recommend using a relational database that is configured for HA. If you are maintaining the database yourself, ensure mirroring is set up, and the supplied JDBC url includes the failover connection details. In a cloud environment this is taken care of by the providers; we recommend using AWS RDS or Azure Database.","title":"Tessera HA configuration requirements"},{"location":"configure-and-manage/configure/private-transaction-manager/","text":"Configure the private transaction manager \u00b6 You can configure a connection to the private transaction manager and enable private transactions using any of the following methods. Direct IPC connection configuration Using a connection configuration file Using command line options Note To run a GoQuorum node without a private transaction manager, set the PRIVATE_CONFIG environment variable to ignore . Ensure there is no transaction manager running for the node. The node won\u2019t broadcast matching private keys and won\u2019t be able to participate in any private transactions. Direct IPC connection configuration \u00b6 You can set the PRIVATE_CONFIG environment variable to the path to the .ipc socket file created by the private transaction manager. Use this method if you want to use an IPC socket for the connection with default timeout values. export PRIVATE_CONFIG = path/to/tm.ipc Using a connection configuration file \u00b6 You can set the PRIVATE_CONFIG environment variable to the path to a TOML configuration file that specifies the private transaction manager connection. Using a configuration file allows you to specify more options for the connection to the transaction manager. export PRIVATE_CONFIG = path/to/connection-config-file.toml The configuration file can specify: An IPC socket connection . An HTTP connection . An HTTP connection using TLS . IPC socket connection \u00b6 Note A configuration file is only necessary for an IPC socket connection if you need to change the timeout values from their default values. Otherwise, direct IPC connection configuration is simpler. An IPC socket configuration file has the following parameters. socket - .ipc socket file created by the private transaction manager. workdir - Path to the working directory of the IPC file. timeout - (optional) Timeout when sending messages, in seconds. Setting to 0 disables the timeout. The default is 5 seconds. You can increase this value if transaction manager responses are too slow. dialTimeout - (optional) Timeout for connecting to the socket, in seconds. The default is 1 second. ipc-config-file.toml socket = \"tm.ipc\" workdir = \"path/to/ipc/file\" timeout = 5 dialTimeout = 1 HTTP connection \u00b6 Warning This should only be used for development purposes, due to a lack of security on the connection. For production environments, you should enable TLS on the connection. An HTTP configuration file has the following parameters. httpUrl - URL of the HTTP connection. timeout - (optional) Timeout when sending messages, in seconds. Setting to 0 disables the timeout. The default is 5 seconds. writeBufferSize - (optional) Size of the write buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. readBufferSize - (optional) Size of the read buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. http-config-file.toml httpUrl = \"HTTP://127.0.0.1:9101\" timeout = 5 httpWriteBufferSize = 4096 httpReadBufferSize = 4096 HTTP connection using TLS \u00b6 An HTTP configuration file using TLS has the following parameters. httpUrl - URL of the HTTPS connection. Make sure to use an https URL. tlsMode - Set to STRICT to enable TLS encryption over the connection. tlsRootCA - Any combination of comma separated files or directories containing root CA certificates. The default is the host\u2019s certificates. tlsClientCert - Path to the file containing the client certificate. tlsClientKey - Path to the file containing the client certificate private key. timeout - (optional) Timeout when sending messages, in seconds. Setting to 0 disables the timeout. The default is 5 seconds. httpIdleConnTimeout - (optional) Idle timeout in seconds. Setting to 0 disables the timeout. The default is 10 seconds. writeBufferSize - (optional) Size of the write buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. readBufferSize - (optional) Size of the read buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. http-config-file.toml httpUrl = \"HTTPS://127.0.0.1:9101\" tlsMode = \"STRICT\" tlsRootCA = \"/path/to/ca-root.cert.pem\" tlsClientCert = \"/path/to/client-ca-chain.cert.pem\" tlsClientKey = \"/path/to/client.key.pem\" timeout = 5 httpIdleConnTimeout = 10 httpWriteBufferSize = 4096 httpReadBufferSize = 4096 Using command line options \u00b6 Use --ptm.* command line options to specify the private transaction manager connection. These can be used in conjunction with the previous methods, in which case the command line options override any others. IPC socket connection \u00b6 Specify the path to the IPC socket file using --ptm.socket . Example IPC connection geth <other parameters> --ptm.socket qdata/c1/tm.ipc HTTP connection \u00b6 Warning This should only be used for development purposes, due to a lack of security on the connection. For production environments, you should enable TLS on the connection. Specify the HTTP URL of the private transaction manager connection using --ptm.url . Example HTTP connection geth <other parameters> --ptm.url \"http://127.0.0.1:9101\" HTTP connection using TLS \u00b6 HTTP using TLS requires: Specifying an https URL using --ptm.url . Setting the TLS mode to strict using --ptm.tls.mode . Specifying relevant certificates using --ptm.tls.rootca , --ptm.tls.clientcert , and --ptm.tls.clientkey . Example TLS connection geth <other parameters> \\ --ptm.url \"https://127.0.0.1:9101\" \\ --ptm.tls.mode \"strict\" \\ --ptm.tls.rootca \"path/to/certfile.pem,dir/with/cert/files/\" \\ --ptm.tls.clientcert \"path/to/client.cert.pem\" \\ --ptm.tls.clientkey \"path/to/client.key.pem\" \\","title":"Private transaction manager"},{"location":"configure-and-manage/configure/private-transaction-manager/#configure-the-private-transaction-manager","text":"You can configure a connection to the private transaction manager and enable private transactions using any of the following methods. Direct IPC connection configuration Using a connection configuration file Using command line options Note To run a GoQuorum node without a private transaction manager, set the PRIVATE_CONFIG environment variable to ignore . Ensure there is no transaction manager running for the node. The node won\u2019t broadcast matching private keys and won\u2019t be able to participate in any private transactions.","title":"Configure the private transaction manager"},{"location":"configure-and-manage/configure/private-transaction-manager/#direct-ipc-connection-configuration","text":"You can set the PRIVATE_CONFIG environment variable to the path to the .ipc socket file created by the private transaction manager. Use this method if you want to use an IPC socket for the connection with default timeout values. export PRIVATE_CONFIG = path/to/tm.ipc","title":"Direct IPC connection configuration"},{"location":"configure-and-manage/configure/private-transaction-manager/#using-a-connection-configuration-file","text":"You can set the PRIVATE_CONFIG environment variable to the path to a TOML configuration file that specifies the private transaction manager connection. Using a configuration file allows you to specify more options for the connection to the transaction manager. export PRIVATE_CONFIG = path/to/connection-config-file.toml The configuration file can specify: An IPC socket connection . An HTTP connection . An HTTP connection using TLS .","title":"Using a connection configuration file"},{"location":"configure-and-manage/configure/private-transaction-manager/#ipc-socket-connection","text":"Note A configuration file is only necessary for an IPC socket connection if you need to change the timeout values from their default values. Otherwise, direct IPC connection configuration is simpler. An IPC socket configuration file has the following parameters. socket - .ipc socket file created by the private transaction manager. workdir - Path to the working directory of the IPC file. timeout - (optional) Timeout when sending messages, in seconds. Setting to 0 disables the timeout. The default is 5 seconds. You can increase this value if transaction manager responses are too slow. dialTimeout - (optional) Timeout for connecting to the socket, in seconds. The default is 1 second. ipc-config-file.toml socket = \"tm.ipc\" workdir = \"path/to/ipc/file\" timeout = 5 dialTimeout = 1","title":"IPC socket connection"},{"location":"configure-and-manage/configure/private-transaction-manager/#http-connection","text":"Warning This should only be used for development purposes, due to a lack of security on the connection. For production environments, you should enable TLS on the connection. An HTTP configuration file has the following parameters. httpUrl - URL of the HTTP connection. timeout - (optional) Timeout when sending messages, in seconds. Setting to 0 disables the timeout. The default is 5 seconds. writeBufferSize - (optional) Size of the write buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. readBufferSize - (optional) Size of the read buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. http-config-file.toml httpUrl = \"HTTP://127.0.0.1:9101\" timeout = 5 httpWriteBufferSize = 4096 httpReadBufferSize = 4096","title":"HTTP connection"},{"location":"configure-and-manage/configure/private-transaction-manager/#http-connection-using-tls","text":"An HTTP configuration file using TLS has the following parameters. httpUrl - URL of the HTTPS connection. Make sure to use an https URL. tlsMode - Set to STRICT to enable TLS encryption over the connection. tlsRootCA - Any combination of comma separated files or directories containing root CA certificates. The default is the host\u2019s certificates. tlsClientCert - Path to the file containing the client certificate. tlsClientKey - Path to the file containing the client certificate private key. timeout - (optional) Timeout when sending messages, in seconds. Setting to 0 disables the timeout. The default is 5 seconds. httpIdleConnTimeout - (optional) Idle timeout in seconds. Setting to 0 disables the timeout. The default is 10 seconds. writeBufferSize - (optional) Size of the write buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. readBufferSize - (optional) Size of the read buffer, in bytes. Setting to 0 or not specifying uses the http.Transport default. http-config-file.toml httpUrl = \"HTTPS://127.0.0.1:9101\" tlsMode = \"STRICT\" tlsRootCA = \"/path/to/ca-root.cert.pem\" tlsClientCert = \"/path/to/client-ca-chain.cert.pem\" tlsClientKey = \"/path/to/client.key.pem\" timeout = 5 httpIdleConnTimeout = 10 httpWriteBufferSize = 4096 httpReadBufferSize = 4096","title":"HTTP connection using TLS"},{"location":"configure-and-manage/configure/private-transaction-manager/#using-command-line-options","text":"Use --ptm.* command line options to specify the private transaction manager connection. These can be used in conjunction with the previous methods, in which case the command line options override any others.","title":"Using command line options"},{"location":"configure-and-manage/configure/private-transaction-manager/#ipc-socket-connection_1","text":"Specify the path to the IPC socket file using --ptm.socket . Example IPC connection geth <other parameters> --ptm.socket qdata/c1/tm.ipc","title":"IPC socket connection"},{"location":"configure-and-manage/configure/private-transaction-manager/#http-connection_1","text":"Warning This should only be used for development purposes, due to a lack of security on the connection. For production environments, you should enable TLS on the connection. Specify the HTTP URL of the private transaction manager connection using --ptm.url . Example HTTP connection geth <other parameters> --ptm.url \"http://127.0.0.1:9101\"","title":"HTTP connection"},{"location":"configure-and-manage/configure/private-transaction-manager/#http-connection-using-tls_1","text":"HTTP using TLS requires: Specifying an https URL using --ptm.url . Setting the TLS mode to strict using --ptm.tls.mode . Specifying relevant certificates using --ptm.tls.rootca , --ptm.tls.clientcert , and --ptm.tls.clientkey . Example TLS connection geth <other parameters> \\ --ptm.url \"https://127.0.0.1:9101\" \\ --ptm.tls.mode \"strict\" \\ --ptm.tls.rootca \"path/to/certfile.pem,dir/with/cert/files/\" \\ --ptm.tls.clientcert \"path/to/client.cert.pem\" \\ --ptm.tls.clientkey \"path/to/client.key.pem\" \\","title":"HTTP connection using TLS"},{"location":"configure-and-manage/configure/static-nodes/","text":"Configure static nodes \u00b6 Static nodes are a configured set of trusted nodes. They\u2019re exempt from maximum peer limits set through the --maxpeers option. GoQuorum attempts to maintain connections with static nodes by periodically initiating a connection to any unconnected static node. Tip Bootnodes and static nodes are parallel methods for finding peers. Depending on your use case, you can use only bootnodes, only static nodes, or both. To find peers, configure one or more bootnodes . To configure a specific set of peer connections, use static nodes, as described on this page. Configure static nodes \u00b6 To configure a network of static nodes: List the enode URLs of the nodes in the static-nodes.json file . Note When specifying enodes in static-nodes.json , you can use either DNS names or IP addresses. Only bootnodes need to be specified with IP addresses. Save the static-nodes.json file in the data directory (specified by --datadir ) of each node. Start GoQuorum with discovery disabled using --nodiscover . To update the list of static peers at runtime, use the admin_addPeer and admin_removePeer JSON-RPC API methods. Note Runtime modifications of static nodes do not persist between runs. The static-nodes.json file is not updated by the admin_addPeer and admin_removePeer methods. Nodes not in the list of the static nodes are not prevented from connecting. To prevent nodes from connecting, use permissioning . Tip If the added peer does not appear in the peer list (returned by admin_peers ), check that the supplied enode URL is correct, the node is running, and the node is listening for TCP connections on the endpoint. static-nodes.json file \u00b6 The static-nodes.json file must be in the data directory (specified by --datadir ) and contain a JSON array of enode URLs . Example [ \"enode://cea71cb65a471037e01508cebcc178f176f9d5267bf29507ea1f6431eb6a5dc67d086dc8dc54358a72299dab1161febc5d7af49d1609c69b42b5e54544145d4f@127.0.0.1:30303\" , \"enode://ca05e940488614402705a6b6836288ea902169ecc67a89e1bd5ef94bc0d1933f20be16bc881ffb4be59f521afa8718fc26eec2b0e90f2cd0f44f99bc8103e60f@127.0.0.1:30304\" ] Note Each node has a static-nodes.json file. We recommend each node in the network has the same static-nodes.json file.","title":"Static nodes"},{"location":"configure-and-manage/configure/static-nodes/#configure-static-nodes","text":"Static nodes are a configured set of trusted nodes. They\u2019re exempt from maximum peer limits set through the --maxpeers option. GoQuorum attempts to maintain connections with static nodes by periodically initiating a connection to any unconnected static node. Tip Bootnodes and static nodes are parallel methods for finding peers. Depending on your use case, you can use only bootnodes, only static nodes, or both. To find peers, configure one or more bootnodes . To configure a specific set of peer connections, use static nodes, as described on this page.","title":"Configure static nodes"},{"location":"configure-and-manage/configure/static-nodes/#configure-static-nodes_1","text":"To configure a network of static nodes: List the enode URLs of the nodes in the static-nodes.json file . Note When specifying enodes in static-nodes.json , you can use either DNS names or IP addresses. Only bootnodes need to be specified with IP addresses. Save the static-nodes.json file in the data directory (specified by --datadir ) of each node. Start GoQuorum with discovery disabled using --nodiscover . To update the list of static peers at runtime, use the admin_addPeer and admin_removePeer JSON-RPC API methods. Note Runtime modifications of static nodes do not persist between runs. The static-nodes.json file is not updated by the admin_addPeer and admin_removePeer methods. Nodes not in the list of the static nodes are not prevented from connecting. To prevent nodes from connecting, use permissioning . Tip If the added peer does not appear in the peer list (returned by admin_peers ), check that the supplied enode URL is correct, the node is running, and the node is listening for TCP connections on the endpoint.","title":"Configure static nodes"},{"location":"configure-and-manage/configure/static-nodes/#static-nodesjson-file","text":"The static-nodes.json file must be in the data directory (specified by --datadir ) and contain a JSON array of enode URLs . Example [ \"enode://cea71cb65a471037e01508cebcc178f176f9d5267bf29507ea1f6431eb6a5dc67d086dc8dc54358a72299dab1161febc5d7af49d1609c69b42b5e54544145d4f@127.0.0.1:30303\" , \"enode://ca05e940488614402705a6b6836288ea902169ecc67a89e1bd5ef94bc0d1933f20be16bc881ffb4be59f521afa8718fc26eec2b0e90f2cd0f44f99bc8103e60f@127.0.0.1:30304\" ] Note Each node has a static-nodes.json file. We recommend each node in the network has the same static-nodes.json file.","title":"static-nodes.json file"},{"location":"configure-and-manage/configure/use-configuration-file/","text":"Using the GoQuorum configuration file \u00b6 You can specify command line options in a TOML configuration file. To do this, specify your options on the command line, and use the dumpconfig command to print the options into a new TOML configuration file. Syntax geth [ OPTIONS ] dumpconfig > <TOML-CONFIG-FILE> Example geth --wsapi \"istanbul\" --rpcapi \"istanbul\" --istanbul.requesttimeout 5000 --allowedfutureblocktime 5 dumpconfig > config.toml The configuration file contains your specified options and other default options. Example configuration file [Eth] NetworkId = 1337 SyncMode = \"fast\" NoPruning = false NoPrefetch = false LightPeers = 100 UltraLightFraction = 75 DatabaseCache = 768 DatabaseFreezer = \"\" TrieCleanCache = 256 TrieDirtyCache = 256 TrieTimeout = 3600000000000 EnablePreimageRecording = false EWASMInterpreter = \"\" EVMInterpreter = \"\" [Eth.Miner] GasFloor = 700000000 GasCeil = 800000000 GasPrice = 1000000000 Recommit = 3000000000 Noverify = false AllowedFutureBlockTime = 5 [Eth.Ethash] CacheDir = \"ethash\" CachesInMem = 2 CachesOnDisk = 3 DatasetDir = \"/Users/alexandratran/Library/Ethash\" DatasetsInMem = 1 DatasetsOnDisk = 2 PowMode = 0 [Eth.TxPool] Locals = [] NoLocals = false Journal = \"transactions.rlp\" Rejournal = 3600000000000 PriceLimit = 1 PriceBump = 10 AccountSlots = 16 GlobalSlots = 4096 AccountQueue = 64 GlobalQueue = 1024 Lifetime = 10800000000000 TransactionSizeLimit = 64 MaxCodeSize = 24 [Eth.GPO] Blocks = 20 Percentile = 60 [Eth.Istanbul] RequestTimeout = 5000 BlockPeriod = 1 Epoch = 30000 Ceil2Nby3Block = 0 [Shh] MaxMessageSize = 1048576 MinimumAcceptedPOW = 2e-01 RestrictConnectionBetweenLightClients = true [Node] DataDir = \"/Users/alexandratran/Library/Ethereum\" omitempty = \"\" IPCPath = \"geth.ipc\" HTTPPort = 8545 HTTPVirtualHosts = [ \"localhost\" ] HTTPModules = [ \"istanbul\" ] WSPort = 8546 WSModules = [ \"istanbul\" ] GraphQLPort = 8547 GraphQLVirtualHosts = [ \"localhost\" ] [Node.P2P] MaxPeers = 50 NoDiscovery = false BootstrapNodes = [ \"enode://d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666@18.138.108.67:30303\" , \"enode://22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de@3.209.45.79:30303\" , \"enode://ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758@34.255.23.113:30303\" , \"enode://279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8@35.158.244.151:30303\" , \"enode://8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a@52.187.207.27:30303\" , \"enode://103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1@191.234.162.198:30303\" , \"enode://715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8@52.231.165.108:30303\" , \"enode://5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f@104.42.217.25:30303\" , \"enode://979b7fa28feeb35a4741660a16076f1943202cb72b6af70d327f053e248bab9ba81760f39d0701ef1d8f89cc1fbd2cacba0710a12cd5314d5e0c9021aa3637f9@5.1.83.226:30303\" ] BootstrapNodesV5 = [ \"enode://06051a5573c81934c9554ef2898eb13b33a34b94cf36b202b69fde139ca17a85051979867720d4bdae4323d4943ddf9aeeb6643633aa656e0be843659795007a@35.177.226.168:30303\" , \"enode://0cc5f5ffb5d9098c8b8c62325f3797f56509bff942704687b6530992ac706e2cb946b90a34f1f19548cd3c7baccbcaea354531e5983c7d1bc0dee16ce4b6440b@40.118.3.223:30304\" , \"enode://1c7a64d76c0334b0418c004af2f67c50e36a3be60b5e4790bdac0439d21603469a85fad36f2473c9a80eb043ae60936df905fa28f1ff614c3e5dc34f15dcd2dc@40.118.3.223:30306\" , \"enode://85c85d7143ae8bb96924f2b54f1b3e70d8c4d367af305325d30a61385a432f247d2c75c45c6b4a60335060d072d7f5b35dd1d4c45f76941f62a4f83b6e75daaf@40.118.3.223:30307\" ] StaticNodes = [] TrustedNodes = [] ListenAddr = \":30303\" EnableMsgEvents = false [Node.HTTPTimeouts] ReadTimeout = 30000000000 WriteTimeout = 30000000000 IdleTimeout = 120000000000 [Dashboard] Host = \"localhost\" Port = 8080 Refresh = 5000000000 You can reuse the configuration file across node startups. To specify the configuration file, use the --config option. Syntax geth --config = <TOML-CONFIG-FILE> Example geth --config = config.toml To override an option specified in the configuration file, specify the same option on the command line.","title":"Use a configuration file"},{"location":"configure-and-manage/configure/use-configuration-file/#using-the-goquorum-configuration-file","text":"You can specify command line options in a TOML configuration file. To do this, specify your options on the command line, and use the dumpconfig command to print the options into a new TOML configuration file. Syntax geth [ OPTIONS ] dumpconfig > <TOML-CONFIG-FILE> Example geth --wsapi \"istanbul\" --rpcapi \"istanbul\" --istanbul.requesttimeout 5000 --allowedfutureblocktime 5 dumpconfig > config.toml The configuration file contains your specified options and other default options. Example configuration file [Eth] NetworkId = 1337 SyncMode = \"fast\" NoPruning = false NoPrefetch = false LightPeers = 100 UltraLightFraction = 75 DatabaseCache = 768 DatabaseFreezer = \"\" TrieCleanCache = 256 TrieDirtyCache = 256 TrieTimeout = 3600000000000 EnablePreimageRecording = false EWASMInterpreter = \"\" EVMInterpreter = \"\" [Eth.Miner] GasFloor = 700000000 GasCeil = 800000000 GasPrice = 1000000000 Recommit = 3000000000 Noverify = false AllowedFutureBlockTime = 5 [Eth.Ethash] CacheDir = \"ethash\" CachesInMem = 2 CachesOnDisk = 3 DatasetDir = \"/Users/alexandratran/Library/Ethash\" DatasetsInMem = 1 DatasetsOnDisk = 2 PowMode = 0 [Eth.TxPool] Locals = [] NoLocals = false Journal = \"transactions.rlp\" Rejournal = 3600000000000 PriceLimit = 1 PriceBump = 10 AccountSlots = 16 GlobalSlots = 4096 AccountQueue = 64 GlobalQueue = 1024 Lifetime = 10800000000000 TransactionSizeLimit = 64 MaxCodeSize = 24 [Eth.GPO] Blocks = 20 Percentile = 60 [Eth.Istanbul] RequestTimeout = 5000 BlockPeriod = 1 Epoch = 30000 Ceil2Nby3Block = 0 [Shh] MaxMessageSize = 1048576 MinimumAcceptedPOW = 2e-01 RestrictConnectionBetweenLightClients = true [Node] DataDir = \"/Users/alexandratran/Library/Ethereum\" omitempty = \"\" IPCPath = \"geth.ipc\" HTTPPort = 8545 HTTPVirtualHosts = [ \"localhost\" ] HTTPModules = [ \"istanbul\" ] WSPort = 8546 WSModules = [ \"istanbul\" ] GraphQLPort = 8547 GraphQLVirtualHosts = [ \"localhost\" ] [Node.P2P] MaxPeers = 50 NoDiscovery = false BootstrapNodes = [ \"enode://d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666@18.138.108.67:30303\" , \"enode://22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de@3.209.45.79:30303\" , \"enode://ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758@34.255.23.113:30303\" , \"enode://279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8@35.158.244.151:30303\" , \"enode://8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a@52.187.207.27:30303\" , \"enode://103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1@191.234.162.198:30303\" , \"enode://715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8@52.231.165.108:30303\" , \"enode://5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f@104.42.217.25:30303\" , \"enode://979b7fa28feeb35a4741660a16076f1943202cb72b6af70d327f053e248bab9ba81760f39d0701ef1d8f89cc1fbd2cacba0710a12cd5314d5e0c9021aa3637f9@5.1.83.226:30303\" ] BootstrapNodesV5 = [ \"enode://06051a5573c81934c9554ef2898eb13b33a34b94cf36b202b69fde139ca17a85051979867720d4bdae4323d4943ddf9aeeb6643633aa656e0be843659795007a@35.177.226.168:30303\" , \"enode://0cc5f5ffb5d9098c8b8c62325f3797f56509bff942704687b6530992ac706e2cb946b90a34f1f19548cd3c7baccbcaea354531e5983c7d1bc0dee16ce4b6440b@40.118.3.223:30304\" , \"enode://1c7a64d76c0334b0418c004af2f67c50e36a3be60b5e4790bdac0439d21603469a85fad36f2473c9a80eb043ae60936df905fa28f1ff614c3e5dc34f15dcd2dc@40.118.3.223:30306\" , \"enode://85c85d7143ae8bb96924f2b54f1b3e70d8c4d367af305325d30a61385a432f247d2c75c45c6b4a60335060d072d7f5b35dd1d4c45f76941f62a4f83b6e75daaf@40.118.3.223:30307\" ] StaticNodes = [] TrustedNodes = [] ListenAddr = \":30303\" EnableMsgEvents = false [Node.HTTPTimeouts] ReadTimeout = 30000000000 WriteTimeout = 30000000000 IdleTimeout = 120000000000 [Dashboard] Host = \"localhost\" Port = 8080 Refresh = 5000000000 You can reuse the configuration file across node startups. To specify the configuration file, use the --config option. Syntax geth --config = <TOML-CONFIG-FILE> Example geth --config = config.toml To override an option specified in the configuration file, specify the same option on the command line.","title":"Using the GoQuorum configuration file"},{"location":"configure-and-manage/configure/consensus-protocols/clique/","text":"Clique consensus \u00b6 Clique is a proof of authority consensus protocol implemented in Go Ethereum (Geth) and included in GoQuorum. Warning Clique is not suitable for production environments. Use only in development environments. You can migrate a Clique network to another consensus protocol . Refer to the following Clique documentation: Clique specification Guide to set up Clique with puppeth Clique API Migrate from Clique to another consensus protocol \u00b6 To migrate a network using Clique to a consensus protocol suitable for production such as QBFT , do one of the following: Stop the Clique network and start the new network with the state at the time of migration. Historical transactions and state history are lost. Replay the historical transactions on the new network. The historical transactions are at different block heights on the new network, but the transactions and state history are the same on the new network as on the Clique network. If you want enterprise support to migrate a Clique network, contact support .","title":"Clique"},{"location":"configure-and-manage/configure/consensus-protocols/clique/#clique-consensus","text":"Clique is a proof of authority consensus protocol implemented in Go Ethereum (Geth) and included in GoQuorum. Warning Clique is not suitable for production environments. Use only in development environments. You can migrate a Clique network to another consensus protocol . Refer to the following Clique documentation: Clique specification Guide to set up Clique with puppeth Clique API","title":"Clique consensus"},{"location":"configure-and-manage/configure/consensus-protocols/clique/#migrate-from-clique-to-another-consensus-protocol","text":"To migrate a network using Clique to a consensus protocol suitable for production such as QBFT , do one of the following: Stop the Clique network and start the new network with the state at the time of migration. Historical transactions and state history are lost. Replay the historical transactions on the new network. The historical transactions are at different block heights on the new network, but the transactions and state history are the same on the new network as on the Clique network. If you want enterprise support to migrate a Clique network, contact support .","title":"Migrate from Clique to another consensus protocol"},{"location":"configure-and-manage/configure/consensus-protocols/ibft/","text":"Configure IBFT consensus \u00b6 GoQuorum implements the IBFT proof of authority consensus protocol . IBFT is supported for existing private networks, but QBFT is the recommended enterprise-grade consensus protocol for private networks. You can migrate an IBFT network to QBFT . You can create a private network using IBFT . In IBFT networks, approved accounts known as validators validate transactions and blocks. Validators take turns to create the next block. Before inserting a block onto the chain, a super-majority (greater than 66%) of validators must first sign the block. Existing validators propose and vote to add or remove validators . Adding or removing a validator requires a majority vote (greater than 50%) of validators. Important Configure your network to ensure you never lose \u2153 or more of your validators. If more than \u2153 of validators stop participating, new blocks are no longer created, and the network stalls. It may take significant time to recover once nodes are restarted. Blocks in IBFT protocol are final, meaning there are no forks, and valid blocks must be in the main chain. To prevent a faulty node from generating a different chain from the main chain, each validator appends ceil(2N/3) of received COMMIT signatures to the extraData field in a block\u2019s header before inserting it into the chain. Therefore, all blocks are self-verifiable. Minimum number of validators \u00b6 IBFT requires four validators to be Byzantine fault tolerant. Byzantine fault tolerance is the ability for a blockchain network to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers. Genesis file \u00b6 To use IBFT, GoQuorum requires a genesis file . The genesis file defines properties specific to IBFT and to your specific network. Example IBFT genesis file { \"config\" : { \"chainId\" : 1337 , \"homesteadBlock\" : 0 , \"eip150Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 0 , \"eip158Block\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"ceil2Nby3Block\" : 0 }, \"txnSizeLimit\" : 64 , \"maxCodeSize\" : 0 , \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5f1663fc\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000f89af8549493917cadbace5dfce132b991732c6cda9bcc5b8a9427a97c9aaf04f18f3014c32e036dd0ac76da5f1894ce412f988377e31f4d0ff12d74df73b51c42d0ca9498c1334496614aed49d2e81526d089f7264fed9cb8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\" , \"gasLimit\" : \"0xf7b760\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : {}, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } The properties specific to IBFT are in the istanbul section: epoch - Number of blocks that should pass before pending validator votes are reset. policy - Proposer selection policy, which is 0 (Round Robin) or 1 (Sticky). \u2018Round Robin\u2019 is where validators take turns in proposing blocks, and \u2018Sticky\u2019 is where a single validator proposes blocks until they go offline or are unreachable. ceil2Nby3Block - Sets the block number from which to use an updated formula for calculating the number of faulty nodes. For new networks, we recommended setting this to 0 to use the updated formula immediately. extraData - RLP encoded string with a list of validators. RLP encoding is a space-efficient object serialization scheme used in Ethereum. Block time \u00b6 The block time is the minimum time between two consecutive IBFT blocks\u2019 timestamps in seconds. Setting the block time determines how quickly blocks should be minted by the validators. The default is 1 second. You can set the block time on each GoQuorum node with the istanbul.blockperiod option: --istanbul.blockperiod <INTEGER> You can also set a requesttimeout by using the istanbul.requesttimeout option: --istanbul.requesttimeout <INTEGER> Important If more than \u2153 of validators stop participating, new blocks can no longer be created and requesttimeoutseconds doubles with each round change. The quickest method to resume block production is to restart all validators, which resets requesttimeoutseconds to its genesis value.","title":"IBFT"},{"location":"configure-and-manage/configure/consensus-protocols/ibft/#configure-ibft-consensus","text":"GoQuorum implements the IBFT proof of authority consensus protocol . IBFT is supported for existing private networks, but QBFT is the recommended enterprise-grade consensus protocol for private networks. You can migrate an IBFT network to QBFT . You can create a private network using IBFT . In IBFT networks, approved accounts known as validators validate transactions and blocks. Validators take turns to create the next block. Before inserting a block onto the chain, a super-majority (greater than 66%) of validators must first sign the block. Existing validators propose and vote to add or remove validators . Adding or removing a validator requires a majority vote (greater than 50%) of validators. Important Configure your network to ensure you never lose \u2153 or more of your validators. If more than \u2153 of validators stop participating, new blocks are no longer created, and the network stalls. It may take significant time to recover once nodes are restarted. Blocks in IBFT protocol are final, meaning there are no forks, and valid blocks must be in the main chain. To prevent a faulty node from generating a different chain from the main chain, each validator appends ceil(2N/3) of received COMMIT signatures to the extraData field in a block\u2019s header before inserting it into the chain. Therefore, all blocks are self-verifiable.","title":"Configure IBFT consensus"},{"location":"configure-and-manage/configure/consensus-protocols/ibft/#minimum-number-of-validators","text":"IBFT requires four validators to be Byzantine fault tolerant. Byzantine fault tolerance is the ability for a blockchain network to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers.","title":"Minimum number of validators"},{"location":"configure-and-manage/configure/consensus-protocols/ibft/#genesis-file","text":"To use IBFT, GoQuorum requires a genesis file . The genesis file defines properties specific to IBFT and to your specific network. Example IBFT genesis file { \"config\" : { \"chainId\" : 1337 , \"homesteadBlock\" : 0 , \"eip150Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 0 , \"eip158Block\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"ceil2Nby3Block\" : 0 }, \"txnSizeLimit\" : 64 , \"maxCodeSize\" : 0 , \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5f1663fc\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000f89af8549493917cadbace5dfce132b991732c6cda9bcc5b8a9427a97c9aaf04f18f3014c32e036dd0ac76da5f1894ce412f988377e31f4d0ff12d74df73b51c42d0ca9498c1334496614aed49d2e81526d089f7264fed9cb8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\" , \"gasLimit\" : \"0xf7b760\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : {}, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } The properties specific to IBFT are in the istanbul section: epoch - Number of blocks that should pass before pending validator votes are reset. policy - Proposer selection policy, which is 0 (Round Robin) or 1 (Sticky). \u2018Round Robin\u2019 is where validators take turns in proposing blocks, and \u2018Sticky\u2019 is where a single validator proposes blocks until they go offline or are unreachable. ceil2Nby3Block - Sets the block number from which to use an updated formula for calculating the number of faulty nodes. For new networks, we recommended setting this to 0 to use the updated formula immediately. extraData - RLP encoded string with a list of validators. RLP encoding is a space-efficient object serialization scheme used in Ethereum.","title":"Genesis file"},{"location":"configure-and-manage/configure/consensus-protocols/ibft/#block-time","text":"The block time is the minimum time between two consecutive IBFT blocks\u2019 timestamps in seconds. Setting the block time determines how quickly blocks should be minted by the validators. The default is 1 second. You can set the block time on each GoQuorum node with the istanbul.blockperiod option: --istanbul.blockperiod <INTEGER> You can also set a requesttimeout by using the istanbul.requesttimeout option: --istanbul.requesttimeout <INTEGER> Important If more than \u2153 of validators stop participating, new blocks can no longer be created and requesttimeoutseconds doubles with each round change. The quickest method to resume block production is to restart all validators, which resets requesttimeoutseconds to its genesis value.","title":"Block time"},{"location":"configure-and-manage/configure/consensus-protocols/qbft/","text":"Configure QBFT consensus \u00b6 GoQuorum implements the QBFT proof of authority consensus protocol . QBFT is the recommended enterprise-grade consensus protocol for private networks. You can create a private network using QBFT . In QBFT networks, approved accounts known as validators validate transactions and blocks. Validators take turns to create the next block. Before inserting a block onto the chain, a super-majority (greater than 66%) of validators must first sign the block. Existing validators propose and vote to add or remove validators. Adding or removing a validator requires a majority vote (greater than 50%) of validators. Important Configure your network to ensure you never lose \u2153 or more of your validators. If more than \u2153 of validators stop participating, new blocks are no longer created, and the network stalls. It may take significant time to recover once nodes are restarted. Blocks in QBFT are final, meaning there are no forks, and valid blocks must be in the main chain. To prevent a faulty node from generating a different chain from the main chain, each validator appends ceil(2N/3) of received COMMIT signatures to the extraData field in a block\u2019s header before inserting it into the chain. Therefore, all blocks are self-verifiable. Minimum number of validators \u00b6 QBFT requires four validators to be Byzantine fault tolerant. Byzantine fault tolerance is the ability for a blockchain network to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers. Genesis file \u00b6 To use QBFT, GoQuorum requires a genesis file . The genesis file defines properties specific to QBFT and to your specific network. Example QBFT genesis file { \"config\" : { \"chainId\" : 1337 , \"homesteadBlock\" : 0 , \"eip150Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 0 , \"eip158Block\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"ceil2Nby3Block\" : 0 , \"testQBFTBlock\" : 0 }, \"txnSizeLimit\" : 64 , \"maxCodeSize\" : 0 , \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5f1663fc\" , \"extraData\" : \"0xf87aa00000000000000000000000000000000000000000000000000000000000000000f8549493917cadbace5dfce132b991732c6cda9bcc5b8a9427a97c9aaf04f18f3014c32e036dd0ac76da5f1894ce412f988377e31f4d0ff12d74df73b51c42d0ca9498c1334496614aed49d2e81526d089f7264fed9cc080c0\" , \"gasLimit\" : \"0xf7b760\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : {}, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } The properties specific to QBFT are in the istanbul section: epoch - Number of blocks that should pass before pending validator votes are reset. policy - Proposer selection policy, which is 0 (Round Robin) or 1 (Sticky). \u2018Round Robin\u2019 is where validators take turns in proposing blocks, and \u2018Sticky\u2019 is where a single validator proposes blocks until they go offline or are unreachable. ceil2Nby3Block - Sets the block number from which to use an updated formula for calculating the number of faulty nodes. For new networks, we recommended setting this to 0 to use the updated formula immediately. extraData - RLP encoded string with a list of validators. RLP encoding is a space-efficient object serialization scheme used in Ethereum. testQBFTBlock - QBFT fork block. QBFT is used once the network reaches this block number. Block time \u00b6 The block time is the minimum time between two consecutive QBFT blocks\u2019 timestamps in seconds. Setting the block time determines how quickly blocks should be minted by the validators. The default is 1 second. You can set the block time on each GoQuorum node with the istanbul.blockperiod option: --istanbul.blockperiod <INTEGER> You can also set a requesttimeout by using the istanbul.requesttimeout option: --istanbul.requesttimeout <INTEGER> Important If more than \u2153 of validators stop participating, new blocks can no longer be created and requesttimeoutseconds doubles with each round change. The quickest method to resume block production is to restart all validators, which resets requesttimeoutseconds to its genesis value. Migrate from IBFT to QBFT \u00b6 You can migrate an existing IBFT network to a QBFT network with the following steps: Stop the network. Update the IBFT genesis file with a non-zero testQBFTBlock fork block. For example, if the current block number in your IBFT network is 100, set testQBFTBlock to any block greater than 100, and once that fork block is reached, QBFT consensus will be used instead of IBFT. Sample QBFT genesis file ... \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"ceil2Nby3Block\" : 0 , \"testQBFTBlock\" : 120 }, ... Restart the network with the updated genesis file.","title":"QBFT"},{"location":"configure-and-manage/configure/consensus-protocols/qbft/#configure-qbft-consensus","text":"GoQuorum implements the QBFT proof of authority consensus protocol . QBFT is the recommended enterprise-grade consensus protocol for private networks. You can create a private network using QBFT . In QBFT networks, approved accounts known as validators validate transactions and blocks. Validators take turns to create the next block. Before inserting a block onto the chain, a super-majority (greater than 66%) of validators must first sign the block. Existing validators propose and vote to add or remove validators. Adding or removing a validator requires a majority vote (greater than 50%) of validators. Important Configure your network to ensure you never lose \u2153 or more of your validators. If more than \u2153 of validators stop participating, new blocks are no longer created, and the network stalls. It may take significant time to recover once nodes are restarted. Blocks in QBFT are final, meaning there are no forks, and valid blocks must be in the main chain. To prevent a faulty node from generating a different chain from the main chain, each validator appends ceil(2N/3) of received COMMIT signatures to the extraData field in a block\u2019s header before inserting it into the chain. Therefore, all blocks are self-verifiable.","title":"Configure QBFT consensus"},{"location":"configure-and-manage/configure/consensus-protocols/qbft/#minimum-number-of-validators","text":"QBFT requires four validators to be Byzantine fault tolerant. Byzantine fault tolerance is the ability for a blockchain network to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers.","title":"Minimum number of validators"},{"location":"configure-and-manage/configure/consensus-protocols/qbft/#genesis-file","text":"To use QBFT, GoQuorum requires a genesis file . The genesis file defines properties specific to QBFT and to your specific network. Example QBFT genesis file { \"config\" : { \"chainId\" : 1337 , \"homesteadBlock\" : 0 , \"eip150Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 0 , \"eip158Block\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"ceil2Nby3Block\" : 0 , \"testQBFTBlock\" : 0 }, \"txnSizeLimit\" : 64 , \"maxCodeSize\" : 0 , \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5f1663fc\" , \"extraData\" : \"0xf87aa00000000000000000000000000000000000000000000000000000000000000000f8549493917cadbace5dfce132b991732c6cda9bcc5b8a9427a97c9aaf04f18f3014c32e036dd0ac76da5f1894ce412f988377e31f4d0ff12d74df73b51c42d0ca9498c1334496614aed49d2e81526d089f7264fed9cc080c0\" , \"gasLimit\" : \"0xf7b760\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : {}, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } The properties specific to QBFT are in the istanbul section: epoch - Number of blocks that should pass before pending validator votes are reset. policy - Proposer selection policy, which is 0 (Round Robin) or 1 (Sticky). \u2018Round Robin\u2019 is where validators take turns in proposing blocks, and \u2018Sticky\u2019 is where a single validator proposes blocks until they go offline or are unreachable. ceil2Nby3Block - Sets the block number from which to use an updated formula for calculating the number of faulty nodes. For new networks, we recommended setting this to 0 to use the updated formula immediately. extraData - RLP encoded string with a list of validators. RLP encoding is a space-efficient object serialization scheme used in Ethereum. testQBFTBlock - QBFT fork block. QBFT is used once the network reaches this block number.","title":"Genesis file"},{"location":"configure-and-manage/configure/consensus-protocols/qbft/#block-time","text":"The block time is the minimum time between two consecutive QBFT blocks\u2019 timestamps in seconds. Setting the block time determines how quickly blocks should be minted by the validators. The default is 1 second. You can set the block time on each GoQuorum node with the istanbul.blockperiod option: --istanbul.blockperiod <INTEGER> You can also set a requesttimeout by using the istanbul.requesttimeout option: --istanbul.requesttimeout <INTEGER> Important If more than \u2153 of validators stop participating, new blocks can no longer be created and requesttimeoutseconds doubles with each round change. The quickest method to resume block production is to restart all validators, which resets requesttimeoutseconds to its genesis value.","title":"Block time"},{"location":"configure-and-manage/configure/consensus-protocols/qbft/#migrate-from-ibft-to-qbft","text":"You can migrate an existing IBFT network to a QBFT network with the following steps: Stop the network. Update the IBFT genesis file with a non-zero testQBFTBlock fork block. For example, if the current block number in your IBFT network is 100, set testQBFTBlock to any block greater than 100, and once that fork block is reached, QBFT consensus will be used instead of IBFT. Sample QBFT genesis file ... \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"ceil2Nby3Block\" : 0 , \"testQBFTBlock\" : 120 }, ... Restart the network with the updated genesis file.","title":"Migrate from IBFT to QBFT"},{"location":"configure-and-manage/configure/consensus-protocols/raft/","text":"Configure Raft consensus \u00b6 GoQuorum implements the Raft proof of authority consensus protocol . To enable Raft consensus, specify the --raft command line option when starting GoQuorum. You can create a private network using Raft . Warning Raft is not suitable for production environments. Use only in development environments. You can migrate a Raft network to another consensus protocol . Raft requires that all initial nodes in the cluster are configured as static peers . The order of the enode IDs in the static-nodes.json file must be the same across all peers. The enode IDs must include a raftport querystring parameter specifying the Raft port for each peer. Example enode://abcd@127.0.0.1:30400?raftport = 50400 For the Raft network to work, 51% of the peers must be up and running. We recommend having an odd number of at least 3 peers in the network. Minting frequency \u00b6 By default, blocks are minted no more frequently than every 50ms. When transactions arrive: If it has been at least 50ms since the last block, a new block is minted immediately. If it has been less that 50ms, a new block is minted 50ms after the previous block was minted. Waiting prevents Raft being flooded with blocks. The rate limiting achieves a balance between transaction throughput and latency. Configure the minting frequency using the --raftblocktime command line option when starting GoQuorum. Raft transport layer \u00b6 Blocks are communicated over the HTTP transport layer built into etcd Raft . By default, GoQuorum listens on port 50400 for the Raft transport. Use the --raftport command line option to change the port. By default, the number of peers is 25. Use the --maxpeers N command line option to configure the maximum number of peers where N is expected size of the cluster. Migrate from Raft to another consensus protocol \u00b6 To migrate a network using Raft to a consensus protocol suitable for production such as QBFT , do one of the following: Stop the Raft network and start the new network with the state at the time of migration. Historical transactions and state history are lost. Replay the historical transactions on the new network. The historical transactions are at different block heights on the new network, but the transactions and state history are the same on the new network as on the Raft network. If you want enterprise support to migrate a Raft network, contact support .","title":"Raft"},{"location":"configure-and-manage/configure/consensus-protocols/raft/#configure-raft-consensus","text":"GoQuorum implements the Raft proof of authority consensus protocol . To enable Raft consensus, specify the --raft command line option when starting GoQuorum. You can create a private network using Raft . Warning Raft is not suitable for production environments. Use only in development environments. You can migrate a Raft network to another consensus protocol . Raft requires that all initial nodes in the cluster are configured as static peers . The order of the enode IDs in the static-nodes.json file must be the same across all peers. The enode IDs must include a raftport querystring parameter specifying the Raft port for each peer. Example enode://abcd@127.0.0.1:30400?raftport = 50400 For the Raft network to work, 51% of the peers must be up and running. We recommend having an odd number of at least 3 peers in the network.","title":"Configure Raft consensus"},{"location":"configure-and-manage/configure/consensus-protocols/raft/#minting-frequency","text":"By default, blocks are minted no more frequently than every 50ms. When transactions arrive: If it has been at least 50ms since the last block, a new block is minted immediately. If it has been less that 50ms, a new block is minted 50ms after the previous block was minted. Waiting prevents Raft being flooded with blocks. The rate limiting achieves a balance between transaction throughput and latency. Configure the minting frequency using the --raftblocktime command line option when starting GoQuorum.","title":"Minting frequency"},{"location":"configure-and-manage/configure/consensus-protocols/raft/#raft-transport-layer","text":"Blocks are communicated over the HTTP transport layer built into etcd Raft . By default, GoQuorum listens on port 50400 for the Raft transport. Use the --raftport command line option to change the port. By default, the number of peers is 25. Use the --maxpeers N command line option to configure the maximum number of peers where N is expected size of the cluster.","title":"Raft transport layer"},{"location":"configure-and-manage/configure/consensus-protocols/raft/#migrate-from-raft-to-another-consensus-protocol","text":"To migrate a network using Raft to a consensus protocol suitable for production such as QBFT , do one of the following: Stop the Raft network and start the new network with the state at the time of migration. Historical transactions and state history are lost. Replay the historical transactions on the new network. The historical transactions are at different block heights on the new network, but the transactions and state history are the same on the new network as on the Raft network. If you want enterprise support to migrate a Raft network, contact support .","title":"Migrate from Raft to another consensus protocol"},{"location":"configure-and-manage/configure/genesis-file/contracts-in-genesis/","text":"Pre-deploying contracts in the genesis file \u00b6 To pre-deploy contracts when starting GoQuorum, specify the contract code in the genesis file . Contract code in the genesis file { ... \"alloc\" : { \"0x0ffd23af8eebc60b3cfdeed6f814988757237314\" : { \"balance\" : \"0x100000000000000000000000000000000000000000000000000\" , \"code\" : \"0x6080604052600436106043576000357c010000000000000000000000000000000000000000000000000000000090048063010fc84214604857806355241077146070575b600080fd5b348015605357600080fd5b50605a60a7565b6040518082815260200191505060405180910390f35b348015607b57600080fd5b5060a560048036036020811015609057600080fd5b810190808035906020019092919050505060ad565b005b60005481565b80600081905550807f04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce360405160405180910390a25056fea165627a7a7230582038cb7ea327af8f73feabcfbff64498f1e74831e67f7c75286760d3845c6747c70029\" , \"storage\" : { \"7aa07e0c924147697605046b7c2c32645b7bbfb41e0ac5d0a84ac93cbb759798\" : \"0000000000000000000000000000000000000000000000000000000000000001\" , \"cea2b0602db61f92b76ec4402875cc38eedc9fc425cb1b697fc2265d50fc20fb\" : \"0000000000000000000000000000000000000000000000000000000000000001\" , } } }, ... } The contract code in the genesis file defines the: Address. Balance. Bytecode. Key value pairs for contract storage.","title":"Predeploy a contract in the genesis file"},{"location":"configure-and-manage/configure/genesis-file/contracts-in-genesis/#pre-deploying-contracts-in-the-genesis-file","text":"To pre-deploy contracts when starting GoQuorum, specify the contract code in the genesis file . Contract code in the genesis file { ... \"alloc\" : { \"0x0ffd23af8eebc60b3cfdeed6f814988757237314\" : { \"balance\" : \"0x100000000000000000000000000000000000000000000000000\" , \"code\" : \"0x6080604052600436106043576000357c010000000000000000000000000000000000000000000000000000000090048063010fc84214604857806355241077146070575b600080fd5b348015605357600080fd5b50605a60a7565b6040518082815260200191505060405180910390f35b348015607b57600080fd5b5060a560048036036020811015609057600080fd5b810190808035906020019092919050505060ad565b005b60005481565b80600081905550807f04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce360405160405180910390a25056fea165627a7a7230582038cb7ea327af8f73feabcfbff64498f1e74831e67f7c75286760d3845c6747c70029\" , \"storage\" : { \"7aa07e0c924147697605046b7c2c32645b7bbfb41e0ac5d0a84ac93cbb759798\" : \"0000000000000000000000000000000000000000000000000000000000000001\" , \"cea2b0602db61f92b76ec4402875cc38eedc9fc425cb1b697fc2265d50fc20fb\" : \"0000000000000000000000000000000000000000000000000000000000000001\" , } } }, ... } The contract code in the genesis file defines the: Address. Balance. Bytecode. Key value pairs for contract storage.","title":"Pre-deploying contracts in the genesis file"},{"location":"configure-and-manage/configure/genesis-file/genesis-options/","text":"Creating the GoQuorum genesis file \u00b6 The genesis file defines the first block in the chain, and the first block defines which chain you want to join. Create a JSON genesis file , then specify the genesis file when initalizing GoQuorum with: geth init <PATH-TO-GENESIS-FILE> The genesis file specifies the network-wide settings , so all nodes in a network must use the same genesis file. Example Raft genesis file { \"alloc\" : { \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0x0fbdc686b912d7722dc86510934589e0aaf3b55a\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0x9186eb3d20cbd1f5f992a950d808c4495153abd5\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" : { \"balance\" : \"1000000000000000000000000000\" } }, \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"maxCodeSizeConfig\" : [ { \"block\" : 0 , \"size\" : 35 } ], \"isQuorum\" : true }, \"difficulty\" : \"0x0\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"gasLimit\" : \"0xE0000000\" , \"mixhash\" : \"0x00000000000000000000000000000000000000647572616c65787365646c6578\" , \"nonce\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"timestamp\" : \"0x00\" }","title":"Create a genesis file"},{"location":"configure-and-manage/configure/genesis-file/genesis-options/#creating-the-goquorum-genesis-file","text":"The genesis file defines the first block in the chain, and the first block defines which chain you want to join. Create a JSON genesis file , then specify the genesis file when initalizing GoQuorum with: geth init <PATH-TO-GENESIS-FILE> The genesis file specifies the network-wide settings , so all nodes in a network must use the same genesis file. Example Raft genesis file { \"alloc\" : { \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0x0fbdc686b912d7722dc86510934589e0aaf3b55a\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0x9186eb3d20cbd1f5f992a950d808c4495153abd5\" : { \"balance\" : \"1000000000000000000000000000\" }, \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" : { \"balance\" : \"1000000000000000000000000000\" } }, \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"maxCodeSizeConfig\" : [ { \"block\" : 0 , \"size\" : 35 } ], \"isQuorum\" : true }, \"difficulty\" : \"0x0\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"gasLimit\" : \"0xE0000000\" , \"mixhash\" : \"0x00000000000000000000000000000000000000647572616c65787365646c6578\" , \"nonce\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"timestamp\" : \"0x00\" }","title":"Creating the GoQuorum genesis file"},{"location":"configure-and-manage/configure/permissioning/basic-permissions/","text":"Configure basic permissions \u00b6 Basic network permissioning is a feature that controls which nodes can connect to a given node, and which nodes the given node can dial out to. Configure basic permissions by providing the \u2013permissioned command line option when starting the node. If --permissioned is set, the node looks for a file named <data-dir>/permissioned-nodes.json . This file contains the allowlist of enodes that this node can connect to and accept connections from. Only the nodes that are listed in the permissioned-nodes.json file become part of the network. If --permissioned is specified but no nodes are added to the permissioned-nodes.json file, this node can neither connect to any nodes nor accept any incoming connections. The permissioned-nodes.json file is structured as follows, which is similar to the <data-dir>/static-nodes.json file that is used to specify the list of static nodes a given node always connects to: permissioned-nodes.json Syntax [ \"enode://remotekey1@ip1:port1\" , \"enode://remotekey2@ip2:port2\" , \"enode://remotekey3@ip3:port3\" , ] Example [ \"enode://6598638ac5b15ee386210156a43f565fa8c48592489d3e66ac774eac759db9eb52866898cf0c5e597a1595d9e60e1a19c84f77df489324e2f3a967207c047470@127.0.0.1:30300\" ] Note You can use DNS names instead of IP addresses to specify nodes in permissioned-nodes.json and static-nodes.json . Only bootnodes need to be specified with IP addresses. Warning Every node has its own copy of the permissioned-nodes.json file. If different nodes have different lists of remote keys, then each node may have a different list of permissioned nodes which may have an adverse effect on the network.","title":"Basic permissioning"},{"location":"configure-and-manage/configure/permissioning/basic-permissions/#configure-basic-permissions","text":"Basic network permissioning is a feature that controls which nodes can connect to a given node, and which nodes the given node can dial out to. Configure basic permissions by providing the \u2013permissioned command line option when starting the node. If --permissioned is set, the node looks for a file named <data-dir>/permissioned-nodes.json . This file contains the allowlist of enodes that this node can connect to and accept connections from. Only the nodes that are listed in the permissioned-nodes.json file become part of the network. If --permissioned is specified but no nodes are added to the permissioned-nodes.json file, this node can neither connect to any nodes nor accept any incoming connections. The permissioned-nodes.json file is structured as follows, which is similar to the <data-dir>/static-nodes.json file that is used to specify the list of static nodes a given node always connects to: permissioned-nodes.json Syntax [ \"enode://remotekey1@ip1:port1\" , \"enode://remotekey2@ip2:port2\" , \"enode://remotekey3@ip3:port3\" , ] Example [ \"enode://6598638ac5b15ee386210156a43f565fa8c48592489d3e66ac774eac759db9eb52866898cf0c5e597a1595d9e60e1a19c84f77df489324e2f3a967207c047470@127.0.0.1:30300\" ] Note You can use DNS names instead of IP addresses to specify nodes in permissioned-nodes.json and static-nodes.json . Only bootnodes need to be specified with IP addresses. Warning Every node has its own copy of the permissioned-nodes.json file. If different nodes have different lists of remote keys, then each node may have a different list of permissioned nodes which may have an adverse effect on the network.","title":"Configure basic permissions"},{"location":"configure-and-manage/configure/permissioning/enhanced-permissions/","text":"Configure enhanced permissions \u00b6 Enhanced network permissioning is a smart-contract-based permissioning model designed for enterprise-level needs. You can configure enhanced permissioning for a new network or when migrating from an earlier version . New network \u00b6 Start the initial set of nodes. Deploy the PermissionsUpgradable.sol contract in the network, which requires specifying a guardian account. Deploy the rest of the contracts, which requires specifying the address of PermissionsUpgradable.sol . Once all the contracts are deployed, create a file permission-config.json with the following construct: permission-config.json { \"permissionModel\" : \"v2\" , \"upgradableAddress\" : \"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\" , \"interfaceAddress\" : \"0x4d3bfd7821e237ffe84209d8e638f9f309865b87\" , \"implAddress\" : \"0xfe0602d820f42800e3ef3f89e1c39cd15f78d283\" , \"nodeMgrAddress\" : \"0x8a5e2a6343108babed07899510fb42297938d41f\" , \"accountMgrAddress\" : \"0x9d13c6d3afe1721beef56b55d303b09e021e27ab\" , \"roleMgrAddress\" : \"0x1349f3e1b8d71effb47b840594ff27da7e603d17\" , \"voterMgrAddress\" : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , \"orgMgrAddress\" : \"0x938781b9796aea6376e40ca158f67fa89d5d8a18\" , \"nwAdminOrg\" : \"ADMINORG\" , \"nwAdminRole\" : \"ADMIN\" , \"orgAdminRole\" : \"ORGADMIN\" , \"accounts\" :[ \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" ], \"subOrgBreadth\" : 3 , \"subOrgDepth\" : 4 } permissionModel - Permission model to be used ( v1 or v2 ). upgradableAddress - Address of deployed contract PermissionsUpgradable.sol . interfaceAddress - Address of deployed contract PermissionsInterface.sol . implAddress - Address of deployed contract PermissionsImplementation.sol . nodeMgrAddress - Address of deployed contract NodeManager.sol . accountMgrAddress - Address of deployed contract AccountManager.sol . roleMgrAddress - Address of deployed contract RoleManager.sol . voterMgrAddress - Address of deployed contract VoterManager.sol . orgMgrAddress - Address of deployed contract OrgManager.sol . nwAdminOrg - Name of the initial organization to be created as a part of the network boot up with a new permissions model. This organization owns all the initial nodes and network administrator accounts at the network boot up. nwAdminRole - Role ID to be assigned to the network administrator accounts. orgAdminRole - Role ID to be assigned to the organization administrator account. accounts - Initial list of accounts linked to the network administrator organization and assigned the network administrator role. These accounts have complete control of the network and can propose and approve new organizations into the network. subOrgBreadth - Number of sub-organizations that any organization can have. subOrgDepth - Maximum depth of sub-organization hierarchy allowed in the network. Once the contracts are deployed, execute init in PermissionsUpgradable.sol through the guardian account. This links the interface and implementation contracts. At the geth prompt, load the following script after replacing the contract addresses appropriately: Example ac = eth . accounts [ 0 ]; web3 . eth . defaultAccount = ac ; var abi = [{ \"constant\" : true , \"inputs\" : [], \"name\" : \"getPermImpl\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_proposedImpl\" , \"type\" : \"address\" }], \"name\" : \"confirmImplChange\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"getGuardian\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"getPermInterface\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_permInterface\" , \"type\" : \"address\" },{ \"name\" : \"_permImpl\" , \"type\" : \"address\" }], \"name\" : \"init\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_guardian\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" }]; var upgr = web3 . eth . contract ( abi ). at ( \"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\" ); // address of the upgradable contracts var impl = \"0xfe0602d820f42800e3ef3f89e1c39cd15f78d283\" // address of the implementation contracts var intr = \"0x4d3bfd7821e237ffe84209d8e638f9f309865b87\" // address of the interface contracts Execute upgr.init(intr, impl, {from: <guardian account>, gas: 4500000}) . Stop all geth nodes in the network and copy permission-config.json into the data directory of each node. Migrating from an earlier version \u00b6 Stop the running network in the earlier version. Set the maxCodeSize attribute in genesis.json to 35. \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"maxCodeSize\" : 35 , \"isQuorum\" : true } Execute geth --datadir <data dir path> init genesis.json . Follow the steps to configure enhanced permission for a new network . Note The new permissioning model will be in effect only when permission-config.json is present in data directory. If this file is not there and the node is started with --permissioned , the old permissioning model will be in effect.","title":"Enhanced permissioning"},{"location":"configure-and-manage/configure/permissioning/enhanced-permissions/#configure-enhanced-permissions","text":"Enhanced network permissioning is a smart-contract-based permissioning model designed for enterprise-level needs. You can configure enhanced permissioning for a new network or when migrating from an earlier version .","title":"Configure enhanced permissions"},{"location":"configure-and-manage/configure/permissioning/enhanced-permissions/#new-network","text":"Start the initial set of nodes. Deploy the PermissionsUpgradable.sol contract in the network, which requires specifying a guardian account. Deploy the rest of the contracts, which requires specifying the address of PermissionsUpgradable.sol . Once all the contracts are deployed, create a file permission-config.json with the following construct: permission-config.json { \"permissionModel\" : \"v2\" , \"upgradableAddress\" : \"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\" , \"interfaceAddress\" : \"0x4d3bfd7821e237ffe84209d8e638f9f309865b87\" , \"implAddress\" : \"0xfe0602d820f42800e3ef3f89e1c39cd15f78d283\" , \"nodeMgrAddress\" : \"0x8a5e2a6343108babed07899510fb42297938d41f\" , \"accountMgrAddress\" : \"0x9d13c6d3afe1721beef56b55d303b09e021e27ab\" , \"roleMgrAddress\" : \"0x1349f3e1b8d71effb47b840594ff27da7e603d17\" , \"voterMgrAddress\" : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , \"orgMgrAddress\" : \"0x938781b9796aea6376e40ca158f67fa89d5d8a18\" , \"nwAdminOrg\" : \"ADMINORG\" , \"nwAdminRole\" : \"ADMIN\" , \"orgAdminRole\" : \"ORGADMIN\" , \"accounts\" :[ \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" ], \"subOrgBreadth\" : 3 , \"subOrgDepth\" : 4 } permissionModel - Permission model to be used ( v1 or v2 ). upgradableAddress - Address of deployed contract PermissionsUpgradable.sol . interfaceAddress - Address of deployed contract PermissionsInterface.sol . implAddress - Address of deployed contract PermissionsImplementation.sol . nodeMgrAddress - Address of deployed contract NodeManager.sol . accountMgrAddress - Address of deployed contract AccountManager.sol . roleMgrAddress - Address of deployed contract RoleManager.sol . voterMgrAddress - Address of deployed contract VoterManager.sol . orgMgrAddress - Address of deployed contract OrgManager.sol . nwAdminOrg - Name of the initial organization to be created as a part of the network boot up with a new permissions model. This organization owns all the initial nodes and network administrator accounts at the network boot up. nwAdminRole - Role ID to be assigned to the network administrator accounts. orgAdminRole - Role ID to be assigned to the organization administrator account. accounts - Initial list of accounts linked to the network administrator organization and assigned the network administrator role. These accounts have complete control of the network and can propose and approve new organizations into the network. subOrgBreadth - Number of sub-organizations that any organization can have. subOrgDepth - Maximum depth of sub-organization hierarchy allowed in the network. Once the contracts are deployed, execute init in PermissionsUpgradable.sol through the guardian account. This links the interface and implementation contracts. At the geth prompt, load the following script after replacing the contract addresses appropriately: Example ac = eth . accounts [ 0 ]; web3 . eth . defaultAccount = ac ; var abi = [{ \"constant\" : true , \"inputs\" : [], \"name\" : \"getPermImpl\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_proposedImpl\" , \"type\" : \"address\" }], \"name\" : \"confirmImplChange\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"getGuardian\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"getPermInterface\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_permInterface\" , \"type\" : \"address\" },{ \"name\" : \"_permImpl\" , \"type\" : \"address\" }], \"name\" : \"init\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_guardian\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" }]; var upgr = web3 . eth . contract ( abi ). at ( \"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\" ); // address of the upgradable contracts var impl = \"0xfe0602d820f42800e3ef3f89e1c39cd15f78d283\" // address of the implementation contracts var intr = \"0x4d3bfd7821e237ffe84209d8e638f9f309865b87\" // address of the interface contracts Execute upgr.init(intr, impl, {from: <guardian account>, gas: 4500000}) . Stop all geth nodes in the network and copy permission-config.json into the data directory of each node.","title":"New network"},{"location":"configure-and-manage/configure/permissioning/enhanced-permissions/#migrating-from-an-earlier-version","text":"Stop the running network in the earlier version. Set the maxCodeSize attribute in genesis.json to 35. \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"maxCodeSize\" : 35 , \"isQuorum\" : true } Execute geth --datadir <data dir path> init genesis.json . Follow the steps to configure enhanced permission for a new network . Note The new permissioning model will be in effect only when permission-config.json is present in data directory. If this file is not there and the node is started with --permissioned , the old permissioning model will be in effect.","title":"Migrating from an earlier version"},{"location":"configure-and-manage/manage/add-nodes/","text":"Adding nodes to the network \u00b6 Adding new nodes to an existing network can range from a common occurrence to never happening. In public blockchains such as Ethereum Mainnet, new nodes continuously join and talk to the existing network. In permissioned blockchains, this may not happen as often, but it\u2019s still an important task to achieve as your network evolves. When adding new nodes to the network, it\u2019s important to understand that the GoQuorum network and Tessera network are distinct and do not overlap in any way. Therefore, options applicable to one are not applicable to the other. In some cases, they may have their own options to achieve similar tasks, but must be specified separately. Prerequisites \u00b6 GoQuorum installed Tessera A running network Adding GoQuorum nodes \u00b6 Raft \u00b6 Use the following API methods on an existing node to add, remove, and promote nodes in a Raft network: raft_addPeer to add a verifier node raft_addLearner to add a learner node raft_promoteToPeer to promote a learner to a verifier raft_removePeer to remove a node If you are using permissioning or peer-to-peer discovery, see the extra options . After addPeer or addLearner : Initialize the new node with the network\u2019s genesis configuration: geth --datadir <NEW-NODE-DATA-DIRECTORY> init <GENESIS-FILE> Note Where you get the genesis file is dependent on the network. You may get it from an existing peer, a network operator, or somewhere else. Start the new GoQuorum node with the --raftjoinexisting and --raft command line options. Use the Raft ID returned by addPeer or addLearner as the argument for --raftjoinexisting . Example PRIVATE_CONFIG = ignore geth --datadir qdata/dd7 ... OTHER ARGS ... --raft --raftport 50407 --http.port 22006 --port 21006 --raftjoinexisting 7 The new node is now up and running, and will start syncing the blockchain from existing peers. Once this has completed, it can send new transactions just as any other peer. Important For a Raft network to work, 51% of the peers must be up and running. We recommend having an odd number of at least 3 peers in a network. IBFT, QBFT, and Clique \u00b6 Adding a non-validator node to an IBFT , QBFT , or Clique network is simpler than adding a node to a Raft network, as it only needs to configure itself rather than be pre-allocated on the network (permissioning aside). Initialize the new node with the network\u2019s genesis configuration: geth --datadir <NEW-NODE-DATA-DIRECTORY> init <GENESIS-FILE> Note Where you get the genesis file is dependent on the network. You may get it from an existing peer, a network operator, or somewhere else. If you are using permissioning or peer-to-peer discovery, see the extra options . Start the new node, pointing either to a bootnode or listing an existing peer in the static-nodes.json file. Once a connection is established, the node will start syncing the blockchain, after which transactions can be sent. Adding a validator to an IBFT or QBFT network requires using the consensus APIs outlined in the IBFT tutorial and the QBFT tutorial . Info Validator nodes require the --mine command line option on startup, which enables mining, while non-validator nodes do not. Extra options \u00b6 Some options take effect regardless of the consensus mechanism used. Permissioned nodes \u00b6 If you have permissioning configured using the permissioned-nodes.json file, make sure this file is updated on all nodes before the new node is able to communicate with existing nodes. You don\u2019t need to restart any nodes for the changes to take effect. Static node connections \u00b6 If not using peer-to-peer node discovery (for example, you specify --nodiscover ), then the node only makes connections to peers defined in the static-nodes.json file. When adding a new node, configure static peers in its static-nodes.json file. The more peers defined here, the better the network connectivity and fault tolerance. Note You don\u2019t need to update the existing peers\u2019 static nodes for the connection to be established, although it is good practice to do so. You don\u2019t need to specify every peer in your static nodes file if you do not wish to connect to every peer directly. Peer-to-peer discovery \u00b6 If using discovery, more options in addition to static nodes become available. Any nodes connected to your peers, which at the start are your static peers , are discoverable by you; you connect to these nodes automatically. You may specify bootnodes using the --bootnodes parameter. This takes a comma-separated list of enode URLs, similar to the static-nodes.json file. These act in the same way as static nodes, letting you connect to them and find out about other peers, who you then connect to. Note If you have discovery disabled, you won\u2019t try to find other nodes to connect to, but others can still find and connect to you. Adding Tessera nodes \u00b6 Add a new Tessera node by ensuring you have one of the existing nodes listed in your Tessera peer list. Peer configuration example { \"peers\" : [ { \"url\" : \"http://existingpeer1.com:8080\" } ] } From there, Tessera connects to that peer and discovers and connects to all the other Tessera nodes in the network. Note You may want to include multiple peers in the peer list in case any of them are offline/unreachable. IP allowlisting \u00b6 Tessera IP allowlisting (whitelisting) restricts connections in a way similar to using permissioned-nodes.json in GoQuorum. If allowlisting is configured , only IP addresses/hostnames in your Tessera peer list can connect to you. To add a new Tessera node with allowlisting enabled: Add the new peer to each of the existing nodes. You can run the following command without restarting an already running node: java -jar tessera.jar admin -configfile /path/to/existing-node-config.json -addpeer http://newpeer.com:8080 Start the new peer, setting the peers configuration to mirror the existing network. Peers configuration example { \"peers\" : [ { \"url\" : \"http://existingpeer1.com:8080\" }, { \"url\" : \"http://existingpeer2.com:8080\" }, { \"url\" : \"http://existingpeer3.com:8080\" } ] } The new node now allows incoming connections from the existing peers, and existing peers allow incoming connections from the new peer. Discovery \u00b6 You can disable Tessera discovery to have Tessera only allow keys that are owned by a node in its peer list to be available to the users. This means that if Tessera finds any keys owned by a node not in its peer list, those keys are discarded and private transactions cannot be sent to that public key. Notes This does not affect incoming transactions. Someone not in your peer list can still send transactions to your node, unless you also enable the IP allowlist option. IP allowlisting blocks communications between nodes, whereas disabling discovery only affects which public keys Tessera keeps track of. To add a new Tessera node with discovery disabled: Add the new peer to each of the existing nodes. You can run the following command without restarting an already running node: java -jar tessera.jar admin -configfile /path/to/existing-node-config.json -addpeer http://newpeer.com:8080 Start the new peer, setting the peers configuration to mirror the existing network. Peers configuration example { \"peers\" : [ { \"url\" : \"http://existingpeer1.com:8080\" }, { \"url\" : \"http://existingpeer2.com:8080\" }, { \"url\" : \"http://existingpeer3.com:8080\" } ] } The new node now records public keys belonging to the existing peers, and existing peers record public keys belonging to the new peer. This allows private transactions to be sent both directions.","title":"Add network nodes"},{"location":"configure-and-manage/manage/add-nodes/#adding-nodes-to-the-network","text":"Adding new nodes to an existing network can range from a common occurrence to never happening. In public blockchains such as Ethereum Mainnet, new nodes continuously join and talk to the existing network. In permissioned blockchains, this may not happen as often, but it\u2019s still an important task to achieve as your network evolves. When adding new nodes to the network, it\u2019s important to understand that the GoQuorum network and Tessera network are distinct and do not overlap in any way. Therefore, options applicable to one are not applicable to the other. In some cases, they may have their own options to achieve similar tasks, but must be specified separately.","title":"Adding nodes to the network"},{"location":"configure-and-manage/manage/add-nodes/#prerequisites","text":"GoQuorum installed Tessera A running network","title":"Prerequisites"},{"location":"configure-and-manage/manage/add-nodes/#adding-goquorum-nodes","text":"","title":"Adding GoQuorum nodes"},{"location":"configure-and-manage/manage/add-nodes/#raft","text":"Use the following API methods on an existing node to add, remove, and promote nodes in a Raft network: raft_addPeer to add a verifier node raft_addLearner to add a learner node raft_promoteToPeer to promote a learner to a verifier raft_removePeer to remove a node If you are using permissioning or peer-to-peer discovery, see the extra options . After addPeer or addLearner : Initialize the new node with the network\u2019s genesis configuration: geth --datadir <NEW-NODE-DATA-DIRECTORY> init <GENESIS-FILE> Note Where you get the genesis file is dependent on the network. You may get it from an existing peer, a network operator, or somewhere else. Start the new GoQuorum node with the --raftjoinexisting and --raft command line options. Use the Raft ID returned by addPeer or addLearner as the argument for --raftjoinexisting . Example PRIVATE_CONFIG = ignore geth --datadir qdata/dd7 ... OTHER ARGS ... --raft --raftport 50407 --http.port 22006 --port 21006 --raftjoinexisting 7 The new node is now up and running, and will start syncing the blockchain from existing peers. Once this has completed, it can send new transactions just as any other peer. Important For a Raft network to work, 51% of the peers must be up and running. We recommend having an odd number of at least 3 peers in a network.","title":"Raft"},{"location":"configure-and-manage/manage/add-nodes/#ibft-qbft-and-clique","text":"Adding a non-validator node to an IBFT , QBFT , or Clique network is simpler than adding a node to a Raft network, as it only needs to configure itself rather than be pre-allocated on the network (permissioning aside). Initialize the new node with the network\u2019s genesis configuration: geth --datadir <NEW-NODE-DATA-DIRECTORY> init <GENESIS-FILE> Note Where you get the genesis file is dependent on the network. You may get it from an existing peer, a network operator, or somewhere else. If you are using permissioning or peer-to-peer discovery, see the extra options . Start the new node, pointing either to a bootnode or listing an existing peer in the static-nodes.json file. Once a connection is established, the node will start syncing the blockchain, after which transactions can be sent. Adding a validator to an IBFT or QBFT network requires using the consensus APIs outlined in the IBFT tutorial and the QBFT tutorial . Info Validator nodes require the --mine command line option on startup, which enables mining, while non-validator nodes do not.","title":"IBFT, QBFT, and Clique"},{"location":"configure-and-manage/manage/add-nodes/#extra-options","text":"Some options take effect regardless of the consensus mechanism used.","title":"Extra options"},{"location":"configure-and-manage/manage/add-nodes/#permissioned-nodes","text":"If you have permissioning configured using the permissioned-nodes.json file, make sure this file is updated on all nodes before the new node is able to communicate with existing nodes. You don\u2019t need to restart any nodes for the changes to take effect.","title":"Permissioned nodes"},{"location":"configure-and-manage/manage/add-nodes/#static-node-connections","text":"If not using peer-to-peer node discovery (for example, you specify --nodiscover ), then the node only makes connections to peers defined in the static-nodes.json file. When adding a new node, configure static peers in its static-nodes.json file. The more peers defined here, the better the network connectivity and fault tolerance. Note You don\u2019t need to update the existing peers\u2019 static nodes for the connection to be established, although it is good practice to do so. You don\u2019t need to specify every peer in your static nodes file if you do not wish to connect to every peer directly.","title":"Static node connections"},{"location":"configure-and-manage/manage/add-nodes/#peer-to-peer-discovery","text":"If using discovery, more options in addition to static nodes become available. Any nodes connected to your peers, which at the start are your static peers , are discoverable by you; you connect to these nodes automatically. You may specify bootnodes using the --bootnodes parameter. This takes a comma-separated list of enode URLs, similar to the static-nodes.json file. These act in the same way as static nodes, letting you connect to them and find out about other peers, who you then connect to. Note If you have discovery disabled, you won\u2019t try to find other nodes to connect to, but others can still find and connect to you.","title":"Peer-to-peer discovery"},{"location":"configure-and-manage/manage/add-nodes/#adding-tessera-nodes","text":"Add a new Tessera node by ensuring you have one of the existing nodes listed in your Tessera peer list. Peer configuration example { \"peers\" : [ { \"url\" : \"http://existingpeer1.com:8080\" } ] } From there, Tessera connects to that peer and discovers and connects to all the other Tessera nodes in the network. Note You may want to include multiple peers in the peer list in case any of them are offline/unreachable.","title":"Adding Tessera nodes"},{"location":"configure-and-manage/manage/add-nodes/#ip-allowlisting","text":"Tessera IP allowlisting (whitelisting) restricts connections in a way similar to using permissioned-nodes.json in GoQuorum. If allowlisting is configured , only IP addresses/hostnames in your Tessera peer list can connect to you. To add a new Tessera node with allowlisting enabled: Add the new peer to each of the existing nodes. You can run the following command without restarting an already running node: java -jar tessera.jar admin -configfile /path/to/existing-node-config.json -addpeer http://newpeer.com:8080 Start the new peer, setting the peers configuration to mirror the existing network. Peers configuration example { \"peers\" : [ { \"url\" : \"http://existingpeer1.com:8080\" }, { \"url\" : \"http://existingpeer2.com:8080\" }, { \"url\" : \"http://existingpeer3.com:8080\" } ] } The new node now allows incoming connections from the existing peers, and existing peers allow incoming connections from the new peer.","title":"IP allowlisting"},{"location":"configure-and-manage/manage/add-nodes/#discovery","text":"You can disable Tessera discovery to have Tessera only allow keys that are owned by a node in its peer list to be available to the users. This means that if Tessera finds any keys owned by a node not in its peer list, those keys are discarded and private transactions cannot be sent to that public key. Notes This does not affect incoming transactions. Someone not in your peer list can still send transactions to your node, unless you also enable the IP allowlist option. IP allowlisting blocks communications between nodes, whereas disabling discovery only affects which public keys Tessera keeps track of. To add a new Tessera node with discovery disabled: Add the new peer to each of the existing nodes. You can run the following command without restarting an already running node: java -jar tessera.jar admin -configfile /path/to/existing-node-config.json -addpeer http://newpeer.com:8080 Start the new peer, setting the peers configuration to mirror the existing network. Peers configuration example { \"peers\" : [ { \"url\" : \"http://existingpeer1.com:8080\" }, { \"url\" : \"http://existingpeer2.com:8080\" }, { \"url\" : \"http://existingpeer3.com:8080\" } ] } The new node now records public keys belonging to the existing peers, and existing peers record public keys belonging to the new peer. This allows private transactions to be sent both directions.","title":"Discovery"},{"location":"configure-and-manage/manage/enhanced-permissions/","text":"Using enhanced permissioning \u00b6 Managing the enhanced permissioning model can be broadly categorized into the following activities: Setting up the initial network \u00b6 Please refer to the configuration instructions for detailed information. For an existing network running with an older version of GoQuorum: Upgrade GoQuorum to the latest version. Deploy the contracts. Execute the init method of PermissionsUpgradable.sol from the guardian account. Copy the permission-config.json to the data directory of each node. Bring geth up in --permissioned mode. For a new network using the latest version of GoQuorum: Bring up the initial set of nodes. Deploy the contracts. Execute the init method of PermissionsUpgradable.sol from the guardian account. Upgrade GoQuorum to the latest version. Copy the permission-config.json to the data directory of each node. Bring geth up in --permissioned mode. As part of network initialization: A network admin organization is created with the nwAdminOrg name specified in permission-config.json . All nodes which are part of static-nodes.json are assigned to this organization. A network admin role is created with the nwAdminRole name specified in the config file. All accounts given in the accounts array of the config file are assigned the network admin role. These accounts will have the ability to propose and approve new organizations into the network. Example \u00b6 This example assumes that the network was started with the permission-config.json given in the configuration instructions , and that the network was brought up with the static-nodes.json file as the following: [ \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" , \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" , \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" , \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" ] View the organization list with the following command: geth console request quorumPermission . orgList geth console result [{ full OrgId : \"ADMINORG\" , level : 1 , orgId : \"ADMINORG\" , pare nt OrgId : \"\" , s tatus : 2 , subOrgLis t : null , ul t ima te Pare nt : \"ADMINORG\" }] View ADMINORG \u2018s details: geth console request quorumPermission . getOrgDetails ( \"ADMINORG\" ) geth console result { acc t Lis t : [{ acc t Id : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , isOrgAdmi n : true , orgId : \"ADMINORG\" , roleId : \"ADMIN\" , s tatus : 2 }, { acc t Id : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , isOrgAdmi n : true , orgId : \"ADMINORG\" , roleId : \"ADMIN\" , s tatus : 2 }], n odeLis t : [{ orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }], roleLis t : [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : true , orgId : \"ADMINORG\" , roleId : \"ADMIN\" }], subOrgLis t : null } Proposing a new organization into the network \u00b6 Once the network is up, the network admin accounts can then propose a new organization into the network. Majority approval from the network admin accounts is required before an organization is approved. The APIs for proposing and approving an organization are documented in permission APIs . Example \u00b6 This example is to propose and approve an organization by name ORG1 . Propose to add ORG1 with the following command: geth console request quorumPermission . addOrg ( \"ORG1\" , \"enode://de9c2d5937e599930832cecc1df8cc90b50839bdf635c1a4e68e1dab2d001cd4a11c626e155078cc65958a72e2d72c1342a28909775edd99cc39470172cce0ac@127.0.0.1:21004?discport=0\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" Once the organization is proposed, it will be in Proposed state awaiting approval from other network admin accounts. View ORG1 \u2018s status: geth console request quorumPermission . orgList [ 1 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 1 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } The network admin accounts can then approve the proposed organizations with the following command, and once the majority approval is achieved, the organization status is updated to Approved : geth console request quorumPermission . approveOrg ( \"ORG1\" , \"enode://de9c2d5937e599930832cecc1df8cc90b50839bdf635c1a4e68e1dab2d001cd4a11c626e155078cc65958a72e2d72c1342a28909775edd99cc39470172cce0ac@127.0.0.1:21004?discport=0\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , { from : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" }) geth console result \"Action completed successfully\" See that ORG1 \u2018s status was updated in the organization list with the following command: geth console request quorumPermission . orgList [ 1 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 2 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } View the details of the new approved organization: geth console request quorumPermission . getOrgDetails ( \"ORG1\" ) geth console result { acc t Lis t : [{ acc t Id : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , isOrgAdmi n : true , orgId : \"ORG1\" , roleId : \"ORGADMIN\" , s tatus : 2 }], n odeLis t : [{ orgId : \"ORG1\" , s tatus : 2 , url : \"enode://de9c2d5937e599930832cecc1df8cc90b50839bdf635c1a4e68e1dab2d001cd4a11c626e155078cc65958a72e2d72c1342a28909775edd99cc39470172cce0ac@127.0.0.1:21004?discport=0\" }], roleLis t : [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : true , orgId : \"ORG1\" , roleId : \"ORGADMIN\" }], subOrgLis t : null } At this point: An organization admin role with name as given in orgAdminRole in permission-config.json has been created and linked to the ORG1 . The account 0x0638e1574728b6d862dd5d3a3e0942c3be47d996 has been linked to ORG1 and the organization admin role. This account acts as the organization admin account and can manage further roles, nodes, and accounts at the organization level. The node has been linked to the organization and its status has been updated as Approved . The new node belonging to the organization can now join the network. In case the network is running in Raft consensus mode, before the node joins the network, ensure that: The node has been added as a peer using raft.addPeer(<<enodeId>>) . You bring up geth for the new node using --raftjoinexisting with the peer ID as obtained in the previous step. Managing the organization-level permissions \u00b6 Once the organization is approved and the node of the organization has joined the network, the organization admin can: Create sub-organizations, add roles, and add additional nodes at organization level. Add accounts to the organization. Change roles of existing organization-level accounts. Use quorumPermission_addSubOrg to add a sub-organization at the ORG1 level. Example \u00b6 Add a sub-organization with the following command: geth console request quorumPermission . addSubOrg ( \"ORG1\" , \"SUB1\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" , { from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" Get the sub-organization\u2019s details: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ) geth console result { acc t Lis t : null , n odeLis t : [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }], roleLis t : null , subOrgLis t : null } The enode ID is not mandatory for adding a sub-organization. If the organization admin wants to add an admin account for the newly created sub-organization, the organization admin account must first create a role using quorumPermission_addNewRole with isAdminRole set to true , then assign this role to the account which belongs to the sub-organization. Once assigned, the account will act as organization admin at the sub-organization level. Add a new admin account for the sub-organization with the following command: geth console request quorumPermission . addNewRole ( \"ORG1.SUB1\" , \"SUBADMIN\" , 3 , false , true ,{ from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" View the organization admin account ID: geth console request eth . accounts [ 0 ] geth console result \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" The sub-organization admin role SUBADMIN can now be assigned to an account at SUB1 . Add the account as a SUBADMIN to SUB1 with the following command: geth console request quorumPermission . addAccountToOrg ( \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , \"ORG1.SUB1\" , \"SUBADMIN\" , { from : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" }) geth console result \"Action completed successfully\" View SUB1 \u2018s details: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ) geth console results { acc t Lis t : [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }], n odeLis t : [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }], roleLis t : [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : false , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" }], subOrgLis t : null } The account 0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0 is now the admin for SUB1 and can add roles, accounts, and nodes to the sub-organization. Add a new role TRANSACT to SUB1 with the following command: geth console request quorumPermission . addNewRole ( \"ORG1.SUB1\" , \"TRANSACT\" , 1 , false , true ,{ from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View SUB1 \u2018s role list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). roleList geth console result [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : false , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" }, { access : 1 , ac t ive : true , isAdmi n : true , isVo ter : false , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" }] Note The organization admin account at the master organization level has the admin rights on all the children sub-organizations. However, the admin account at the sub-organization level has control only in its sub-organization. To add an account to an organization, use quorumPermission_addAccountToOrg : geth console request quorumPermission . addAccountToOrg ( \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , \"ORG1.SUB1\" , \"SUBADMIN\" , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 2 }] To suspend an account, use quorumPermission_updateAccountStatus with action set to 1: geth console request quorumPermission . updateAccountStatus ( \"ORG1.SUB1\" , \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , 1 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the account\u2019s updated status in the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 1 }] To revoke suspension of an account, use quorumPermission_updateAccountStatus with action set to 2: geth console request quorumPermission . updateAccountStatus ( \"ORG1.SUB1\" , \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , 2 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console resultt \"Action completed successfully\" View the account\u2019s updated status in the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 2 }] To exclude an account, use quorumPermission_updateAccountStatus with action set to 3: geth console request quorumPermission . updateAccountStatus ( \"ORG1.SUB1\" , \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , 3 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" Once excluded, no further activity is possible on the account. View the account\u2019s updated status in the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 5 }] To add nodes at the organization and sub-organization level, use quorumPermission_addNode : geth console request quorumPermission . addNode ( \"ORG1.SUB1\" , \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated node list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] To manage the status of the nodes, use quorumPermission_updateNodeStatus . To deactivate a node, call the method with action set to 1: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 3 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] To re-activate a node, use quorumPermission_updateNodeStatus with action set to 2: geth console request quorumPermission . updateNodeStatus ( \"ORG1.SUB1\" , \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" , 2 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the node\u2019s updated status in the organization\u2019s node list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] To exclude a node, use quorumPermission_updateNodeStatus with action set to 3: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 4 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] Once excluded, a node can\u2019t re-join a network. Note In Raft consensus, when a node is deactivated, the peer ID is lost. Upon activation, the node needs to be added to the Raft cluster again using raft.addPeer and the node should be brought up with a new peer ID. An account can transact from any of the nodes within the same organization. No transaction is allowed from a deactivated node. Suspending an organization temporarily \u00b6 If you need to temporarily suspend all activities of an organization, use quorumPermission_updateOrgStatus with action set to `. This can be invoked only by network admin accounts and requires majority approval. Example \u00b6 Suspend ORG1 with the following command: geth console request quorumPermission . updateOrgStatus ( \"ORG1\" , 1 , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated status in the organization list: geth console request quorumPermission . orgList [ 2 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 3 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } Suspending an organization requires majority approval from other network admin accounts, using quorumPermission_approveOrgStatus . Once approved the organization status is marked as Suspended . geth console request quorumPermission . approveOrgStatus ( \"ORG1\" , 1 , { from : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated status in the organization list: geth console request quorumPermission . orgList [ 2 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 4 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } When the organization is suspended, no transaction from any of the accounts linked to the organization or sub-organizations under it is allowed. However, the nodes linked to the organization are active and are syncing with the network. Revoking suspension of an organization \u00b6 To revoke the suspension of an organization, use quorumPermission_updateOrgStatus with action set to 2. Example \u00b6 Revoke the suspension of ORG1 with the following command: geth console request quorumPermission . updateOrgStatus ( \"ORG1\" , 2 , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" Revoking an organization\u2019s suspension requires majority approval using quorumPermission_approveOrgStatus with action set to 2: geth console request quorumPermission . approveOrgStatus ( \"ORG1\" , 2 , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated status in the organization list: geth console request quorumPermission . orgList [ 0 ] geth console result { full OrgId : \"ORG1.SUB1\" , level : 2 , orgId : \"SUB1\" , pare nt OrgId : \"ORG1\" , s tatus : 2 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } Once the revoke is approved, all accounts in the organization and sub-organizations under it are able to transact as per role level access. Assigning admin privileges at organization and network level \u00b6 At times, an account at the organization level may need be able to perform network admin activities. Also, there may be a need to change the admin account at organization level. Both of these activities can be performed by existing network admin accounts only, and will require majority approval from the network admin accounts. Example \u00b6 To assign a network admin or organization admin role to an account, use quorumPermission_assignAdminRole : geth console request quorumPermission . assignAdminRole ( \"ORG1\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , \"ADMIN\" , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" View the account\u2019s updated role in the account list: geth console request quorumPermission . acctList [ 3 ] geth console result { acc t Id : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , isOrgAdmi n : true , orgId : \"ORG1\" , roleId : \"ADMIN\" , s tatus : 1 } To approve the assignment of a network admin role, use quorumPermission_approveAdminRole : geth console request quorumPermission . approveAdminRole ( \"ORG1\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , { from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" View the account\u2019s updated status in the account list: geth console request quorumPermission . acctList [ 4 ] geth console result { acc t Id : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , isOrgAdmi n : true , orgId : \"ORG1\" , roleId : \"ADMIN\" , s tatus : 2 } The account can now perform all activities allowable by a network admin account and can participate in the approval process for any actions at network level.","title":"Enhanced permissions"},{"location":"configure-and-manage/manage/enhanced-permissions/#using-enhanced-permissioning","text":"Managing the enhanced permissioning model can be broadly categorized into the following activities:","title":"Using enhanced permissioning"},{"location":"configure-and-manage/manage/enhanced-permissions/#setting-up-the-initial-network","text":"Please refer to the configuration instructions for detailed information. For an existing network running with an older version of GoQuorum: Upgrade GoQuorum to the latest version. Deploy the contracts. Execute the init method of PermissionsUpgradable.sol from the guardian account. Copy the permission-config.json to the data directory of each node. Bring geth up in --permissioned mode. For a new network using the latest version of GoQuorum: Bring up the initial set of nodes. Deploy the contracts. Execute the init method of PermissionsUpgradable.sol from the guardian account. Upgrade GoQuorum to the latest version. Copy the permission-config.json to the data directory of each node. Bring geth up in --permissioned mode. As part of network initialization: A network admin organization is created with the nwAdminOrg name specified in permission-config.json . All nodes which are part of static-nodes.json are assigned to this organization. A network admin role is created with the nwAdminRole name specified in the config file. All accounts given in the accounts array of the config file are assigned the network admin role. These accounts will have the ability to propose and approve new organizations into the network.","title":"Setting up the initial network"},{"location":"configure-and-manage/manage/enhanced-permissions/#example","text":"This example assumes that the network was started with the permission-config.json given in the configuration instructions , and that the network was brought up with the static-nodes.json file as the following: [ \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" , \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" , \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" , \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" ] View the organization list with the following command: geth console request quorumPermission . orgList geth console result [{ full OrgId : \"ADMINORG\" , level : 1 , orgId : \"ADMINORG\" , pare nt OrgId : \"\" , s tatus : 2 , subOrgLis t : null , ul t ima te Pare nt : \"ADMINORG\" }] View ADMINORG \u2018s details: geth console request quorumPermission . getOrgDetails ( \"ADMINORG\" ) geth console result { acc t Lis t : [{ acc t Id : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , isOrgAdmi n : true , orgId : \"ADMINORG\" , roleId : \"ADMIN\" , s tatus : 2 }, { acc t Id : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , isOrgAdmi n : true , orgId : \"ADMINORG\" , roleId : \"ADMIN\" , s tatus : 2 }], n odeLis t : [{ orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { orgId : \"ADMINORG\" , s tatus : 2 , url : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }], roleLis t : [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : true , orgId : \"ADMINORG\" , roleId : \"ADMIN\" }], subOrgLis t : null }","title":"Example"},{"location":"configure-and-manage/manage/enhanced-permissions/#proposing-a-new-organization-into-the-network","text":"Once the network is up, the network admin accounts can then propose a new organization into the network. Majority approval from the network admin accounts is required before an organization is approved. The APIs for proposing and approving an organization are documented in permission APIs .","title":"Proposing a new organization into the network"},{"location":"configure-and-manage/manage/enhanced-permissions/#example_1","text":"This example is to propose and approve an organization by name ORG1 . Propose to add ORG1 with the following command: geth console request quorumPermission . addOrg ( \"ORG1\" , \"enode://de9c2d5937e599930832cecc1df8cc90b50839bdf635c1a4e68e1dab2d001cd4a11c626e155078cc65958a72e2d72c1342a28909775edd99cc39470172cce0ac@127.0.0.1:21004?discport=0\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" Once the organization is proposed, it will be in Proposed state awaiting approval from other network admin accounts. View ORG1 \u2018s status: geth console request quorumPermission . orgList [ 1 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 1 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } The network admin accounts can then approve the proposed organizations with the following command, and once the majority approval is achieved, the organization status is updated to Approved : geth console request quorumPermission . approveOrg ( \"ORG1\" , \"enode://de9c2d5937e599930832cecc1df8cc90b50839bdf635c1a4e68e1dab2d001cd4a11c626e155078cc65958a72e2d72c1342a28909775edd99cc39470172cce0ac@127.0.0.1:21004?discport=0\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , { from : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" }) geth console result \"Action completed successfully\" See that ORG1 \u2018s status was updated in the organization list with the following command: geth console request quorumPermission . orgList [ 1 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 2 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } View the details of the new approved organization: geth console request quorumPermission . getOrgDetails ( \"ORG1\" ) geth console result { acc t Lis t : [{ acc t Id : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , isOrgAdmi n : true , orgId : \"ORG1\" , roleId : \"ORGADMIN\" , s tatus : 2 }], n odeLis t : [{ orgId : \"ORG1\" , s tatus : 2 , url : \"enode://de9c2d5937e599930832cecc1df8cc90b50839bdf635c1a4e68e1dab2d001cd4a11c626e155078cc65958a72e2d72c1342a28909775edd99cc39470172cce0ac@127.0.0.1:21004?discport=0\" }], roleLis t : [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : true , orgId : \"ORG1\" , roleId : \"ORGADMIN\" }], subOrgLis t : null } At this point: An organization admin role with name as given in orgAdminRole in permission-config.json has been created and linked to the ORG1 . The account 0x0638e1574728b6d862dd5d3a3e0942c3be47d996 has been linked to ORG1 and the organization admin role. This account acts as the organization admin account and can manage further roles, nodes, and accounts at the organization level. The node has been linked to the organization and its status has been updated as Approved . The new node belonging to the organization can now join the network. In case the network is running in Raft consensus mode, before the node joins the network, ensure that: The node has been added as a peer using raft.addPeer(<<enodeId>>) . You bring up geth for the new node using --raftjoinexisting with the peer ID as obtained in the previous step.","title":"Example"},{"location":"configure-and-manage/manage/enhanced-permissions/#managing-the-organization-level-permissions","text":"Once the organization is approved and the node of the organization has joined the network, the organization admin can: Create sub-organizations, add roles, and add additional nodes at organization level. Add accounts to the organization. Change roles of existing organization-level accounts. Use quorumPermission_addSubOrg to add a sub-organization at the ORG1 level.","title":"Managing the organization-level permissions"},{"location":"configure-and-manage/manage/enhanced-permissions/#example_2","text":"Add a sub-organization with the following command: geth console request quorumPermission . addSubOrg ( \"ORG1\" , \"SUB1\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" , { from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" Get the sub-organization\u2019s details: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ) geth console result { acc t Lis t : null , n odeLis t : [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }], roleLis t : null , subOrgLis t : null } The enode ID is not mandatory for adding a sub-organization. If the organization admin wants to add an admin account for the newly created sub-organization, the organization admin account must first create a role using quorumPermission_addNewRole with isAdminRole set to true , then assign this role to the account which belongs to the sub-organization. Once assigned, the account will act as organization admin at the sub-organization level. Add a new admin account for the sub-organization with the following command: geth console request quorumPermission . addNewRole ( \"ORG1.SUB1\" , \"SUBADMIN\" , 3 , false , true ,{ from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" View the organization admin account ID: geth console request eth . accounts [ 0 ] geth console result \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" The sub-organization admin role SUBADMIN can now be assigned to an account at SUB1 . Add the account as a SUBADMIN to SUB1 with the following command: geth console request quorumPermission . addAccountToOrg ( \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , \"ORG1.SUB1\" , \"SUBADMIN\" , { from : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" }) geth console result \"Action completed successfully\" View SUB1 \u2018s details: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ) geth console results { acc t Lis t : [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }], n odeLis t : [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }], roleLis t : [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : false , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" }], subOrgLis t : null } The account 0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0 is now the admin for SUB1 and can add roles, accounts, and nodes to the sub-organization. Add a new role TRANSACT to SUB1 with the following command: geth console request quorumPermission . addNewRole ( \"ORG1.SUB1\" , \"TRANSACT\" , 1 , false , true ,{ from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View SUB1 \u2018s role list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). roleList geth console result [{ access : 3 , ac t ive : true , isAdmi n : true , isVo ter : false , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" }, { access : 1 , ac t ive : true , isAdmi n : true , isVo ter : false , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" }] Note The organization admin account at the master organization level has the admin rights on all the children sub-organizations. However, the admin account at the sub-organization level has control only in its sub-organization. To add an account to an organization, use quorumPermission_addAccountToOrg : geth console request quorumPermission . addAccountToOrg ( \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , \"ORG1.SUB1\" , \"SUBADMIN\" , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 2 }] To suspend an account, use quorumPermission_updateAccountStatus with action set to 1: geth console request quorumPermission . updateAccountStatus ( \"ORG1.SUB1\" , \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , 1 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the account\u2019s updated status in the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 1 }] To revoke suspension of an account, use quorumPermission_updateAccountStatus with action set to 2: geth console request quorumPermission . updateAccountStatus ( \"ORG1.SUB1\" , \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , 2 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console resultt \"Action completed successfully\" View the account\u2019s updated status in the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 2 }] To exclude an account, use quorumPermission_updateAccountStatus with action set to 3: geth console request quorumPermission . updateAccountStatus ( \"ORG1.SUB1\" , \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , 3 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" Once excluded, no further activity is possible on the account. View the account\u2019s updated status in the organization\u2019s account list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). acctList geth console result [{ acc t Id : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"SUBADMIN\" , s tatus : 2 }, { acc t Id : \"0x283f3b8989ec20df621166973c93b56b0f4b5455\" , isOrgAdmi n : true , orgId : \"ORG1.SUB1\" , roleId : \"TRANSACT\" , s tatus : 5 }] To add nodes at the organization and sub-organization level, use quorumPermission_addNode : geth console request quorumPermission . addNode ( \"ORG1.SUB1\" , \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated node list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] To manage the status of the nodes, use quorumPermission_updateNodeStatus . To deactivate a node, call the method with action set to 1: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 3 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] To re-activate a node, use quorumPermission_updateNodeStatus with action set to 2: geth console request quorumPermission . updateNodeStatus ( \"ORG1.SUB1\" , \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" , 2 , { from : \"0x42ef6abedcb7ecd3e9c4816cd5f5a96df35bb9a0\" }) geth console result \"Action completed successfully\" View the node\u2019s updated status in the organization\u2019s node list: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] To exclude a node, use quorumPermission_updateNodeStatus with action set to 3: geth console request quorumPermission . getOrgDetails ( \"ORG1.SUB1\" ). nodeList geth console result [{ orgId : \"ORG1.SUB1\" , s tatus : 2 , url : \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0\" }, { orgId : \"ORG1.SUB1\" , s tatus : 4 , url : \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0\" }] Once excluded, a node can\u2019t re-join a network. Note In Raft consensus, when a node is deactivated, the peer ID is lost. Upon activation, the node needs to be added to the Raft cluster again using raft.addPeer and the node should be brought up with a new peer ID. An account can transact from any of the nodes within the same organization. No transaction is allowed from a deactivated node.","title":"Example"},{"location":"configure-and-manage/manage/enhanced-permissions/#suspending-an-organization-temporarily","text":"If you need to temporarily suspend all activities of an organization, use quorumPermission_updateOrgStatus with action set to `. This can be invoked only by network admin accounts and requires majority approval.","title":"Suspending an organization temporarily"},{"location":"configure-and-manage/manage/enhanced-permissions/#example_3","text":"Suspend ORG1 with the following command: geth console request quorumPermission . updateOrgStatus ( \"ORG1\" , 1 , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated status in the organization list: geth console request quorumPermission . orgList [ 2 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 3 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } Suspending an organization requires majority approval from other network admin accounts, using quorumPermission_approveOrgStatus . Once approved the organization status is marked as Suspended . geth console request quorumPermission . approveOrgStatus ( \"ORG1\" , 1 , { from : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated status in the organization list: geth console request quorumPermission . orgList [ 2 ] geth console result { full OrgId : \"ORG1\" , level : 1 , orgId : \"ORG1\" , pare nt OrgId : \"\" , s tatus : 4 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } When the organization is suspended, no transaction from any of the accounts linked to the organization or sub-organizations under it is allowed. However, the nodes linked to the organization are active and are syncing with the network.","title":"Example"},{"location":"configure-and-manage/manage/enhanced-permissions/#revoking-suspension-of-an-organization","text":"To revoke the suspension of an organization, use quorumPermission_updateOrgStatus with action set to 2.","title":"Revoking suspension of an organization"},{"location":"configure-and-manage/manage/enhanced-permissions/#example_4","text":"Revoke the suspension of ORG1 with the following command: geth console request quorumPermission . updateOrgStatus ( \"ORG1\" , 2 , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" Revoking an organization\u2019s suspension requires majority approval using quorumPermission_approveOrgStatus with action set to 2: geth console request quorumPermission . approveOrgStatus ( \"ORG1\" , 2 , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" View the organization\u2019s updated status in the organization list: geth console request quorumPermission . orgList [ 0 ] geth console result { full OrgId : \"ORG1.SUB1\" , level : 2 , orgId : \"SUB1\" , pare nt OrgId : \"ORG1\" , s tatus : 2 , subOrgLis t : null , ul t ima te Pare nt : \"ORG1\" } Once the revoke is approved, all accounts in the organization and sub-organizations under it are able to transact as per role level access.","title":"Example"},{"location":"configure-and-manage/manage/enhanced-permissions/#assigning-admin-privileges-at-organization-and-network-level","text":"At times, an account at the organization level may need be able to perform network admin activities. Also, there may be a need to change the admin account at organization level. Both of these activities can be performed by existing network admin accounts only, and will require majority approval from the network admin accounts.","title":"Assigning admin privileges at organization and network level"},{"location":"configure-and-manage/manage/enhanced-permissions/#example_5","text":"To assign a network admin or organization admin role to an account, use quorumPermission_assignAdminRole : geth console request quorumPermission . assignAdminRole ( \"ORG1\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , \"ADMIN\" , { from : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" }) geth console result \"Action completed successfully\" View the account\u2019s updated role in the account list: geth console request quorumPermission . acctList [ 3 ] geth console result { acc t Id : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , isOrgAdmi n : true , orgId : \"ORG1\" , roleId : \"ADMIN\" , s tatus : 1 } To approve the assignment of a network admin role, use quorumPermission_approveAdminRole : geth console request quorumPermission . approveAdminRole ( \"ORG1\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , { from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" View the account\u2019s updated status in the account list: geth console request quorumPermission . acctList [ 4 ] geth console result { acc t Id : \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" , isOrgAdmi n : true , orgId : \"ORG1\" , roleId : \"ADMIN\" , s tatus : 2 } The account can now perform all activities allowable by a network admin account and can participate in the approval process for any actions at network level.","title":"Example"},{"location":"configure-and-manage/manage/graphql/","text":"GoQuorum GraphQL \u00b6 Overview \u00b6 Ethereum has defined a GraphQL schema as part of EIP 1767 . To support GoQuorum private transaction data, a supplement schema and implementation has been added on top of the default. New supplement schema for GoQuorum \u00b6 # Transaction is an Ethereum transaction . type Transaction { ... # IsPrivate is an indicator of Quorum private transaction isPrivate : Boolean # PrivateInputData is the actual payload of Quorum private transaction privateInputData : Bytes } Example curl http://localhost:8547/graphql \\ -X POST -H \"Content-Type: application/json\" \\ -d '{ \"query\": \"{ transaction(hash:\\\"0x58462fa0b6074a8feb5d9b8cd0e6bb7ef4d1528471396070d9ae617c5dee40a8\\\") { isPrivate inputData privateInputData } }\" }' { \"data\" : { \"transaction\" : { \"isPrivate\" :true, \"inputData\" : \"0xe9394a3620f2ef52a2001b08a79363dd467de866ab825877234ee66af5cac620877fdb88633114dd63c3c7a8048fc623e25eaa5914f5dc8004738dc0a52b62a3\" , \"privateInputData\" : \"0x608060405234801561001057600080fd5b506040516020806101a18339810180604052602081101561003057600080fd5b81019080805190602001909291905050508060008190555050610149806100586000396000f3fe608060405234801561001057600080fd5b506004361061005e576000357c0100000000000000000000000000000000000000000000000000000000900480632a1afcd91461006357806360fe47b1146100815780636d4ce63c146100af575b600080fd5b61006b6100cd565b6040518082815260200191505060405180910390f35b6100ad6004803603602081101561009757600080fd5b81019080803590602001909291905050506100d3565b005b6100b7610114565b6040518082815260200191505060405180910390f35b60005481565b806000819055507fefe5cb8d23d632b5d2cdd9f0a151c4b1a84ccb7afa1c57331009aa922d5e4f36816040518082815260200191505060405180910390a150565b6000805490509056fea165627a7a7230582061f6956b053dbf99873b363ab3ba7bca70853ba5efbaff898cd840d71c54fc1d0029000000000000000000000000000000000000000000000000000000000000002a\" }}}","title":"GraphQL"},{"location":"configure-and-manage/manage/graphql/#goquorum-graphql","text":"","title":"GoQuorum GraphQL"},{"location":"configure-and-manage/manage/graphql/#overview","text":"Ethereum has defined a GraphQL schema as part of EIP 1767 . To support GoQuorum private transaction data, a supplement schema and implementation has been added on top of the default.","title":"Overview"},{"location":"configure-and-manage/manage/graphql/#new-supplement-schema-for-goquorum","text":"# Transaction is an Ethereum transaction . type Transaction { ... # IsPrivate is an indicator of Quorum private transaction isPrivate : Boolean # PrivateInputData is the actual payload of Quorum private transaction privateInputData : Bytes } Example curl http://localhost:8547/graphql \\ -X POST -H \"Content-Type: application/json\" \\ -d '{ \"query\": \"{ transaction(hash:\\\"0x58462fa0b6074a8feb5d9b8cd0e6bb7ef4d1528471396070d9ae617c5dee40a8\\\") { isPrivate inputData privateInputData } }\" }' { \"data\" : { \"transaction\" : { \"isPrivate\" :true, \"inputData\" : \"0xe9394a3620f2ef52a2001b08a79363dd467de866ab825877234ee66af5cac620877fdb88633114dd63c3c7a8048fc623e25eaa5914f5dc8004738dc0a52b62a3\" , \"privateInputData\" : \"0x608060405234801561001057600080fd5b506040516020806101a18339810180604052602081101561003057600080fd5b81019080805190602001909291905050508060008190555050610149806100586000396000f3fe608060405234801561001057600080fd5b506004361061005e576000357c0100000000000000000000000000000000000000000000000000000000900480632a1afcd91461006357806360fe47b1146100815780636d4ce63c146100af575b600080fd5b61006b6100cd565b6040518082815260200191505060405180910390f35b6100ad6004803603602081101561009757600080fd5b81019080803590602001909291905050506100d3565b005b6100b7610114565b6040518082815260200191505060405180910390f35b60005481565b806000819055507fefe5cb8d23d632b5d2cdd9f0a151c4b1a84ccb7afa1c57331009aa922d5e4f36816040518082815260200191505060405180910390a150565b6000805490509056fea165627a7a7230582061f6956b053dbf99873b363ab3ba7bca70853ba5efbaff898cd840d71c54fc1d0029000000000000000000000000000000000000000000000000000000000000002a\" }}}","title":"New supplement schema for GoQuorum"},{"location":"configure-and-manage/manage/import-export/","text":"Backup and restore GoQuorum nodes \u00b6 GoQuorum supports exporting and importing chain data with built-in tooling. This is a node backup mechanism adapted for the specific needs of GoQuorum such as private transactions, permissioning, and its supported consensus algorithms. Note GoQuorum chain data import and export must run after geth process is stopped. Node backup (export) \u00b6 Backup functionality mimics the original geth export command. GoQuorum export accepts three arguments: Export file name First block Last block First and last block are optional, but both arguments must be provided if one is. geth export < export file name> --datadir <geth data dir> Node restore (import) \u00b6 Restore functionality mimics original geth import command but requires a transaction manager environment variable. GoQuorum import must run on a new node with an initialized --datadir after geth init has been executed. Restore supports an arbitrary number of import files (at least one). Warning If private transactions are used in the chain data, the Private Transaction Manager (PTM) process for the original exported node must be running on the PTM ipc endpoint during import. Otherwise, nil pointer exceptions are raised. PRIVATE_CONFIG = <PTM ipc endpoint> geth import <import file names...> --datadir <geth data dir> Special consensus considerations \u00b6 IBFT and QBFT \u00b6 IBFT and QBFT block data contain sealer information in the header. To restore a copy of exported chain data, the new node must be initialized using an IBFT/QBFT genesis file with the same validator set encoded in extraData field as in the original exported node\u2019s genesis file. Raft \u00b6 Raft backups do not account for current Raft state. An exported chain data from a Raft cluster can only be used by new nodes being added to that same cluster.","title":"Backup and restore"},{"location":"configure-and-manage/manage/import-export/#backup-and-restore-goquorum-nodes","text":"GoQuorum supports exporting and importing chain data with built-in tooling. This is a node backup mechanism adapted for the specific needs of GoQuorum such as private transactions, permissioning, and its supported consensus algorithms. Note GoQuorum chain data import and export must run after geth process is stopped.","title":"Backup and restore GoQuorum nodes"},{"location":"configure-and-manage/manage/import-export/#node-backup-export","text":"Backup functionality mimics the original geth export command. GoQuorum export accepts three arguments: Export file name First block Last block First and last block are optional, but both arguments must be provided if one is. geth export < export file name> --datadir <geth data dir>","title":"Node backup (export)"},{"location":"configure-and-manage/manage/import-export/#node-restore-import","text":"Restore functionality mimics original geth import command but requires a transaction manager environment variable. GoQuorum import must run on a new node with an initialized --datadir after geth init has been executed. Restore supports an arbitrary number of import files (at least one). Warning If private transactions are used in the chain data, the Private Transaction Manager (PTM) process for the original exported node must be running on the PTM ipc endpoint during import. Otherwise, nil pointer exceptions are raised. PRIVATE_CONFIG = <PTM ipc endpoint> geth import <import file names...> --datadir <geth data dir>","title":"Node restore (import)"},{"location":"configure-and-manage/manage/import-export/#special-consensus-considerations","text":"","title":"Special consensus considerations"},{"location":"configure-and-manage/manage/import-export/#ibft-and-qbft","text":"IBFT and QBFT block data contain sealer information in the header. To restore a copy of exported chain data, the new node must be initialized using an IBFT/QBFT genesis file with the same validator set encoded in extraData field as in the original exported node\u2019s genesis file.","title":"IBFT and QBFT"},{"location":"configure-and-manage/manage/import-export/#raft","text":"Raft backups do not account for current Raft state. An exported chain data from a Raft cluster can only be used by new nodes being added to that same cluster.","title":"Raft"},{"location":"configure-and-manage/manage/json-rpc-api-security/","text":"Securing JSON-RPC \u00b6 Overview \u00b6 JSON-RPC servers are secured using a security plugin interface . The official implementation enables the GoQuorum client to protect JSON-RPC APIs using the following features: Native Transport Layer Security \u00b6 Native Transport Layer Security (TLS) introduces an encryption layer to the JSON-RPC request/response communication channel for both HTTP and WebSocket listeners. By using a simple configuration flag, this feature allows the automatic generation of a self-signed certificates for testing environments, or a smooth integration with certificate authorities for enterprise deployment. Enterprise authorization protocol integration \u00b6 Enterprise authorization protocol integration introduces an access control layer that authorizes each JSON-RPC invocation to an atomic module function level (for example personal_OpenWallet ) using the industry standard OAuth 2.0 protocol and JSON Web Token (JWT) method. This feature enables GoQuorum access control and dapp management. Configuration \u00b6 Refer to the plugin implementation for more details and find examples on how to configure the plugin to work with different OAuth2 Authorization servers . Client usage \u00b6 Before invoking protected JSON-RPC APIs, the client must request an access token by authenticating with the authorization server. An access token can be opaque or a JWT. It\u2019s the client\u2019s responsibility to maintain this token\u2019s validity during its lifetime. When invoking a JSON-RPC API, the client must send the token in the Authorization request header field with the Bearer authentication scheme. All major HTTP client libraries have extensions to allow such customization. Examples \u00b6 The following are examples on how to interact with protected JSON-RPC APIs. web3 \u00b6 Use Web3.js JavaScript library: let Web3 = require ( 'web3' ); let HttpHeaderProvider = require ( 'httpheaderprovider' ); // obtain the preauthenticated bearer token // by authenticating with the authorization server let token = ...; let headers = { \"Authorization\" : `Bearer ${ token } ` }; let provider = new HttpHeaderProvider ( 'https://...' , headers ); web3 . setProvider ( provider ); web3j-quorum \u00b6 Use the web3j-quorum Java library: HttpService service = new HttpService ( \"<JSON-RPC HTTPS endpoint>\" ); service . addHeader ( \"Authorization\" , \"bearer $accessToken\" ); quorum = Quorum . build ( service ); curl \u00b6 Get the pre-authenticated bearer token by authenticating with the authorization server: export TOKEN = \"Bearer ...\" curl -X POST -H \"Content-type: application/json\" -H \"Authorization: $TOKEN \" \\ https://... \\ --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1}' geth attach \u00b6 Use the following command line options to allow a secured GoQuorum node connection: --rpcclitoken --rpcclitls.insecureskipverify --rpcclitls.cert --rpcclitls.cacert --rpcclitls.ciphersuites For example, connect to the node using --rpcclitls.insecureskipverify to ignore the server\u2019s certificate validation: HTTP geth attach https://localhost:22000 --rpcclitls.insecureskipverify WebSocket geth attach wss://localhost:23000 --rpcclitls.insecureskipverify ethclient \u00b6 ethclient provides a Go client for the Ethereum RPC API. It also supports GoQuorum-specific APIs and protected APIs. HTTP For the HTTP endpoint, the preauthenticated token is populated in the Authorization HTTP request header for each call. The token value is obtained from the rpc.HttpCredentialsProviderFunc implementation, which is configured after rpc.Client is instantiated. // obtain the preauthenticated bearer token // by authenticating with the authorization server token := ... // instantiate rpc.Client c , err := rpc . Dial ( \"http://...\" ) if err != nil { // handle err } var f rpc . HttpCredentialsProviderFunc = func ( ctx context . Context ) ( string , error ) { // optionally to refresh the token if necessary return \"Bearer \" + token , nil } // configure rpc.Client with preauthenticated token authenticatedClient , err := c . WithHTTPCredentials ( f ) if err != nil { // handle err } // use authenticatedClient as usual To customize TLS client configuration: // instantiate a http.Client with custom TLS client config myHttpClient := ... // instantiate rpc.Client c , err := rpc . DialHTTPWithClient ( \"https://...\" , myHttpClient ) WebSocket For the WS endpoint, the preauthenticated token is populated in the Authorization HTTP request header only once during the handshake. The token value is obtained from the rpc.HttpCredentialsProviderFunc implementation via context.Context when dialing. // obtain the preauthenticated bearer token // by authenticating with the authorization server token := ... var f rpc . HttpCredentialsProviderFunc = func ( ctx context . Context ) ( string , error ) { // optionally to refresh the token if necessary return \"Bearer \" + token , nil } ctx := context . WithValue ( context . Background (), rpc . CtxCredentialsProvider , f ) authenticatedClient , err := rpc . DialContext ( ctx , \" ws : //...) if err != nil { // handle err } // use authenticatedClient as usual To customize the TLS client configuration, use rpc.DialWebsocketWithCustomTLS() instead of rpc.DialContext() : // create a tls.Config tlsConfig := & tls . Config { ... } c , err := rpc . DialWebsocketWithCustomTLS ( ctx , \"wss://...\" , \"\" , tlsConfig )","title":"JSON-RPC API security"},{"location":"configure-and-manage/manage/json-rpc-api-security/#securing-json-rpc","text":"","title":"Securing JSON-RPC"},{"location":"configure-and-manage/manage/json-rpc-api-security/#overview","text":"JSON-RPC servers are secured using a security plugin interface . The official implementation enables the GoQuorum client to protect JSON-RPC APIs using the following features:","title":"Overview"},{"location":"configure-and-manage/manage/json-rpc-api-security/#native-transport-layer-security","text":"Native Transport Layer Security (TLS) introduces an encryption layer to the JSON-RPC request/response communication channel for both HTTP and WebSocket listeners. By using a simple configuration flag, this feature allows the automatic generation of a self-signed certificates for testing environments, or a smooth integration with certificate authorities for enterprise deployment.","title":"Native Transport Layer Security"},{"location":"configure-and-manage/manage/json-rpc-api-security/#enterprise-authorization-protocol-integration","text":"Enterprise authorization protocol integration introduces an access control layer that authorizes each JSON-RPC invocation to an atomic module function level (for example personal_OpenWallet ) using the industry standard OAuth 2.0 protocol and JSON Web Token (JWT) method. This feature enables GoQuorum access control and dapp management.","title":"Enterprise authorization protocol integration"},{"location":"configure-and-manage/manage/json-rpc-api-security/#configuration","text":"Refer to the plugin implementation for more details and find examples on how to configure the plugin to work with different OAuth2 Authorization servers .","title":"Configuration"},{"location":"configure-and-manage/manage/json-rpc-api-security/#client-usage","text":"Before invoking protected JSON-RPC APIs, the client must request an access token by authenticating with the authorization server. An access token can be opaque or a JWT. It\u2019s the client\u2019s responsibility to maintain this token\u2019s validity during its lifetime. When invoking a JSON-RPC API, the client must send the token in the Authorization request header field with the Bearer authentication scheme. All major HTTP client libraries have extensions to allow such customization.","title":"Client usage"},{"location":"configure-and-manage/manage/json-rpc-api-security/#examples","text":"The following are examples on how to interact with protected JSON-RPC APIs.","title":"Examples"},{"location":"configure-and-manage/manage/json-rpc-api-security/#web3","text":"Use Web3.js JavaScript library: let Web3 = require ( 'web3' ); let HttpHeaderProvider = require ( 'httpheaderprovider' ); // obtain the preauthenticated bearer token // by authenticating with the authorization server let token = ...; let headers = { \"Authorization\" : `Bearer ${ token } ` }; let provider = new HttpHeaderProvider ( 'https://...' , headers ); web3 . setProvider ( provider );","title":"web3"},{"location":"configure-and-manage/manage/json-rpc-api-security/#web3j-quorum","text":"Use the web3j-quorum Java library: HttpService service = new HttpService ( \"<JSON-RPC HTTPS endpoint>\" ); service . addHeader ( \"Authorization\" , \"bearer $accessToken\" ); quorum = Quorum . build ( service );","title":"web3j-quorum"},{"location":"configure-and-manage/manage/json-rpc-api-security/#curl","text":"Get the pre-authenticated bearer token by authenticating with the authorization server: export TOKEN = \"Bearer ...\" curl -X POST -H \"Content-type: application/json\" -H \"Authorization: $TOKEN \" \\ https://... \\ --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1}'","title":"curl"},{"location":"configure-and-manage/manage/json-rpc-api-security/#geth-attach","text":"Use the following command line options to allow a secured GoQuorum node connection: --rpcclitoken --rpcclitls.insecureskipverify --rpcclitls.cert --rpcclitls.cacert --rpcclitls.ciphersuites For example, connect to the node using --rpcclitls.insecureskipverify to ignore the server\u2019s certificate validation: HTTP geth attach https://localhost:22000 --rpcclitls.insecureskipverify WebSocket geth attach wss://localhost:23000 --rpcclitls.insecureskipverify","title":"geth attach"},{"location":"configure-and-manage/manage/json-rpc-api-security/#ethclient","text":"ethclient provides a Go client for the Ethereum RPC API. It also supports GoQuorum-specific APIs and protected APIs. HTTP For the HTTP endpoint, the preauthenticated token is populated in the Authorization HTTP request header for each call. The token value is obtained from the rpc.HttpCredentialsProviderFunc implementation, which is configured after rpc.Client is instantiated. // obtain the preauthenticated bearer token // by authenticating with the authorization server token := ... // instantiate rpc.Client c , err := rpc . Dial ( \"http://...\" ) if err != nil { // handle err } var f rpc . HttpCredentialsProviderFunc = func ( ctx context . Context ) ( string , error ) { // optionally to refresh the token if necessary return \"Bearer \" + token , nil } // configure rpc.Client with preauthenticated token authenticatedClient , err := c . WithHTTPCredentials ( f ) if err != nil { // handle err } // use authenticatedClient as usual To customize TLS client configuration: // instantiate a http.Client with custom TLS client config myHttpClient := ... // instantiate rpc.Client c , err := rpc . DialHTTPWithClient ( \"https://...\" , myHttpClient ) WebSocket For the WS endpoint, the preauthenticated token is populated in the Authorization HTTP request header only once during the handshake. The token value is obtained from the rpc.HttpCredentialsProviderFunc implementation via context.Context when dialing. // obtain the preauthenticated bearer token // by authenticating with the authorization server token := ... var f rpc . HttpCredentialsProviderFunc = func ( ctx context . Context ) ( string , error ) { // optionally to refresh the token if necessary return \"Bearer \" + token , nil } ctx := context . WithValue ( context . Background (), rpc . CtxCredentialsProvider , f ) authenticatedClient , err := rpc . DialContext ( ctx , \" ws : //...) if err != nil { // handle err } // use authenticatedClient as usual To customize the TLS client configuration, use rpc.DialWebsocketWithCustomTLS() instead of rpc.DialContext() : // create a tls.Config tlsConfig := & tls . Config { ... } c , err := rpc . DialWebsocketWithCustomTLS ( ctx , \"wss://...\" , \"\" , tlsConfig )","title":"ethclient"},{"location":"configure-and-manage/manage/node-network-migration/","text":"Migrate nodes to a new IP network \u00b6 Use the following instructions to update a node\u2019s network configuration while ensuring the consensus protocol continues to work as expected. These instructions apply when using a static configuration through the static-nodes.json file. The following instructions use a three-node network, A, B, and C, as an example, where Node A is being migrated. You can apply these instructions to any number of migrated nodes on any network with any number of nodes. Important Before migrating a node to a new network, create a backup of each node\u2019s data directory . Prerequisites \u00b6 GoQuorum installed A running Raft network or IBFT network Raft \u00b6 Peers with same networking configuration \u00b6 In this scenario, the migrated node has a new network configuration, but its peers keep the same IP addresses and ports. For example: Node A\u2019s public IP address and port are changed, and Nodes B and C keep the same public IP addresses and ports. Node A migrates from one private sub-network 10.1.X.X to another sub-network 10.2.X.X , but can still connect to Nodes B and C using the same IP addresses as before, by routing across the sub-networks. Steps \u00b6 Stop Node A. On Node B or C, obtain Node A\u2019s Raft ID (GoQuorum Raft node ID in the network): geth console request raft.cluster JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : [{ \"raftId\" : 1 , \"nodeId\" : \"<enodeId>\" , ... }, ...] } In this example Node A\u2019s Raft ID is 1. On Node B or C, remove Node A from the network using its Raft ID: raft.removePeer ( <RAFT-ID> ) Update the network configuration in Node A\u2019s static-nodes.json file. Note Even if this file isn\u2019t specified with --raftjoinexisting , it should be updated to keep in sync with the current cluster configuration. Add Node A back to the Raft network with its new network configuration. The nodes can now connect with their peers, and raft.cluster shows the updated information and network configuration. Peers need a new networking configuration \u00b6 In this scenario, the migrated node must update the IP addresses and ports of its peers. For example, Nodes A, B, and C are in the same private sub-network, and Node A migrates to another sub-network, or to the internet. NAT is used to translate the IP addresses from the public to private sub-network and vice versa, requiring the nodes to use their peers\u2019 public IPs. This requires updating the configuration of Node A to use the public IP addresses of Nodes B and C, and updating the configurations of Nodes B and C to use the public IP address of Node A. Steps \u00b6 Stop all nodes. Clean the cached Raft data. In the data folder of each node, run: rm quorum-raft-state raft-* This forces Raft to refresh the cluster state based on the latest information in the static-nodes.json without losing any of the blockchain data. Migrate Node A\u2019s data to the new location. Update the network configuration in the static-nodes.json file of each node with its peers\u2019 accessible IP addresses and ports. Start all nodes. The nodes can now connect with their peers, and raft.cluster shows the updated information and network configuration. IBFT and QBFT \u00b6 Stop Node A. Update the network configuration in Node A\u2019s static-nodes.json file with its peers\u2019 accessible IP addresses and ports. Start Node A. The nodes can now connect with their peers, and admin.peers returns the current connections between the nodes.","title":"Migrate network nodes"},{"location":"configure-and-manage/manage/node-network-migration/#migrate-nodes-to-a-new-ip-network","text":"Use the following instructions to update a node\u2019s network configuration while ensuring the consensus protocol continues to work as expected. These instructions apply when using a static configuration through the static-nodes.json file. The following instructions use a three-node network, A, B, and C, as an example, where Node A is being migrated. You can apply these instructions to any number of migrated nodes on any network with any number of nodes. Important Before migrating a node to a new network, create a backup of each node\u2019s data directory .","title":"Migrate nodes to a new IP network"},{"location":"configure-and-manage/manage/node-network-migration/#prerequisites","text":"GoQuorum installed A running Raft network or IBFT network","title":"Prerequisites"},{"location":"configure-and-manage/manage/node-network-migration/#raft","text":"","title":"Raft"},{"location":"configure-and-manage/manage/node-network-migration/#peers-with-same-networking-configuration","text":"In this scenario, the migrated node has a new network configuration, but its peers keep the same IP addresses and ports. For example: Node A\u2019s public IP address and port are changed, and Nodes B and C keep the same public IP addresses and ports. Node A migrates from one private sub-network 10.1.X.X to another sub-network 10.2.X.X , but can still connect to Nodes B and C using the same IP addresses as before, by routing across the sub-networks.","title":"Peers with same networking configuration"},{"location":"configure-and-manage/manage/node-network-migration/#steps","text":"Stop Node A. On Node B or C, obtain Node A\u2019s Raft ID (GoQuorum Raft node ID in the network): geth console request raft.cluster JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : [{ \"raftId\" : 1 , \"nodeId\" : \"<enodeId>\" , ... }, ...] } In this example Node A\u2019s Raft ID is 1. On Node B or C, remove Node A from the network using its Raft ID: raft.removePeer ( <RAFT-ID> ) Update the network configuration in Node A\u2019s static-nodes.json file. Note Even if this file isn\u2019t specified with --raftjoinexisting , it should be updated to keep in sync with the current cluster configuration. Add Node A back to the Raft network with its new network configuration. The nodes can now connect with their peers, and raft.cluster shows the updated information and network configuration.","title":"Steps"},{"location":"configure-and-manage/manage/node-network-migration/#peers-need-a-new-networking-configuration","text":"In this scenario, the migrated node must update the IP addresses and ports of its peers. For example, Nodes A, B, and C are in the same private sub-network, and Node A migrates to another sub-network, or to the internet. NAT is used to translate the IP addresses from the public to private sub-network and vice versa, requiring the nodes to use their peers\u2019 public IPs. This requires updating the configuration of Node A to use the public IP addresses of Nodes B and C, and updating the configurations of Nodes B and C to use the public IP address of Node A.","title":"Peers need a new networking configuration"},{"location":"configure-and-manage/manage/node-network-migration/#steps_1","text":"Stop all nodes. Clean the cached Raft data. In the data folder of each node, run: rm quorum-raft-state raft-* This forces Raft to refresh the cluster state based on the latest information in the static-nodes.json without losing any of the blockchain data. Migrate Node A\u2019s data to the new location. Update the network configuration in the static-nodes.json file of each node with its peers\u2019 accessible IP addresses and ports. Start all nodes. The nodes can now connect with their peers, and raft.cluster shows the updated information and network configuration.","title":"Steps"},{"location":"configure-and-manage/manage/node-network-migration/#ibft-and-qbft","text":"Stop Node A. Update the network configuration in Node A\u2019s static-nodes.json file with its peers\u2019 accessible IP addresses and ports. Start Node A. The nodes can now connect with their peers, and admin.peers returns the current connections between the nodes.","title":"IBFT and QBFT"},{"location":"configure-and-manage/manage/qlight-node/","text":"Using a GoQuorum qlight node \u00b6 A qlight client node requires a full node configured to act as a qlight server. The server node is usually set up to support multiple private states (MPS), with the qlight client set up to use a private state identifier (PSI) which is managed by the server node. Note A server node is normally be set up as a multi-tenant node with Multiple Private States (MPS). However this is not essential, for example when setting up a qlight client for the purpose of offloading processing from a full node. Configure qlight client \u00b6 Configure the qlight client using the following command line options: --qlight.client : This marks the node as a qlight client. --qlight.client.psi : This specifies the PSI which this client will support (The default is private ). --qlight.client.serverNode : The Node ID of the server node. --qlight.client.serverNodeRPC : The RPC URL of the server node. If the server node has the RPC API secured using TLS, then the qlight client requires the following: --qlight.client.rpc.tls : Use TLS when forwarding RPC API calls. --qlight.client.rpc.tls.insecureskipverify : Skip TLS verification. --qlight.client.rpc.tls.cacert : The qlight client certificate authority. --qlight.client.rpc.tls.cert : The qlight client certificate. --qlight.client.rpc.tls.key : The qlight client certificate private key. If the qlight client node is halted, on restart it resyncs with any blocks that were missed when it was not running. Configure server node \u00b6 Configure the qlight server using the following command line options: --qlight.server : This marks the node as a qlight server. --qlight.server.p2p.port : The RPC listening port. --qlight.server.p2p.maxpeers : The maximum number of qlight clients that are supported. Network IP restriction \u00b6 This restricts communication to specified IP networks (CIDR masks). Specify the network mask on the qlight server using --qlight.server.p2p.netrestrict . File based permissioning \u00b6 File based permissioning allows qlight clients to be checked against a permissioned list and a disallowed list. Enable file based permissioning on the server node using --qlight.server.p2p.permissioning . The default files are permissioned-nodes.json and disallowed-nodes.json . However, you can specify a file prefix using --qlight.server.p2p.permissioning.prefix , in which case the filename is: the prefix, followed by a hyphen, followed by the default file name. Using the enterprise authorization protocol integration \u00b6 This leverages the security model described under JSON-RPC security to only allow authenticated clients to connect to the server. When using JSON-RPC security you must provide an access token to communicate to the qlight server. Enable auth tokens in the qlight client using --qlight.client.token.enabled . Once enabled, specify an initial value using --qlight.client.token.value . Specify a refresh mechanism for the token using --qlight.client.token.management . The valid values are: none - the token is not refreshed (this mechanism is for development/testing purposes only). external - the refreshed token must be updated in the running qlight client process by invoking the qlight.setCurrentToken RPC API. client-security-plugin (default) - the client security plugin is used to periodically refresh the access token. Please see the client-security-plugin documentation for further details. Native transport layer security (TLS) for P2P communication \u00b6 You can add an encryption layer on the qlight client-server communication. Configure the encryption layer using the following options: --qlight.tls : Enable TLS on the P2P connection. --qlight.tls.cert : The certificate file to use. --qlight.tls.key : The key file to use. --qlight.tls.cacerts : The certificate authorities file to use for validating the connection (client configuration parameter). --qlight.tls.clientauth : The way the client is authenticated. Possible values: 0=NoClientCert(default) 1=RequestClientCert 2=RequireAnyClientCert 3=VerifyClientCertIfGiven 4=RequireAndVerifyClientCert (default: 0). --qlight.tls.ciphersuites : The cipher suites to use for the connection.","title":"GoQuorum qlight client"},{"location":"configure-and-manage/manage/qlight-node/#using-a-goquorum-qlight-node","text":"A qlight client node requires a full node configured to act as a qlight server. The server node is usually set up to support multiple private states (MPS), with the qlight client set up to use a private state identifier (PSI) which is managed by the server node. Note A server node is normally be set up as a multi-tenant node with Multiple Private States (MPS). However this is not essential, for example when setting up a qlight client for the purpose of offloading processing from a full node.","title":"Using a GoQuorum qlight node"},{"location":"configure-and-manage/manage/qlight-node/#configure-qlight-client","text":"Configure the qlight client using the following command line options: --qlight.client : This marks the node as a qlight client. --qlight.client.psi : This specifies the PSI which this client will support (The default is private ). --qlight.client.serverNode : The Node ID of the server node. --qlight.client.serverNodeRPC : The RPC URL of the server node. If the server node has the RPC API secured using TLS, then the qlight client requires the following: --qlight.client.rpc.tls : Use TLS when forwarding RPC API calls. --qlight.client.rpc.tls.insecureskipverify : Skip TLS verification. --qlight.client.rpc.tls.cacert : The qlight client certificate authority. --qlight.client.rpc.tls.cert : The qlight client certificate. --qlight.client.rpc.tls.key : The qlight client certificate private key. If the qlight client node is halted, on restart it resyncs with any blocks that were missed when it was not running.","title":"Configure qlight client"},{"location":"configure-and-manage/manage/qlight-node/#configure-server-node","text":"Configure the qlight server using the following command line options: --qlight.server : This marks the node as a qlight server. --qlight.server.p2p.port : The RPC listening port. --qlight.server.p2p.maxpeers : The maximum number of qlight clients that are supported.","title":"Configure server node"},{"location":"configure-and-manage/manage/qlight-node/#network-ip-restriction","text":"This restricts communication to specified IP networks (CIDR masks). Specify the network mask on the qlight server using --qlight.server.p2p.netrestrict .","title":"Network IP restriction"},{"location":"configure-and-manage/manage/qlight-node/#file-based-permissioning","text":"File based permissioning allows qlight clients to be checked against a permissioned list and a disallowed list. Enable file based permissioning on the server node using --qlight.server.p2p.permissioning . The default files are permissioned-nodes.json and disallowed-nodes.json . However, you can specify a file prefix using --qlight.server.p2p.permissioning.prefix , in which case the filename is: the prefix, followed by a hyphen, followed by the default file name.","title":"File based permissioning"},{"location":"configure-and-manage/manage/qlight-node/#using-the-enterprise-authorization-protocol-integration","text":"This leverages the security model described under JSON-RPC security to only allow authenticated clients to connect to the server. When using JSON-RPC security you must provide an access token to communicate to the qlight server. Enable auth tokens in the qlight client using --qlight.client.token.enabled . Once enabled, specify an initial value using --qlight.client.token.value . Specify a refresh mechanism for the token using --qlight.client.token.management . The valid values are: none - the token is not refreshed (this mechanism is for development/testing purposes only). external - the refreshed token must be updated in the running qlight client process by invoking the qlight.setCurrentToken RPC API. client-security-plugin (default) - the client security plugin is used to periodically refresh the access token. Please see the client-security-plugin documentation for further details.","title":"Using the enterprise authorization protocol integration"},{"location":"configure-and-manage/manage/qlight-node/#native-transport-layer-security-tls-for-p2p-communication","text":"You can add an encryption layer on the qlight client-server communication. Configure the encryption layer using the following options: --qlight.tls : Enable TLS on the P2P connection. --qlight.tls.cert : The certificate file to use. --qlight.tls.key : The key file to use. --qlight.tls.cacerts : The certificate authorities file to use for validating the connection (client configuration parameter). --qlight.tls.clientauth : The way the client is authenticated. Possible values: 0=NoClientCert(default) 1=RequestClientCert 2=RequireAnyClientCert 3=VerifyClientCertIfGiven 4=RequireAndVerifyClientCert (default: 0). --qlight.tls.ciphersuites : The cipher suites to use for the connection.","title":"Native transport layer security (TLS) for P2P communication"},{"location":"configure-and-manage/manage/revert-reason/","text":"Revert reason \u00b6 In smart contracts, the revert operation triggers an exception to flag an error and revert the current call. The EVM passes back to the client an optional string message containing information about the error. Example pragma solidity >=0.5.0 <0.7.0; contract VendingMachine { function buy(uint amount) public payable { if (amount > msg.value / 2 ether) revert(\"Not enough Ether provided\"); // Alternative way to do it: require( amount <= msg.value / 2 ether, \"Not enough Ether provided.\" ); // Perform the purchase. } } Enabling revert reason \u00b6 Restart your GoQuorum node with the --revertreason command line option enabled. Any subsequent reverted transactions store the revert reason locally. Where is the revert reason included \u00b6 With revert reason enabled, the transaction receipt returned by eth_getTransactionReceipt includes the revert reason as an ABI-encoded string. Example { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"blockHash\" : \"0xe7212a92cfb9b06addc80dec2a0dfae9ea94fd344efeb157c41e12994fcad60a\" , \"blockNumber\" : \"0x50\" , \"contractAddress\" : null , \"cumulativeGasUsed\" : \"0x5208\" , \"from\" : \"0x627306090abab3a6e1400e9345bc60c78a8bef57\" , \"gasUsed\" : \"0x5208\" , \"logs\" : [], \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"status\" : \"0x1\" , \"to\" : \"0xf17f52151ebef6c7334fad080c5704d77216b732\" , \"transactionHash\" : \"0xc00e97af59c6f88de163306935f7682af1a34c67245e414537d02e422815efc3\" , \"transactionIndex\" : \"0x0\" , \"revertReason\" : \"0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4e6f7420656e6f7567682045746865722070726f76696465642e000000000000\" } } Revert reason format \u00b6 As described in the Solidity documentation , the revert reason is an ABI-encoded string consisting of: 0x08c379a0 // Function selector for Error ( string ) 0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset 0x000000000000000000000000000000000000000000000000000000000000001a // String length 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data Example of revert reason string for \"Not enough Ether provided.\" \"0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4e6f7420656e6f7567682045746865722070726f76696465642e000000000000\"","title":"Include revert reason"},{"location":"configure-and-manage/manage/revert-reason/#revert-reason","text":"In smart contracts, the revert operation triggers an exception to flag an error and revert the current call. The EVM passes back to the client an optional string message containing information about the error. Example pragma solidity >=0.5.0 <0.7.0; contract VendingMachine { function buy(uint amount) public payable { if (amount > msg.value / 2 ether) revert(\"Not enough Ether provided\"); // Alternative way to do it: require( amount <= msg.value / 2 ether, \"Not enough Ether provided.\" ); // Perform the purchase. } }","title":"Revert reason"},{"location":"configure-and-manage/manage/revert-reason/#enabling-revert-reason","text":"Restart your GoQuorum node with the --revertreason command line option enabled. Any subsequent reverted transactions store the revert reason locally.","title":"Enabling revert reason"},{"location":"configure-and-manage/manage/revert-reason/#where-is-the-revert-reason-included","text":"With revert reason enabled, the transaction receipt returned by eth_getTransactionReceipt includes the revert reason as an ABI-encoded string. Example { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"blockHash\" : \"0xe7212a92cfb9b06addc80dec2a0dfae9ea94fd344efeb157c41e12994fcad60a\" , \"blockNumber\" : \"0x50\" , \"contractAddress\" : null , \"cumulativeGasUsed\" : \"0x5208\" , \"from\" : \"0x627306090abab3a6e1400e9345bc60c78a8bef57\" , \"gasUsed\" : \"0x5208\" , \"logs\" : [], \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"status\" : \"0x1\" , \"to\" : \"0xf17f52151ebef6c7334fad080c5704d77216b732\" , \"transactionHash\" : \"0xc00e97af59c6f88de163306935f7682af1a34c67245e414537d02e422815efc3\" , \"transactionIndex\" : \"0x0\" , \"revertReason\" : \"0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4e6f7420656e6f7567682045746865722070726f76696465642e000000000000\" } }","title":"Where is the revert reason included"},{"location":"configure-and-manage/manage/revert-reason/#revert-reason-format","text":"As described in the Solidity documentation , the revert reason is an ABI-encoded string consisting of: 0x08c379a0 // Function selector for Error ( string ) 0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset 0x000000000000000000000000000000000000000000000000000000000000001a // String length 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data Example of revert reason string for \"Not enough Ether provided.\" \"0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4e6f7420656e6f7567682045746865722070726f76696465642e000000000000\"","title":"Revert reason format"},{"location":"configure-and-manage/manage/multi-tenancy/migration/","text":"Multiple private states migration \u00b6 If running GoQuorum version 21.4.1 or earlier or Tessera version 21.1.1 or earlier, you can upgrade your existing nodes to enable multiple private states (MPS) to run as multi-tenant or single-tenant nodes. If you upgrade GoQuorum without upgrading Tessera, GoQuorum continues to operate in legacy mode on a single private state. In this case, GoQuorum can\u2019t be run in MPS mode since Tessera isn\u2019t upgraded. GoQuorum multi-tenant node upgrade \u00b6 You can enable MPS for GoQuorum to run as a multi-tenant node by re-syncing the node after upgrading Tessera . GoQuorum single-tenant node upgrade ( mpsdbupgrade ) \u00b6 You can enable MPS on a single-tenant GoQuorum node by executing the mpsdbupgrade command after upgrading Tessera . It\u2019s faster than a normal sync from block 0 (especially if the network has reached a significant number of blocks). The mpsdbupgrade command upgrades the existing database to an MPS-enabled database with a single private state (and sets isMPS to true in the configuration). Once the upgrade completes, you can introduce additional private states from the current block height. You must specify the directory containing the GoQuorum node database using the --datadir command line option. Important The node must be offline during the upgrade process (we recommend backing up the node data directory before upgrading). You can\u2019t use mpsdbupgrade to combine multiple GoQuorum databases/private states into a single GoQuorum database. mpsdbupgrade command Syntax geth mpsdbupgrade --datadir <DATA-DIRECTORY> Example geth mpsdbupgrade --datadir data Example result Processing block 1 with hash 0xf668e8b8320040a0cabd1b6ec963a79a08536409d82b9ccaa31f62b0a1a4dc10 ... Processing block 1232739 with hash 0x2423b5d0f4c2883172f657f08d7d359b81f144b8cb8393ee24ef285058d55ce8 MPS DB upgrade finished successfully. After execution, the node database contains the empty state and the private state (corresponding to the single private state that existed before the upgrade). Tessera multi-tenant node upgrade \u00b6 You can enable MPS for Tessera to run as a multi-tenant node by rebuilding from the privacy managers of the single-tenant nodes your Tessera node now supports. You must merge all transactions from the privacy managers into the new Tessera storage . Update your Tessera residentGroups configuration so that each tenant has its own private state. This provides a user experience similar to the tenants running separate nodes. After upgrading Tessera, re-sync your GoQuorum node . Tessera single-tenant node upgrade \u00b6 You can enable MPS for Tessera but continue running as a single-tenant node. Upgrade the Tessera version to 21.4.0 or later and configure residentGroups to define a single resident group named \u201cprivate\u201d containing all the tenant\u2019s Tessera keys. You can upgrade your GoQuorum node to support MPS as a single-tenant node .","title":"Multiple private states migration"},{"location":"configure-and-manage/manage/multi-tenancy/migration/#multiple-private-states-migration","text":"If running GoQuorum version 21.4.1 or earlier or Tessera version 21.1.1 or earlier, you can upgrade your existing nodes to enable multiple private states (MPS) to run as multi-tenant or single-tenant nodes. If you upgrade GoQuorum without upgrading Tessera, GoQuorum continues to operate in legacy mode on a single private state. In this case, GoQuorum can\u2019t be run in MPS mode since Tessera isn\u2019t upgraded.","title":"Multiple private states migration"},{"location":"configure-and-manage/manage/multi-tenancy/migration/#goquorum-multi-tenant-node-upgrade","text":"You can enable MPS for GoQuorum to run as a multi-tenant node by re-syncing the node after upgrading Tessera .","title":"GoQuorum multi-tenant node upgrade"},{"location":"configure-and-manage/manage/multi-tenancy/migration/#goquorum-single-tenant-node-upgrade-mpsdbupgrade","text":"You can enable MPS on a single-tenant GoQuorum node by executing the mpsdbupgrade command after upgrading Tessera . It\u2019s faster than a normal sync from block 0 (especially if the network has reached a significant number of blocks). The mpsdbupgrade command upgrades the existing database to an MPS-enabled database with a single private state (and sets isMPS to true in the configuration). Once the upgrade completes, you can introduce additional private states from the current block height. You must specify the directory containing the GoQuorum node database using the --datadir command line option. Important The node must be offline during the upgrade process (we recommend backing up the node data directory before upgrading). You can\u2019t use mpsdbupgrade to combine multiple GoQuorum databases/private states into a single GoQuorum database. mpsdbupgrade command Syntax geth mpsdbupgrade --datadir <DATA-DIRECTORY> Example geth mpsdbupgrade --datadir data Example result Processing block 1 with hash 0xf668e8b8320040a0cabd1b6ec963a79a08536409d82b9ccaa31f62b0a1a4dc10 ... Processing block 1232739 with hash 0x2423b5d0f4c2883172f657f08d7d359b81f144b8cb8393ee24ef285058d55ce8 MPS DB upgrade finished successfully. After execution, the node database contains the empty state and the private state (corresponding to the single private state that existed before the upgrade).","title":"GoQuorum single-tenant node upgrade (mpsdbupgrade)"},{"location":"configure-and-manage/manage/multi-tenancy/migration/#tessera-multi-tenant-node-upgrade","text":"You can enable MPS for Tessera to run as a multi-tenant node by rebuilding from the privacy managers of the single-tenant nodes your Tessera node now supports. You must merge all transactions from the privacy managers into the new Tessera storage . Update your Tessera residentGroups configuration so that each tenant has its own private state. This provides a user experience similar to the tenants running separate nodes. After upgrading Tessera, re-sync your GoQuorum node .","title":"Tessera multi-tenant node upgrade"},{"location":"configure-and-manage/manage/multi-tenancy/migration/#tessera-single-tenant-node-upgrade","text":"You can enable MPS for Tessera but continue running as a single-tenant node. Upgrade the Tessera version to 21.4.0 or later and configure residentGroups to define a single resident group named \u201cprivate\u201d containing all the tenant\u2019s Tessera keys. You can upgrade your GoQuorum node to support MPS as a single-tenant node .","title":"Tessera single-tenant node upgrade"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/","text":"Using multi-tenancy via multiple private states \u00b6 Use multi-tenancy via multiple private states (MPS) to allow multiple tenants to use the same GoQuorum node, with each tenant having its own private state(s). Configure multi-tenancy via multiple private states \u00b6 Prerequisites \u00b6 Tessera version 21.4.0 or later installed GoQuorum version 21.4.2 or later installed Important If running an earlier GoQuorum or Tessera version, upgrade your existing nodes to enable MPS and multi-tenancy using the migration guide . Steps \u00b6 Set isMPS to true in the config item of the GoQuorum genesis file . MPS configuration { \"config\" : { ... \"isMPS\" : true }, ... } Note There can be a mix of MPS-enabled and non-MPS-enabled nodes in a network. Configure the JSON-RPC security plugin . This requires configuring an authorization server. View examples of configuring the plugin to work with different OAuth2 authorization servers . Set enableMultiplePrivateStates to true in the Tessera configuration file. The default is false . Important GoQuorum can\u2019t start if isMPS is true in the GoQuorum configuration and enableMultiplePrivateStates is false in the Tessera configuration. GoQuorum runs as a non-MPS-enabled node if isMPS is false and enableMultiplePrivateStates is true . Configure residentGroups in the Tessera configuration file. Run GoQuorum with the --multitenancy command line option. geth [ OPTIONS ] --multitenancy --plugins file:///<path>/<to>/plugins.json In the command, plugins.json is the plugin settings file that contains the JSON-RPC Security plugin definition . For example, if you use quorum-security-plugin-enterprise , plugins.json looks like the following: plugins.json { \"providers\" : { \"security\" : { \"name\" : \"quorum-security-plugin-enterprise\" , \"version\" : \"0.1.1\" , \"config\" : \"/path/to/config.json\" } } } Configure custom scopes \u00b6 A network operator must configure scope values for each user in an authorization server, for each tenant. Example \u00b6 This example network contains four nodes. Multi-tenant Node1 is shared between tenant J and G ( isMPS=true ) and single-tenant Node2 is used by tenant D alone ( isMPS=false ). Note A node consists of a GoQuorum client and Tessera private transaction manager. We name privacy manager key pairs for easy referencing, for example: J_K1 or G_K1 . In reality, their values are the pubic keys used in the privateFor and privateFrom fields. Tenants are assigned to multi-tenant nodes as follows: J Organization owns J_K1 and J_K2 , and its tenancy is on Node1 . G Organization owns G_K1 and G_K2 , and its tenancy is on Node1 . D Organization owns D_K1 , and its tenancy is on Node2 . In practice, J Organization and G Organization may decide to allocate keys to their departments, therefore the security model may be as follows: J Organization : J Investment has access to J tenancy using any self-managed Ethereum accounts. J Settlement has access to J tenancy using node-managed Ethereum account J_ACC1 and a self-managed Wallet1 . G Organization : G Investment has access to G tenancy using any self-managed Ethereum accounts. G Settlement has access to G tenancy using node-managed Ethereum account G_ACC1 and self-managed Wallet2 . Each authorization server has its own configuration steps and client onboarding process. A network operator\u2019s responsibility is to implement this security model in the authorization server by defining custom scopes and granting them to target clients. A custom scope representing J Investment is: psi://J?self.eoa=0x0 A custom scope representing G Settlement is: psi://G?node.eoa=G_ACC1&self.eoa=Wallet2 Clients must also be granted scopes which specify access to the JSON-RPC APIs: rpc://eth_* Refer to the JSON-RPC security plugi documentation for more information. Add a new tenant to multi-tenant node \u00b6 Use the following steps to add a new tenant to a multi-tenant node: The network administrator executes Tessera keygen to generate a new key. Update the Tessera configuration file to include the new key in a resident group . Restart Tessera to load the new key. Startup fails if the new key is generated but not added to a resident group. Make updates to the authorization server to provide the new tenant access to the private state defined in the resident groups configuration. API methods \u00b6 Use the eth_getMPS JSON-RPC API method to get the private state the user is operating on.","title":"Use multi-tenancy"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#using-multi-tenancy-via-multiple-private-states","text":"Use multi-tenancy via multiple private states (MPS) to allow multiple tenants to use the same GoQuorum node, with each tenant having its own private state(s).","title":"Using multi-tenancy via multiple private states"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#configure-multi-tenancy-via-multiple-private-states","text":"","title":"Configure multi-tenancy via multiple private states"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#prerequisites","text":"Tessera version 21.4.0 or later installed GoQuorum version 21.4.2 or later installed Important If running an earlier GoQuorum or Tessera version, upgrade your existing nodes to enable MPS and multi-tenancy using the migration guide .","title":"Prerequisites"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#steps","text":"Set isMPS to true in the config item of the GoQuorum genesis file . MPS configuration { \"config\" : { ... \"isMPS\" : true }, ... } Note There can be a mix of MPS-enabled and non-MPS-enabled nodes in a network. Configure the JSON-RPC security plugin . This requires configuring an authorization server. View examples of configuring the plugin to work with different OAuth2 authorization servers . Set enableMultiplePrivateStates to true in the Tessera configuration file. The default is false . Important GoQuorum can\u2019t start if isMPS is true in the GoQuorum configuration and enableMultiplePrivateStates is false in the Tessera configuration. GoQuorum runs as a non-MPS-enabled node if isMPS is false and enableMultiplePrivateStates is true . Configure residentGroups in the Tessera configuration file. Run GoQuorum with the --multitenancy command line option. geth [ OPTIONS ] --multitenancy --plugins file:///<path>/<to>/plugins.json In the command, plugins.json is the plugin settings file that contains the JSON-RPC Security plugin definition . For example, if you use quorum-security-plugin-enterprise , plugins.json looks like the following: plugins.json { \"providers\" : { \"security\" : { \"name\" : \"quorum-security-plugin-enterprise\" , \"version\" : \"0.1.1\" , \"config\" : \"/path/to/config.json\" } } }","title":"Steps"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#configure-custom-scopes","text":"A network operator must configure scope values for each user in an authorization server, for each tenant.","title":"Configure custom scopes"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#example","text":"This example network contains four nodes. Multi-tenant Node1 is shared between tenant J and G ( isMPS=true ) and single-tenant Node2 is used by tenant D alone ( isMPS=false ). Note A node consists of a GoQuorum client and Tessera private transaction manager. We name privacy manager key pairs for easy referencing, for example: J_K1 or G_K1 . In reality, their values are the pubic keys used in the privateFor and privateFrom fields. Tenants are assigned to multi-tenant nodes as follows: J Organization owns J_K1 and J_K2 , and its tenancy is on Node1 . G Organization owns G_K1 and G_K2 , and its tenancy is on Node1 . D Organization owns D_K1 , and its tenancy is on Node2 . In practice, J Organization and G Organization may decide to allocate keys to their departments, therefore the security model may be as follows: J Organization : J Investment has access to J tenancy using any self-managed Ethereum accounts. J Settlement has access to J tenancy using node-managed Ethereum account J_ACC1 and a self-managed Wallet1 . G Organization : G Investment has access to G tenancy using any self-managed Ethereum accounts. G Settlement has access to G tenancy using node-managed Ethereum account G_ACC1 and self-managed Wallet2 . Each authorization server has its own configuration steps and client onboarding process. A network operator\u2019s responsibility is to implement this security model in the authorization server by defining custom scopes and granting them to target clients. A custom scope representing J Investment is: psi://J?self.eoa=0x0 A custom scope representing G Settlement is: psi://G?node.eoa=G_ACC1&self.eoa=Wallet2 Clients must also be granted scopes which specify access to the JSON-RPC APIs: rpc://eth_* Refer to the JSON-RPC security plugi documentation for more information.","title":"Example"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#add-a-new-tenant-to-multi-tenant-node","text":"Use the following steps to add a new tenant to a multi-tenant node: The network administrator executes Tessera keygen to generate a new key. Update the Tessera configuration file to include the new key in a resident group . Restart Tessera to load the new key. Startup fails if the new key is generated but not added to a resident group. Make updates to the authorization server to provide the new tenant access to the private state defined in the resident groups configuration.","title":"Add a new tenant to multi-tenant node"},{"location":"configure-and-manage/manage/multi-tenancy/multi-tenancy/#api-methods","text":"Use the eth_getMPS JSON-RPC API method to get the private state the user is operating on.","title":"API methods"},{"location":"configure-and-manage/monitor/cakeshop/","text":"Cakeshop \u00b6 Cakeshop is a set of tools and APIs for working with Ethereum, packaged as a Java web application archive (WAR) that gets you up and running quickly. Out of the box you get: Blockchain explorer - View transactions, blocks, and contracts, and see historical contract state at a point in time. Node info - View the overall status of your network. Peer management - Discover, add, and remove peers. Enhanced permissions UI - Manage enhanced network permissioning . Solidity sandbox - Develop, compile, deploy, and interact with Solidity smart contracts. Contract registry - Keep track of deployed contracts and their code, interfaces, and state. You can access Cakeshop when using the Quorum Developer Quickstart , with Spring Boot , or with Docker . To view Cakeshop with your GoQuorum Quickstart network: Start the Quorum Developer Quickstart with GoQuorum , Start cakeshop , Open the Cakeshop UI at http://localhost:8999 . Tip The Quorum Developer Quickstart tutorial demonstrates how to perform transactions directly using the Cakeshop UI .","title":"Use Cakeshop"},{"location":"configure-and-manage/monitor/cakeshop/#cakeshop","text":"Cakeshop is a set of tools and APIs for working with Ethereum, packaged as a Java web application archive (WAR) that gets you up and running quickly. Out of the box you get: Blockchain explorer - View transactions, blocks, and contracts, and see historical contract state at a point in time. Node info - View the overall status of your network. Peer management - Discover, add, and remove peers. Enhanced permissions UI - Manage enhanced network permissioning . Solidity sandbox - Develop, compile, deploy, and interact with Solidity smart contracts. Contract registry - Keep track of deployed contracts and their code, interfaces, and state. You can access Cakeshop when using the Quorum Developer Quickstart , with Spring Boot , or with Docker . To view Cakeshop with your GoQuorum Quickstart network: Start the Quorum Developer Quickstart with GoQuorum , Start cakeshop , Open the Cakeshop UI at http://localhost:8999 . Tip The Quorum Developer Quickstart tutorial demonstrates how to perform transactions directly using the Cakeshop UI .","title":"Cakeshop"},{"location":"configure-and-manage/monitor/elastic-stack/","text":"Elastic Stack \u00b6 Elastic Stack (ELK) is an open-source log management platform that is available when using the Quorum Developer Quickstart . The Filebeat configuration ingests logs and the Metricbeat configuration collects metrics from the nodes at regular defined intervals and outputs them to Redis for storage. Redis provides a highly available mechanism enabling storage by any of the Elastic Beats and pulled by Logstash as required. The pipeline configuration defines the JSON format used for GoQuorum logs and automatically picks up any new log fields. Note The pipeline configuration must match the your log format. If using the default, you can use the grok plugin to extract the log fields. To view the GoQuorum Quickstart network logs in Kibana: Start the Quorum Developer Quickstart with GoQuorum , selecting ELK monitoring. Open the Kibana logs address listed by the sample networks list.sh script. The logs display in Kibana.","title":"Use Elastic Stack"},{"location":"configure-and-manage/monitor/elastic-stack/#elastic-stack","text":"Elastic Stack (ELK) is an open-source log management platform that is available when using the Quorum Developer Quickstart . The Filebeat configuration ingests logs and the Metricbeat configuration collects metrics from the nodes at regular defined intervals and outputs them to Redis for storage. Redis provides a highly available mechanism enabling storage by any of the Elastic Beats and pulled by Logstash as required. The pipeline configuration defines the JSON format used for GoQuorum logs and automatically picks up any new log fields. Note The pipeline configuration must match the your log format. If using the default, you can use the grok plugin to extract the log fields. To view the GoQuorum Quickstart network logs in Kibana: Start the Quorum Developer Quickstart with GoQuorum , selecting ELK monitoring. Open the Kibana logs address listed by the sample networks list.sh script. The logs display in Kibana.","title":"Elastic Stack"},{"location":"configure-and-manage/monitor/metrics/","text":"Use metrics to monitor node performance \u00b6 You can configure a GoQuorum node to collect metrics that can be viewed in a visualization tool like Grafana . This page explains how to configure a GoQuorum node to provide metrics and enable monitoring. Collect metrics \u00b6 A GoQuorum node can collect and expose the metrics data in the following formats: ExpVars - The standard Go interface to instrument and expose metrics via HTTP. Prometheus - An alternative to ExpVars, and the preferred option because it allows users to pull or push metrics, and has a consistent metric format across languages. InfluxDB - Metrics can only be pushed to Influx. Use the geth command line options --metrics , --pprof , --pprof.addr and --pprof.port where applicable, and set the scraper endpoints to the following: In ExpVar format, http://127.0.0.1:6060/debug/metrics In Prometheus format, http://127.0.0.1:6060/debug/metrics/prometheus Security warning Do not expose the pprof HTTP endpoint to the public internet. This endpoint can be used to trigger resource intensive operations. Use --metric.influxdb and associated geth command line options to push metrics data to InfluxDB . Excerpt of geth command line options LOGGING AND DEBUGGING OPTIONS: --pprof Enable the pprof HTTP server --pprof.addr value pprof HTTP server listening interface (default: \"127.0.0.1\") --pprof.port value pprof HTTP server listening port (default: 6060) METRICS AND STATS OPTIONS: --metrics Enable metrics collection and reporting --metrics.expensive Enable expensive metrics collection and reporting --metrics.influxdb Enable metrics export/push to an external InfluxDB database --metrics.influxdb.endpoint value InfluxDB API endpoint to report metrics to (default: \"http://localhost:8086\") --metrics.influxdb.database value InfluxDB database name to push reported metrics to (default: \"geth\") --metrics.influxdb.username value Username to authorize access to the database (default: \"test\") --metrics.influxdb.password value Password to authorize access to the database (default: \"test\") --metrics.influxdb.tags value Comma-separated InfluxDB tags (key/values) attached to all measurements (default: \"host=localhost\") Visualize collected data \u00b6 You can visualize GoQuorum metrics data with many dashboard tools. For example, you can import the GoQuorum dashboard into your Grafana instance. The GoQuorum Dashboard provides network information such as blocks and transactions per second, CPU usage, and memory usage. Tip If using the Quorum Developer Quickstart , the dashboard is pre-installed in the Grafana container, and the example shows how to configure nodes to use Prometheus to send metrics to Grafana.","title":"Use metrics"},{"location":"configure-and-manage/monitor/metrics/#use-metrics-to-monitor-node-performance","text":"You can configure a GoQuorum node to collect metrics that can be viewed in a visualization tool like Grafana . This page explains how to configure a GoQuorum node to provide metrics and enable monitoring.","title":"Use metrics to monitor node performance"},{"location":"configure-and-manage/monitor/metrics/#collect-metrics","text":"A GoQuorum node can collect and expose the metrics data in the following formats: ExpVars - The standard Go interface to instrument and expose metrics via HTTP. Prometheus - An alternative to ExpVars, and the preferred option because it allows users to pull or push metrics, and has a consistent metric format across languages. InfluxDB - Metrics can only be pushed to Influx. Use the geth command line options --metrics , --pprof , --pprof.addr and --pprof.port where applicable, and set the scraper endpoints to the following: In ExpVar format, http://127.0.0.1:6060/debug/metrics In Prometheus format, http://127.0.0.1:6060/debug/metrics/prometheus Security warning Do not expose the pprof HTTP endpoint to the public internet. This endpoint can be used to trigger resource intensive operations. Use --metric.influxdb and associated geth command line options to push metrics data to InfluxDB . Excerpt of geth command line options LOGGING AND DEBUGGING OPTIONS: --pprof Enable the pprof HTTP server --pprof.addr value pprof HTTP server listening interface (default: \"127.0.0.1\") --pprof.port value pprof HTTP server listening port (default: 6060) METRICS AND STATS OPTIONS: --metrics Enable metrics collection and reporting --metrics.expensive Enable expensive metrics collection and reporting --metrics.influxdb Enable metrics export/push to an external InfluxDB database --metrics.influxdb.endpoint value InfluxDB API endpoint to report metrics to (default: \"http://localhost:8086\") --metrics.influxdb.database value InfluxDB database name to push reported metrics to (default: \"geth\") --metrics.influxdb.username value Username to authorize access to the database (default: \"test\") --metrics.influxdb.password value Password to authorize access to the database (default: \"test\") --metrics.influxdb.tags value Comma-separated InfluxDB tags (key/values) attached to all measurements (default: \"host=localhost\")","title":"Collect metrics"},{"location":"configure-and-manage/monitor/metrics/#visualize-collected-data","text":"You can visualize GoQuorum metrics data with many dashboard tools. For example, you can import the GoQuorum dashboard into your Grafana instance. The GoQuorum Dashboard provides network information such as blocks and transactions per second, CPU usage, and memory usage. Tip If using the Quorum Developer Quickstart , the dashboard is pre-installed in the Grafana container, and the example shows how to configure nodes to use Prometheus to send metrics to Grafana.","title":"Visualize collected data"},{"location":"configure-and-manage/monitor/quorum-hibernate/","text":"Quorum Hibernate \u00b6 Quorum Hibernate is a proxy that monitors a node\u2019s API traffic and hibernates the node when inactive. This reduces infrastructure costs by ensuring only nodes receiving API requests or nodes required to establish consensus are running. Quorum Hibernate wakes up hibernating nodes: When a new transaction or API request is received. To allow it to periodically sync with the network.","title":"Use GoQuorum Hibernate"},{"location":"configure-and-manage/monitor/quorum-hibernate/#quorum-hibernate","text":"Quorum Hibernate is a proxy that monitors a node\u2019s API traffic and hibernates the node when inactive. This reduces infrastructure costs by ensuring only nodes receiving API requests or nodes required to establish consensus are running. Quorum Hibernate wakes up hibernating nodes: When a new transaction or API request is received. To allow it to periodically sync with the network.","title":"Quorum Hibernate"},{"location":"configure-and-manage/monitor/quorum-reporting/","text":"Quorum Reporting \u00b6 Quorum Reporting is a tool that provides APIs for generating reports about contracts deployed to your GoQuorum network. You can access Quorum Reporting when using the Quorum Developer Quickstart or by following the instructions on the repository README . Once a contract is registered, you can use Quorum Reporting to inspect the transactions related to that contract and see how the state of the contract has changed over time. To access Quorum Reporting for your GoQuorum Quickstart network: Start the Quorum Developer Quickstart with GoQuorum , selecting default monitoring. Open the Reporting UI at http://localhost:3000 . The RPC API runs at http://localhost:4000 .","title":"Use GoQuorum Reporting"},{"location":"configure-and-manage/monitor/quorum-reporting/#quorum-reporting","text":"Quorum Reporting is a tool that provides APIs for generating reports about contracts deployed to your GoQuorum network. You can access Quorum Reporting when using the Quorum Developer Quickstart or by following the instructions on the repository README . Once a contract is registered, you can use Quorum Reporting to inspect the transactions related to that contract and see how the state of the contract has changed over time. To access Quorum Reporting for your GoQuorum Quickstart network: Start the Quorum Developer Quickstart with GoQuorum , selecting default monitoring. Open the Reporting UI at http://localhost:3000 . The RPC API runs at http://localhost:4000 .","title":"Quorum Reporting"},{"location":"configure-and-manage/monitor/splunk/","text":"Splunk \u00b6 Splunk is a third-party monitoring solution that is available when using the Quorum Developer Quickstart . If you add Splunk to your GoQuorum Quickstart network, all logs will be directed to the local Splunk container. From there, you can search through the logs, view network metrics, and create custom dashboards with the data that you\u2019re interested in. To view the GoQuorum Quickstart network logs in Splunk: Start the Quorum Developer Quickstart with GoQuorum , selecting Splunk monitoring. Open the Splunk UI at http://localhost:8000 .","title":"Use Splunk"},{"location":"configure-and-manage/monitor/splunk/#splunk","text":"Splunk is a third-party monitoring solution that is available when using the Quorum Developer Quickstart . If you add Splunk to your GoQuorum Quickstart network, all logs will be directed to the local Splunk container. From there, you can search through the logs, view network metrics, and create custom dashboards with the data that you\u2019re interested in. To view the GoQuorum Quickstart network logs in Splunk: Start the Quorum Developer Quickstart with GoQuorum , selecting Splunk monitoring. Open the Splunk UI at http://localhost:8000 .","title":"Splunk"},{"location":"deploy/deployment-overview/","text":"Quorum deployment examples \u00b6 The GoQuorum Ethereum client is part of the ConsenSys Quorum platform. The following are examples of Quorum deployments. For more information about Quorum deployment options, contact Quorum support . Get started with GoQuorum .","title":"GoQuorum deployment examples"},{"location":"deploy/deployment-overview/#quorum-deployment-examples","text":"The GoQuorum Ethereum client is part of the ConsenSys Quorum platform. The following are examples of Quorum deployments. For more information about Quorum deployment options, contact Quorum support . Get started with GoQuorum .","title":"Quorum deployment examples"},{"location":"deploy/install/","text":"Installation overview \u00b6 You can get started with GoQuorum in multiple ways. They range from using the quickstart to generate a local network, to creating and configuring a full network from scratch. Quorum Dev Quickstart \u00b6 The easiest way to get a network up and running is by using the Quorum Dev Quickstart . This command-line tool creates a local GoQuorum network that can be started and be ready for use in minutes. The quickstart provides options for configuring the network and generates all the resources to run in containers using docker-compose . The quickstart requires: Node.js and runs on Linux and Mac only. Docker and Docker-compose . Truffle development framework. curl command line . MetaMask . To start the quickstart, run: npx quorum-dev-quickstart To explore the features of GoQuorum and deploy private contracts, follow the instructions on Interacting with the Network GoQuorum examples sample network \u00b6 GoQuorum examples provides the means to quickly create a pre-configured sample GoQuorum network that can be run either in a virtual-machine environment using Vagrant, in containers using docker-compose, or locally through the use of bash scripts to automate creation of the network. GoQuorum on Kubernetes \u00b6 Use kubernetes to run configurable GoQuorum and Tessera networks on Kubernetes. For local development, use kind or Minikube . For long running networks, use a cloud service (for example Google GKE, Azure AKS, AWS EKS) or a self-hosted Kubernetes cluster. Creating a network from scratch \u00b6 Follow the step-by-step walk-throughs to create and configure GoQuorum networks for QBFT , IBFT , and Raft consensus. It also shows how to enable privacy and add/remove nodes as required. Creating a network deployed in the cloud \u00b6 Quorum Terraform provides an example of how a GoQuorum network can be run on a cloud platform on either AWS or Azure","title":"Installation overview"},{"location":"deploy/install/#installation-overview","text":"You can get started with GoQuorum in multiple ways. They range from using the quickstart to generate a local network, to creating and configuring a full network from scratch.","title":"Installation overview"},{"location":"deploy/install/#quorum-dev-quickstart","text":"The easiest way to get a network up and running is by using the Quorum Dev Quickstart . This command-line tool creates a local GoQuorum network that can be started and be ready for use in minutes. The quickstart provides options for configuring the network and generates all the resources to run in containers using docker-compose . The quickstart requires: Node.js and runs on Linux and Mac only. Docker and Docker-compose . Truffle development framework. curl command line . MetaMask . To start the quickstart, run: npx quorum-dev-quickstart To explore the features of GoQuorum and deploy private contracts, follow the instructions on Interacting with the Network","title":"Quorum Dev Quickstart"},{"location":"deploy/install/#goquorum-examples-sample-network","text":"GoQuorum examples provides the means to quickly create a pre-configured sample GoQuorum network that can be run either in a virtual-machine environment using Vagrant, in containers using docker-compose, or locally through the use of bash scripts to automate creation of the network.","title":"GoQuorum examples sample network"},{"location":"deploy/install/#goquorum-on-kubernetes","text":"Use kubernetes to run configurable GoQuorum and Tessera networks on Kubernetes. For local development, use kind or Minikube . For long running networks, use a cloud service (for example Google GKE, Azure AKS, AWS EKS) or a self-hosted Kubernetes cluster.","title":"GoQuorum on Kubernetes"},{"location":"deploy/install/#creating-a-network-from-scratch","text":"Follow the step-by-step walk-throughs to create and configure GoQuorum networks for QBFT , IBFT , and Raft consensus. It also shows how to enable privacy and add/remove nodes as required.","title":"Creating a network from scratch"},{"location":"deploy/install/#creating-a-network-deployed-in-the-cloud","text":"Quorum Terraform provides an example of how a GoQuorum network can be run on a cloud platform on either AWS or Azure","title":"Creating a network deployed in the cloud"},{"location":"deploy/install/ansible/","text":"GoQuorum can be installed using Ansible on a linux VM or OSX machine. Additionally, you can use the same role in conjuction with other orchestration tooling like Terraform. Ansible-Galaxy \u00b6 You can use an Ansible Galaxy role to install, configure, and run GoQuourum Install the role \u00b6 The first step is to include the role in the requirements.yaml file with any other roles that you use. For example the Prometheus exporter roles below publishes system metrics that can be scraped with Prometheus # requirements.yaml --- roles: - src: consensys.goquorum version: 0 .1.0 - src: undergreen.prometheus-node-exporter version: v1.4.0 - src: undergreen.prometheus-exporters-common version: v1.2.0 Then install the role: ansible-galaxy install --role-file requirements.yaml Use the role \u00b6 After you install the role , create a file called goquorum.yml where you can define variables to configure GoQuorum. For example, you can configure the JSON-RPC service as follows: # goquorum.yml --- - hosts: localhost connection: local force_handlers: True roles: - role: consensys.goquorum vars: goquorum_version: vX.Y.Z goquorum_consensus_algorithm: \"istanbul\" goquorum_genesis_path: \"/path/to/genesis_file\" goquorum_http_enabled: true goquorum_http_host: 127 .0.0.1 goquorum_http_port: 8545 goquorum_http_api: [ \"admin\" , \"db\" , \"eth\" , \"debug\" , \"miner\" , \"net\" , \"web3\" , \"quorum\" , \"ibft\" ] goquorum_http_cors_origins: [ \"all\" ] goquorum_http_virtual_hosts: [ \"all\" ] Run the file as follows: ansible-playbook -v /path/to/goquorum.yml","title":"Ansible"},{"location":"deploy/install/ansible/#ansible-galaxy","text":"You can use an Ansible Galaxy role to install, configure, and run GoQuourum","title":"Ansible-Galaxy"},{"location":"deploy/install/ansible/#install-the-role","text":"The first step is to include the role in the requirements.yaml file with any other roles that you use. For example the Prometheus exporter roles below publishes system metrics that can be scraped with Prometheus # requirements.yaml --- roles: - src: consensys.goquorum version: 0 .1.0 - src: undergreen.prometheus-node-exporter version: v1.4.0 - src: undergreen.prometheus-exporters-common version: v1.2.0 Then install the role: ansible-galaxy install --role-file requirements.yaml","title":"Install the role"},{"location":"deploy/install/ansible/#use-the-role","text":"After you install the role , create a file called goquorum.yml where you can define variables to configure GoQuorum. For example, you can configure the JSON-RPC service as follows: # goquorum.yml --- - hosts: localhost connection: local force_handlers: True roles: - role: consensys.goquorum vars: goquorum_version: vX.Y.Z goquorum_consensus_algorithm: \"istanbul\" goquorum_genesis_path: \"/path/to/genesis_file\" goquorum_http_enabled: true goquorum_http_host: 127 .0.0.1 goquorum_http_port: 8545 goquorum_http_api: [ \"admin\" , \"db\" , \"eth\" , \"debug\" , \"miner\" , \"net\" , \"web3\" , \"quorum\" , \"ibft\" ] goquorum_http_cors_origins: [ \"all\" ] goquorum_http_virtual_hosts: [ \"all\" ] Run the file as follows: ansible-playbook -v /path/to/goquorum.yml","title":"Use the role"},{"location":"deploy/install/binaries/","text":"Install binaries \u00b6 You can install and use GoQuorum and Tessera using Docker containers, building from source, or by downloading pre-built release binaries. Release binaries \u00b6 The pre-compiled release binaries for GoQuorum and Tessera can be downloaded from the following links: Quorum Tessera Once downloaded, add the binaries to the PATH environment variable to make them easier to run. Build from source \u00b6 GoQuorum \u00b6 Note We recommend installing from official containers or release binaries rather than building from source. If you build from source, use Go version 1.15 or later. Clone the repository and build the source: git clone https://github.com/Consensys/quorum.git cd quorum make all Binaries are placed in $REPO_ROOT/build/bin . Add that folder to the PATH environment variable to make geth and bootnode easier to run, or copy those binaries to a folder already in PATH , for example /usr/local/bin . Tip An easy way to supplement PATH is to add PATH=$PATH:/path/to/repository/build/bin to your ~/.bashrc or ~/.bash_aliases file. Run the tests: make test Tessera \u00b6 Follow the installation instructions on the Tessera project page .","title":"Install binaries"},{"location":"deploy/install/binaries/#install-binaries","text":"You can install and use GoQuorum and Tessera using Docker containers, building from source, or by downloading pre-built release binaries.","title":"Install binaries"},{"location":"deploy/install/binaries/#release-binaries","text":"The pre-compiled release binaries for GoQuorum and Tessera can be downloaded from the following links: Quorum Tessera Once downloaded, add the binaries to the PATH environment variable to make them easier to run.","title":"Release binaries"},{"location":"deploy/install/binaries/#build-from-source","text":"","title":"Build from source"},{"location":"deploy/install/binaries/#goquorum","text":"Note We recommend installing from official containers or release binaries rather than building from source. If you build from source, use Go version 1.15 or later. Clone the repository and build the source: git clone https://github.com/Consensys/quorum.git cd quorum make all Binaries are placed in $REPO_ROOT/build/bin . Add that folder to the PATH environment variable to make geth and bootnode easier to run, or copy those binaries to a folder already in PATH , for example /usr/local/bin . Tip An easy way to supplement PATH is to add PATH=$PATH:/path/to/repository/build/bin to your ~/.bashrc or ~/.bash_aliases file. Run the tests: make test","title":"GoQuorum"},{"location":"deploy/install/binaries/#tessera","text":"Follow the installation instructions on the Tessera project page .","title":"Tessera"},{"location":"deploy/install/docker-and-compose/","text":"Docker \u00b6 You can run GoQuorum using the official docker image on Dockerhub . We also provide an official Tessera docker image which can be paired with GoQuorum to handle private transactions. This pattern is used in the Kubernetes manifests and Helm charts. Pull the image \u00b6 After you log into dockerhub , pull the latest image as follows: docker pull quorumengineering/quorum:latest Run the image \u00b6 To run the image, pass in the same command line arguments as you would when running the binary : docker run -d -p 8545 :8545 quorumengineering/quorum:latest --datadir /data --http --http.addr 0 .0.0.0 --http.port 8545 ... Docker Compose \u00b6 Docker-compose allows you to spin up many docker containers simultaneously, and allows you to quickly configure networking and volumes, and develop patterns to use. The Quorum Developer Quickstart provides the simplest and fastest method to spin up a local GoQuourm network with Tessera nodes, and supporting containers for monitoring. You can also use the Kubernetes examples and charts.","title":"Docker and Docker Compose"},{"location":"deploy/install/docker-and-compose/#docker","text":"You can run GoQuorum using the official docker image on Dockerhub . We also provide an official Tessera docker image which can be paired with GoQuorum to handle private transactions. This pattern is used in the Kubernetes manifests and Helm charts.","title":"Docker"},{"location":"deploy/install/docker-and-compose/#pull-the-image","text":"After you log into dockerhub , pull the latest image as follows: docker pull quorumengineering/quorum:latest","title":"Pull the image"},{"location":"deploy/install/docker-and-compose/#run-the-image","text":"To run the image, pass in the same command line arguments as you would when running the binary : docker run -d -p 8545 :8545 quorumengineering/quorum:latest --datadir /data --http --http.addr 0 .0.0.0 --http.port 8545 ...","title":"Run the image"},{"location":"deploy/install/docker-and-compose/#docker-compose","text":"Docker-compose allows you to spin up many docker containers simultaneously, and allows you to quickly configure networking and volumes, and develop patterns to use. The Quorum Developer Quickstart provides the simplest and fastest method to spin up a local GoQuourm network with Tessera nodes, and supporting containers for monitoring. You can also use the Kubernetes examples and charts.","title":"Docker Compose"},{"location":"deploy/install/kubernetes/","text":"Quorum-Kubernetes \u00b6 Use the reference implementations to install private networks using Kubernetes (K8S). The repository has full support for cloud providers like AWS, Azure, GCP, and IBM, and has production setups that use of identities and cloud-native secret storage services like Azure KeyVault and AWS Secrets Manager. Refer to the tutorial and familiarize yourself with the reference implementations, and customize them to your requirements.","title":"Kubernetes"},{"location":"deploy/install/kubernetes/#quorum-kubernetes","text":"Use the reference implementations to install private networks using Kubernetes (K8S). The repository has full support for cloud providers like AWS, Azure, GCP, and IBM, and has production setups that use of identities and cloud-native secret storage services like Azure KeyVault and AWS Secrets Manager. Refer to the tutorial and familiarize yourself with the reference implementations, and customize them to your requirements.","title":"Quorum-Kubernetes"},{"location":"deploy/upgrade/migration/","text":"Upgrade GoQuroum \u00b6 The following information is for upgrading GoQuorum only. You can have multiple versions of GoQuorum running on the same network, allowing you to perform a rolling (node-by-node) upgrade. Ensure your network maintains full uptime availability when upgrading to provide redundancy and reversibility if anything goes wrong. Incremental upgrades \u00b6 Stop the GoQuorum node you wish to upgrade, update the binary to the next version, and restart the node. Check that the node starts without errors and has the latest block from the network. We don\u2019t recommend jumping versions during an upgrade; some versions require manual intervention. Check the release log for any actions you might need to take. Upgrade to GoQuorum 22.1.0 \u00b6 There are several significant changes to the underlying Geth 1.10 in the release of GoQuorum 22.1.0. Before you upgrade to this GoQuorum version, consider and prepare for these changes. The main things to be aware of are option deprecations and chain ID enforcement . Option deprecations \u00b6 Several command line interface (CLI) options are deprecated in the 1.9.x releases of Geth (first merged into GoQuorum as of version 2.6.0). Support for deprecated options is removed in GoQuorum 22.1.0. See the full list of deprecated options . Chain ID enforcement \u00b6 Signing transactions with a chain ID is enforced as the default behavior in Geth 1.10 and GoQuorum 22.1.0 for raw transactions. This impacts client libraries, tooling, and applications. You can send signed raw private transactions that include a chain ID to GoQuorum, but when you use sendTransaction for private transactions, GoQuorum continues to sign it using the Homestead signer (that is, without chain ID). Recommended changes \u00b6 We recommend you sign transactions using the chain ID on your network. If you use a client library, for example, web3j-quorum , you must use the latest QuorumTransactionManager to specify a chain ID. With web3js-quorum you can add the chainId property to the transaction, as seen in the Quorum Developer Quickstart examples. If you don\u2019t want to make application changes \u00b6 From version 22.1.0, you can start GoQuorum with the option --rpc.allow-unprotected-txs . This allows you to submit transactions that aren\u2019t signed with a chain ID. Upgrade to GoQuorum 2.6.0 \u00b6 GoQuorum 2.6.0 upgrades the base Geth version from 1.8.18 to 1.9.7. See Ethereum 1.9.0 for the complete list if new features added as a part of Geth 1.9.7. Note Geth 1.9.7 has several enhancements at the database layer which are part of GoQuorum 2.6.0. Once you migrate to 2.6.0, it can\u2019t roll back to an older version of GoQuorum. We recommend backing up the data directory before upgrading to 2.6.0, which you can use to revert back to the older version if necessary. A node running on GoQuorum 2.6.0 can coexist in a network with other nodes on lower versions of GoQuorum, so you can perform a rolling upgrade to GoQuorum 2.6.0. The following is the recommended upgrade process: Stop the node you wish to upgrade to GoQuorum 2.6.0. Modify the genesis.json file to include istanbulBlock and petersburgBlock . Set these parameters to an appropriate value in future by when the entire network will be upgraded to GoQuorum 2.6.0. Warning Setting the milestone blocks is necessary because the gas calculation logic changes in Geth 1.9.7. Not setting these values properly can result in a Bad block error . GoQuorum 2.6.0 deprecates genesis parameters maxCodeSize and maxCodeSizeChangeBlock . A new attribute maxCodeSizeConfig is added to genesis to allow tracking of multiple maxCodeSize value changes. In earlier GoQuorum versions, if the maxCodeSize is changed multiple times, any node joining the network might get a Bad block error . The changes in GoQuorum 2.6.0 enable tracking of historical changes of maxCodeSize in the genesis file and thus allow it to be changed multiple times in the network\u2019s life. When init is executed in GoQuorum 2.6.0, Geth forces use of maxCodeSizeConfig . Example \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"petersburgBlock\" : 0 , \"istanbulBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"isQuorum\" : true , \"maxCodeSizeConfig\" : [ { \"block\" : 5 , \"size\" : 35 }, { \"block\" : 15 , \"size\" : 24 }, { \"block\" : 20 , \"size\" : 35 } ] }, Execute geth --datadir path/to/datadir init genesis.json with the modified genesis.json . Start the node in GoQuorum 2.6.0. Notes Geth 1.9.7 introduces freezerdb , where block data beyond a certain threshold is moved to a different file-based storage area. Provide the location for freezerdb using the --datadir.ancient Geth command line option. When a node is migrated to this version, Geth by default creates the ancient data folder and starts moving blocks below the immutability threshold (default: 3162240) into the ancient data. If you don\u2019t want this movement to happen, use --immutabilitythreshold to set the immutability threshold to an appropriate value when starting Geth. Geth 1.9.7 by default doesn\u2019t allow unlocking keystore-based accounts in the startup process, and crashes if you attempt this. To enable account unlocking, use the --allow-insecure-unlock Geth option. In a GoQuorum 2.6.0 network running with gcmode=full and block height exceeding the immutability threshold (with blocks in freezerdb ), if a node is restarted non-gracefully ( kill -9/docker kill & start ), it can fail to sync up with its peers, generating a missing parent error. This is due to an upstream bug where non-graceful restart causes a gap between leveldb and freezerdb . You can avoid this by either running the node with gcmode=archive or restarting the node gracefully ( kill / docker stop & start ). This is fixed in GoQuorum v21.4.0 (from upstream Geth 1.9.20).","title":"Upgrade GoQuorum"},{"location":"deploy/upgrade/migration/#upgrade-goquroum","text":"The following information is for upgrading GoQuorum only. You can have multiple versions of GoQuorum running on the same network, allowing you to perform a rolling (node-by-node) upgrade. Ensure your network maintains full uptime availability when upgrading to provide redundancy and reversibility if anything goes wrong.","title":"Upgrade GoQuroum"},{"location":"deploy/upgrade/migration/#incremental-upgrades","text":"Stop the GoQuorum node you wish to upgrade, update the binary to the next version, and restart the node. Check that the node starts without errors and has the latest block from the network. We don\u2019t recommend jumping versions during an upgrade; some versions require manual intervention. Check the release log for any actions you might need to take.","title":"Incremental upgrades"},{"location":"deploy/upgrade/migration/#upgrade-to-goquorum-2210","text":"There are several significant changes to the underlying Geth 1.10 in the release of GoQuorum 22.1.0. Before you upgrade to this GoQuorum version, consider and prepare for these changes. The main things to be aware of are option deprecations and chain ID enforcement .","title":"Upgrade to GoQuorum 22.1.0"},{"location":"deploy/upgrade/migration/#option-deprecations","text":"Several command line interface (CLI) options are deprecated in the 1.9.x releases of Geth (first merged into GoQuorum as of version 2.6.0). Support for deprecated options is removed in GoQuorum 22.1.0. See the full list of deprecated options .","title":"Option deprecations"},{"location":"deploy/upgrade/migration/#chain-id-enforcement","text":"Signing transactions with a chain ID is enforced as the default behavior in Geth 1.10 and GoQuorum 22.1.0 for raw transactions. This impacts client libraries, tooling, and applications. You can send signed raw private transactions that include a chain ID to GoQuorum, but when you use sendTransaction for private transactions, GoQuorum continues to sign it using the Homestead signer (that is, without chain ID).","title":"Chain ID enforcement"},{"location":"deploy/upgrade/migration/#recommended-changes","text":"We recommend you sign transactions using the chain ID on your network. If you use a client library, for example, web3j-quorum , you must use the latest QuorumTransactionManager to specify a chain ID. With web3js-quorum you can add the chainId property to the transaction, as seen in the Quorum Developer Quickstart examples.","title":"Recommended changes"},{"location":"deploy/upgrade/migration/#if-you-dont-want-to-make-application-changes","text":"From version 22.1.0, you can start GoQuorum with the option --rpc.allow-unprotected-txs . This allows you to submit transactions that aren\u2019t signed with a chain ID.","title":"If you don't want to make application changes"},{"location":"deploy/upgrade/migration/#upgrade-to-goquorum-260","text":"GoQuorum 2.6.0 upgrades the base Geth version from 1.8.18 to 1.9.7. See Ethereum 1.9.0 for the complete list if new features added as a part of Geth 1.9.7. Note Geth 1.9.7 has several enhancements at the database layer which are part of GoQuorum 2.6.0. Once you migrate to 2.6.0, it can\u2019t roll back to an older version of GoQuorum. We recommend backing up the data directory before upgrading to 2.6.0, which you can use to revert back to the older version if necessary. A node running on GoQuorum 2.6.0 can coexist in a network with other nodes on lower versions of GoQuorum, so you can perform a rolling upgrade to GoQuorum 2.6.0. The following is the recommended upgrade process: Stop the node you wish to upgrade to GoQuorum 2.6.0. Modify the genesis.json file to include istanbulBlock and petersburgBlock . Set these parameters to an appropriate value in future by when the entire network will be upgraded to GoQuorum 2.6.0. Warning Setting the milestone blocks is necessary because the gas calculation logic changes in Geth 1.9.7. Not setting these values properly can result in a Bad block error . GoQuorum 2.6.0 deprecates genesis parameters maxCodeSize and maxCodeSizeChangeBlock . A new attribute maxCodeSizeConfig is added to genesis to allow tracking of multiple maxCodeSize value changes. In earlier GoQuorum versions, if the maxCodeSize is changed multiple times, any node joining the network might get a Bad block error . The changes in GoQuorum 2.6.0 enable tracking of historical changes of maxCodeSize in the genesis file and thus allow it to be changed multiple times in the network\u2019s life. When init is executed in GoQuorum 2.6.0, Geth forces use of maxCodeSizeConfig . Example \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"petersburgBlock\" : 0 , \"istanbulBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"isQuorum\" : true , \"maxCodeSizeConfig\" : [ { \"block\" : 5 , \"size\" : 35 }, { \"block\" : 15 , \"size\" : 24 }, { \"block\" : 20 , \"size\" : 35 } ] }, Execute geth --datadir path/to/datadir init genesis.json with the modified genesis.json . Start the node in GoQuorum 2.6.0. Notes Geth 1.9.7 introduces freezerdb , where block data beyond a certain threshold is moved to a different file-based storage area. Provide the location for freezerdb using the --datadir.ancient Geth command line option. When a node is migrated to this version, Geth by default creates the ancient data folder and starts moving blocks below the immutability threshold (default: 3162240) into the ancient data. If you don\u2019t want this movement to happen, use --immutabilitythreshold to set the immutability threshold to an appropriate value when starting Geth. Geth 1.9.7 by default doesn\u2019t allow unlocking keystore-based accounts in the startup process, and crashes if you attempt this. To enable account unlocking, use the --allow-insecure-unlock Geth option. In a GoQuorum 2.6.0 network running with gcmode=full and block height exceeding the immutability threshold (with blocks in freezerdb ), if a node is restarted non-gracefully ( kill -9/docker kill & start ), it can fail to sync up with its peers, generating a missing parent error. This is due to an upstream bug where non-graceful restart causes a gap between leveldb and freezerdb . You can avoid this by either running the node with gcmode=archive or restarting the node gracefully ( kill / docker stop & start ). This is fixed in GoQuorum v21.4.0 (from upstream Geth 1.9.20).","title":"Upgrade to GoQuorum 2.6.0"},{"location":"develop/client-libraries/","text":"Client libraries \u00b6 GoQuorum supports common smart contract and dapp development, deployment, and operational use cases, using tools such as Truffle , web3.js and web3js-quorum . The client supports common JSON-RPC API methods, for example eth , net , web3 , debug , and miner . Prerequisites \u00b6 Node.js version 15 or later . The web3 library must be installed in your project . A private network if deploying a public contract. A privacy-enabled network if deploying a private contract. Public contracts can also be deployed on privacy-enabled networks. Note You can use the Quorum Developer Quickstart to deploy either public contracts or private contracts. To enable privacy, enter Y at the prompt for private transactions. web3 \u00b6 The web3.js library is the most widely used for developing applications. Install web3 in your project \u00b6 npm install web3 Initialize the web3 client \u00b6 Initialize your client where: <GoQuorum JSON-RPC HTTP endpoint> is the JSON-RPC HTTP endpoint of your GoQuorum node. Example connection HTTP example const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"http://some.local.remote.endpoint:8545\" ); WS example const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"http://some.local.remote.endpoint:8546\" ); Deploying a contract \u00b6 To deploy a private contract, you need the contract binary. You can use Solidity to get the contract binary. Deploying a contract with Contract.deploy myContract . deploy ({ data : '0x12345...' , arguments : [ 123 , 'My String' ] }) . send ({ from : '0x1234567890123456789012345678901234567891' , gas : 1500000 , gasPrice : '30000000000000' }, function ( error , transactionHash ){ ... }) . on ( 'error' , function ( error ){ ... }) . on ( 'transactionHash' , function ( transactionHash ){ ... }) . on ( 'receipt' , function ( receipt ){ console . log ( receipt . contractAddress ) // contains the new contract address }) . on ( 'confirmation' , function ( confirmationNumber , receipt ){ ... }) . then ( function ( newContractInstance ){ console . log ( newContractInstance . options . address ) // instance with the new contract address }); Alternatively, you can also deploy a contract using eth.sendSignedTransaction Deploying a contract with eth.sendSignedTransaction const rawTxOptions = { nonce : \"0x00\" , from : account . address , to : null , //public tx value : \"0x00\" , data : '0x' + contractBin + contractConstructorInit , gasPrice : \"0x0\" , //ETH per unit of gas gasLimit : \"0x24A22\" //max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const tx = new Tx ( rawTxOptions ); console . log ( \"Signing transaction...\" ); tx . sign ( Buffer . from ( account . privateKey . substring ( 2 ), \"hex\" )); console . log ( \"Sending transaction...\" ); var serializedTx = tx . serialize (); const pTx = await web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' ). toString ( \"hex\" )); console . log ( \"tx transactionHash: \" + pTx . transactionHash ); console . log ( \"tx contractAddress: \" + pTx . contractAddress ); return pTx ; web3 methods \u00b6 For more information about the web3 methods, see the web3 reference documentation . web3js-quorum \u00b6 The web3js-quorum library extends web3.js and adds supports for GoQuorum-specific JSON-RPC APIs and features. Note The web3js-quorum library replaces the deprecated quorum.js and web3js-eea libraries, and includes all the features of both libraries. Important web3js-quorum supports GoQuorum JSON-RPC over HTTP only. Only the enclave connection can be configured over TLS. Information If migrating to web3js-quorum, then update your Javascript code as indicated in the following examples. Read the migration guide for more information about updating your code. Add web3js-quorum to your project \u00b6 npm install web3js-quorum Initialize the web3js-quorum client \u00b6 Initialize your client where: <GoQuorum JSON-RPC HTTP endpoint> is the JSON-RPC HTTP endpoint of your GoQuorum node. <Enclave IPC Path> is the enclave IPC Unix socket path. <Enclave Private URL> is the enclave HTTP endpoint. <enclave key file path> is the enclave public key file path (see Tessera keys documentation ). <enclave TLS cert file path> is the enclave TLS client certificate file path (see Tessera TLS documentation ). <enclave TLS CA cert file path> is the enclave TLS certification authority (CA) certificate file path (see Tessera TLS documentation ). Example connection Full syntax const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const fs = require ( 'fs' ); const isQuorum = true ; const keyFileBuffer = fs . readFileSync ( \"<enclave key file path>\" ); const certFileBuffer = fs . readFileSync ( \"<enclave TLS cert file path>\" ); const caCertFileBuffer = fs . readFileSync ( \"<enclave TLS CA cert file path>\" ); const enclaveOptions = { ipcPath : \"<Enclave IPC Path>\" , privateUrl : \"<Enclave Private URL>\" , tlsSettings : { key : keyFileBuffer , clcert : certFileBuffer , cacert : caCertFileBuffer , allowInsecure : true | false } }; const web3 = new Web3Quorum ( new Web3 ( \"<GoQuorum JSON-RPC HTTP endpoint>\" ), enclaveOptions , isQuorum ); Important IPC and HTTP are mutually exclusive. Choose one or the other depending on your needs. IPC example const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const isQuorum = true ; const enclaveOptions = { ipcPath : \"unix:/tmp/enclave.ipc\" }; const web3 = new Web3Quorum ( new Web3 ( \"http://localhost:8545\" ), enclaveOptions , isQuorum ); Important If IPC is enabled with ipcPath , then HTTP privateUrl and TLS options will be ignored. HTTP example const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const isQuorum = true ; const enclaveOptions = { privateUrl : \"http://localhost:9081\" }; const web3 = new Web3Quorum ( new Web3 ( \"http://localhost:8545\" ), enclaveOptions , isQuorum ); Important If HTTP is enabled with privateUrl , then ipcPath options should not be used. HTTP + enclave TLS example const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const fs = require ( 'fs' ); const isQuorum = true ; const keyFileBuffer = fs . readFileSync ( \"./cert.key\" ); const certFileBuffer = fs . readFileSync ( \"./cert.pem\" ); const caCertFileBuffer = fs . readFileSync ( \"./ca-cert.pem\" ); const enclaveOptions = { privateUrl : \"https://localhost:9081\" , tlsSettings : { key : keyFileBuffer , clcert : certFileBuffer , cacert : caCertFileBuffer , allowInsecure : false } }; const web3 = new Web3Quorum ( new Web3 ( \"http://localhost:8545\" ), enclaveOptions , isQuorum ); Important allowInsecure: false forces the private transaction manager\u2019s certificate to be verified. Setting allowInsecure: true disables the private transaction manager\u2019s certificate verification and allows self-signed certificates. If HTTPS is enabled with privateUrl and TLS options, then ipcPath options should not be used. Deploying a contract with generateAndSendRawTransaction \u00b6 To deploy a private contract, you need the contract binary. You can use Solidity to get the contract binary. Deploying a contract with web3.priv.generateAndSendRawTransaction const contractOptions = { data : `0x123` , // contract binary privateFrom : \"tesseraNode1PublicKey\" , privateFor : [ \"tesseraNode3PublicKey\" ], privateKey : \"goquorumNode1PrivateKey\" }; return web3 . priv . generateAndSendRawTransaction ( contractOptions ); web3.priv.generateAndSendRawTransaction(contractOptions) returns the transaction hash. To get the private transaction receipt, use web3.priv.waitForTransactionReceipt(txHash) . web3js-quorum methods \u00b6 For more information about the web3js-quorum methods, see the web3js-quorum reference documentation .","title":"Client libraries"},{"location":"develop/client-libraries/#client-libraries","text":"GoQuorum supports common smart contract and dapp development, deployment, and operational use cases, using tools such as Truffle , web3.js and web3js-quorum . The client supports common JSON-RPC API methods, for example eth , net , web3 , debug , and miner .","title":"Client libraries"},{"location":"develop/client-libraries/#prerequisites","text":"Node.js version 15 or later . The web3 library must be installed in your project . A private network if deploying a public contract. A privacy-enabled network if deploying a private contract. Public contracts can also be deployed on privacy-enabled networks. Note You can use the Quorum Developer Quickstart to deploy either public contracts or private contracts. To enable privacy, enter Y at the prompt for private transactions.","title":"Prerequisites"},{"location":"develop/client-libraries/#web3","text":"The web3.js library is the most widely used for developing applications.","title":"web3"},{"location":"develop/client-libraries/#install-web3-in-your-project","text":"npm install web3","title":"Install web3 in your project"},{"location":"develop/client-libraries/#initialize-the-web3-client","text":"Initialize your client where: <GoQuorum JSON-RPC HTTP endpoint> is the JSON-RPC HTTP endpoint of your GoQuorum node. Example connection HTTP example const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"http://some.local.remote.endpoint:8545\" ); WS example const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"http://some.local.remote.endpoint:8546\" );","title":"Initialize the web3 client"},{"location":"develop/client-libraries/#deploying-a-contract","text":"To deploy a private contract, you need the contract binary. You can use Solidity to get the contract binary. Deploying a contract with Contract.deploy myContract . deploy ({ data : '0x12345...' , arguments : [ 123 , 'My String' ] }) . send ({ from : '0x1234567890123456789012345678901234567891' , gas : 1500000 , gasPrice : '30000000000000' }, function ( error , transactionHash ){ ... }) . on ( 'error' , function ( error ){ ... }) . on ( 'transactionHash' , function ( transactionHash ){ ... }) . on ( 'receipt' , function ( receipt ){ console . log ( receipt . contractAddress ) // contains the new contract address }) . on ( 'confirmation' , function ( confirmationNumber , receipt ){ ... }) . then ( function ( newContractInstance ){ console . log ( newContractInstance . options . address ) // instance with the new contract address }); Alternatively, you can also deploy a contract using eth.sendSignedTransaction Deploying a contract with eth.sendSignedTransaction const rawTxOptions = { nonce : \"0x00\" , from : account . address , to : null , //public tx value : \"0x00\" , data : '0x' + contractBin + contractConstructorInit , gasPrice : \"0x0\" , //ETH per unit of gas gasLimit : \"0x24A22\" //max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const tx = new Tx ( rawTxOptions ); console . log ( \"Signing transaction...\" ); tx . sign ( Buffer . from ( account . privateKey . substring ( 2 ), \"hex\" )); console . log ( \"Sending transaction...\" ); var serializedTx = tx . serialize (); const pTx = await web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' ). toString ( \"hex\" )); console . log ( \"tx transactionHash: \" + pTx . transactionHash ); console . log ( \"tx contractAddress: \" + pTx . contractAddress ); return pTx ;","title":"Deploying a contract"},{"location":"develop/client-libraries/#web3-methods","text":"For more information about the web3 methods, see the web3 reference documentation .","title":"web3 methods"},{"location":"develop/client-libraries/#web3js-quorum","text":"The web3js-quorum library extends web3.js and adds supports for GoQuorum-specific JSON-RPC APIs and features. Note The web3js-quorum library replaces the deprecated quorum.js and web3js-eea libraries, and includes all the features of both libraries. Important web3js-quorum supports GoQuorum JSON-RPC over HTTP only. Only the enclave connection can be configured over TLS. Information If migrating to web3js-quorum, then update your Javascript code as indicated in the following examples. Read the migration guide for more information about updating your code.","title":"web3js-quorum"},{"location":"develop/client-libraries/#add-web3js-quorum-to-your-project","text":"npm install web3js-quorum","title":"Add web3js-quorum to your project"},{"location":"develop/client-libraries/#initialize-the-web3js-quorum-client","text":"Initialize your client where: <GoQuorum JSON-RPC HTTP endpoint> is the JSON-RPC HTTP endpoint of your GoQuorum node. <Enclave IPC Path> is the enclave IPC Unix socket path. <Enclave Private URL> is the enclave HTTP endpoint. <enclave key file path> is the enclave public key file path (see Tessera keys documentation ). <enclave TLS cert file path> is the enclave TLS client certificate file path (see Tessera TLS documentation ). <enclave TLS CA cert file path> is the enclave TLS certification authority (CA) certificate file path (see Tessera TLS documentation ). Example connection Full syntax const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const fs = require ( 'fs' ); const isQuorum = true ; const keyFileBuffer = fs . readFileSync ( \"<enclave key file path>\" ); const certFileBuffer = fs . readFileSync ( \"<enclave TLS cert file path>\" ); const caCertFileBuffer = fs . readFileSync ( \"<enclave TLS CA cert file path>\" ); const enclaveOptions = { ipcPath : \"<Enclave IPC Path>\" , privateUrl : \"<Enclave Private URL>\" , tlsSettings : { key : keyFileBuffer , clcert : certFileBuffer , cacert : caCertFileBuffer , allowInsecure : true | false } }; const web3 = new Web3Quorum ( new Web3 ( \"<GoQuorum JSON-RPC HTTP endpoint>\" ), enclaveOptions , isQuorum ); Important IPC and HTTP are mutually exclusive. Choose one or the other depending on your needs. IPC example const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const isQuorum = true ; const enclaveOptions = { ipcPath : \"unix:/tmp/enclave.ipc\" }; const web3 = new Web3Quorum ( new Web3 ( \"http://localhost:8545\" ), enclaveOptions , isQuorum ); Important If IPC is enabled with ipcPath , then HTTP privateUrl and TLS options will be ignored. HTTP example const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const isQuorum = true ; const enclaveOptions = { privateUrl : \"http://localhost:9081\" }; const web3 = new Web3Quorum ( new Web3 ( \"http://localhost:8545\" ), enclaveOptions , isQuorum ); Important If HTTP is enabled with privateUrl , then ipcPath options should not be used. HTTP + enclave TLS example const Web3 = require ( \"web3\" ); const Web3Quorum = require ( \"web3js-quorum\" ); const fs = require ( 'fs' ); const isQuorum = true ; const keyFileBuffer = fs . readFileSync ( \"./cert.key\" ); const certFileBuffer = fs . readFileSync ( \"./cert.pem\" ); const caCertFileBuffer = fs . readFileSync ( \"./ca-cert.pem\" ); const enclaveOptions = { privateUrl : \"https://localhost:9081\" , tlsSettings : { key : keyFileBuffer , clcert : certFileBuffer , cacert : caCertFileBuffer , allowInsecure : false } }; const web3 = new Web3Quorum ( new Web3 ( \"http://localhost:8545\" ), enclaveOptions , isQuorum ); Important allowInsecure: false forces the private transaction manager\u2019s certificate to be verified. Setting allowInsecure: true disables the private transaction manager\u2019s certificate verification and allows self-signed certificates. If HTTPS is enabled with privateUrl and TLS options, then ipcPath options should not be used.","title":"Initialize the web3js-quorum client"},{"location":"develop/client-libraries/#deploying-a-contract-with-generateandsendrawtransaction","text":"To deploy a private contract, you need the contract binary. You can use Solidity to get the contract binary. Deploying a contract with web3.priv.generateAndSendRawTransaction const contractOptions = { data : `0x123` , // contract binary privateFrom : \"tesseraNode1PublicKey\" , privateFor : [ \"tesseraNode3PublicKey\" ], privateKey : \"goquorumNode1PrivateKey\" }; return web3 . priv . generateAndSendRawTransaction ( contractOptions ); web3.priv.generateAndSendRawTransaction(contractOptions) returns the transaction hash. To get the private transaction receipt, use web3.priv.waitForTransactionReceipt(txHash) .","title":"Deploying a contract with generateAndSendRawTransaction"},{"location":"develop/client-libraries/#web3js-quorum-methods","text":"For more information about the web3js-quorum methods, see the web3js-quorum reference documentation .","title":"web3js-quorum methods"},{"location":"develop/connecting-to-a-node/","text":"Connect to a node \u00b6 Prerequisites \u00b6 Set up a GoQuorum network using one of the following tutorials: The Quorum Developer Quickstart Create a private network Create a privacy-enabled network Use geth attach \u00b6 The Geth JavaScript console exposes the Web3 JavaScript API for development use, and can be started using the console or attach Geth subcommands. The console subcommand starts the Geth node and opens the console, while the attach subcommand attaches an already-running Geth instance to the console. Run the attach subcommand and connect to the IPC socket, or, if enabled, to the RPC or WebSocket API endpoints: geth attach IPC socket geth attach /path/to/geth.ipc RPC API endpoint geth attach http://host:8545 # connect over HTTP WebSocket API endpoint geth attach ws://host:8546 # connect over websocket Geth console result Welcome to the Geth JavaScript console! instance: Geth/node1-/v1.9.24-stable-d5ef77ca(quorum-v21.7.1)/linux-amd64/go1.15.5 coinbase: 0x93917cadbace5dfce132b991732c6cda9bcc5b8a at block: 8 (Wed Oct 27 2021 03:36:02 GMT+0000 (UTC)) datadir: /data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 To exit, press ctrl-d Once connected you can execute commands as normal. For example, check existing validators using the following command: istanbul.getValidators Geth console request istanbul . getValidators () JSON result [ \"0x27a97c9aaf04f18f3014c32e036dd0ac76da5f18\" , \"0x93917cadbace5dfce132b991732c6cda9bcc5b8a\" , \"0x98c1334496614aed49d2e81526d089f7264fed9c\" , \"0xce412f988377e31f4d0ff12d74df73b51c42d0ca\" ] Exit the console using the following command: exit Use the RPC interface \u00b6 You can connect to a running node by making HTTP REST requests on the RPC endpoint, which is exposed on port 8545 by default. To enable the RPC interface, start the GoQuorum node with the following parameters: --http # Enable the HTTP-RPC server endpoint --http.addr localhost # HTTP-RPC server listening interface (default: \"localhost\") --http.port 8545 # HTTP-RPC server listening port (default: 8545) --http.corsdomain \"localhost\" # Comma-separated list of domains from which to accept cross origin requests (browser enforced) --http.vhosts \"localhost\" # Comma-separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard. --http.api admin,db,... # APIs offered over the HTTP-RPC interface GoQuorum supports the standard web3 JSON-RPC APIs and custom methods . For example, run the following command to get the list of validators at a given block in an IBFT or QBFT network: istanbul_getValidators curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getValidators\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } You can any tool to make requests, such as curl , Postman , or Web3 . Note Use the security plugin to secure the JSON-RPC server. Use the WebSocket interface \u00b6 You can connect to a running node using a WebSocket endpoint, which is exposed on port 8546 by default. To enable the WebSocket interface, start the GoQuorum node with the following parameters: --ws # Enable the WS-RPC server endpoint --ws.addr localhost # WS-RPC server listening interface (default: \"localhost\") --ws.port 8545 # WS-RPC server listening port (default: 8545) --ws.origins \"localhost\" # Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard --ws.api admin,db,... # APIs offered over the WS interface --ws.rpcprefix \"/\" # Path prefix on which WS-RPC is served. Use '/' to serve on all paths. For example, to connect to an endpoint and get logs, run the following JavaScript: eth.subscribe const Web3 = require ( 'web3' ) var web3 = new Web3 ( 'wss://localhost:8546' ); var subscription = web3 . eth . subscribe ( 'logs' , { address : '0x123456..' , topics : [ '0x12345...' ] }, function ( error , result ){ if ( ! error ) console . log ( result ); });","title":"Connect to a node"},{"location":"develop/connecting-to-a-node/#connect-to-a-node","text":"","title":"Connect to a node"},{"location":"develop/connecting-to-a-node/#prerequisites","text":"Set up a GoQuorum network using one of the following tutorials: The Quorum Developer Quickstart Create a private network Create a privacy-enabled network","title":"Prerequisites"},{"location":"develop/connecting-to-a-node/#use-geth-attach","text":"The Geth JavaScript console exposes the Web3 JavaScript API for development use, and can be started using the console or attach Geth subcommands. The console subcommand starts the Geth node and opens the console, while the attach subcommand attaches an already-running Geth instance to the console. Run the attach subcommand and connect to the IPC socket, or, if enabled, to the RPC or WebSocket API endpoints: geth attach IPC socket geth attach /path/to/geth.ipc RPC API endpoint geth attach http://host:8545 # connect over HTTP WebSocket API endpoint geth attach ws://host:8546 # connect over websocket Geth console result Welcome to the Geth JavaScript console! instance: Geth/node1-/v1.9.24-stable-d5ef77ca(quorum-v21.7.1)/linux-amd64/go1.15.5 coinbase: 0x93917cadbace5dfce132b991732c6cda9bcc5b8a at block: 8 (Wed Oct 27 2021 03:36:02 GMT+0000 (UTC)) datadir: /data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 To exit, press ctrl-d Once connected you can execute commands as normal. For example, check existing validators using the following command: istanbul.getValidators Geth console request istanbul . getValidators () JSON result [ \"0x27a97c9aaf04f18f3014c32e036dd0ac76da5f18\" , \"0x93917cadbace5dfce132b991732c6cda9bcc5b8a\" , \"0x98c1334496614aed49d2e81526d089f7264fed9c\" , \"0xce412f988377e31f4d0ff12d74df73b51c42d0ca\" ] Exit the console using the following command: exit","title":"Use geth attach"},{"location":"develop/connecting-to-a-node/#use-the-rpc-interface","text":"You can connect to a running node by making HTTP REST requests on the RPC endpoint, which is exposed on port 8545 by default. To enable the RPC interface, start the GoQuorum node with the following parameters: --http # Enable the HTTP-RPC server endpoint --http.addr localhost # HTTP-RPC server listening interface (default: \"localhost\") --http.port 8545 # HTTP-RPC server listening port (default: 8545) --http.corsdomain \"localhost\" # Comma-separated list of domains from which to accept cross origin requests (browser enforced) --http.vhosts \"localhost\" # Comma-separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard. --http.api admin,db,... # APIs offered over the HTTP-RPC interface GoQuorum supports the standard web3 JSON-RPC APIs and custom methods . For example, run the following command to get the list of validators at a given block in an IBFT or QBFT network: istanbul_getValidators curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getValidators\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } You can any tool to make requests, such as curl , Postman , or Web3 . Note Use the security plugin to secure the JSON-RPC server.","title":"Use the RPC interface"},{"location":"develop/connecting-to-a-node/#use-the-websocket-interface","text":"You can connect to a running node using a WebSocket endpoint, which is exposed on port 8546 by default. To enable the WebSocket interface, start the GoQuorum node with the following parameters: --ws # Enable the WS-RPC server endpoint --ws.addr localhost # WS-RPC server listening interface (default: \"localhost\") --ws.port 8545 # WS-RPC server listening port (default: 8545) --ws.origins \"localhost\" # Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard --ws.api admin,db,... # APIs offered over the WS interface --ws.rpcprefix \"/\" # Path prefix on which WS-RPC is served. Use '/' to serve on all paths. For example, to connect to an endpoint and get logs, run the following JavaScript: eth.subscribe const Web3 = require ( 'web3' ) var web3 = new Web3 ( 'wss://localhost:8546' ); var subscription = web3 . eth . subscribe ( 'logs' , { address : '0x123456..' , topics : [ '0x12345...' ] }, function ( error , result ){ if ( ! error ) console . log ( result ); });","title":"Use the WebSocket interface"},{"location":"develop/develop-plugins/","text":"Develop plugins \u00b6 GoQuorum uses HashiCorp\u2019s go-plugin library to enable a plugin-based architecture using gRPC. We recommend reading the go-plugin gRPC examples . Some advanced topics not available in the go-plugin documentation are covered in this page. Lifecycle \u00b6 Each plugin starts as a separate process and communicates with the GoQuorum client host process via the gRPC service interfaces, over a mutual TLS connection on the local machine. The implementation is inside the go-plugin library. Developing plugins in Go is simplest. For plugins written in other languages , plugin authors must understand the following lifecycle: geth looks for the plugin distribution file after reading the plugin definition from settings. geth verifies the plugin distribution file integrity. geth generates a self-signed certificate (client certificate). geth spawns the plugin with the client certificate. The plugin imports the client certificate and generates a self-signed server certificate for its RPC server. The plugin includes the RPC server certificate in the handshake. geth imports the plugin RPC server certificate. geth communicates with the plugin via RPC over TLS, using mutual TLS. Each plugin must implement the PluginInitializer gRPC service interface . After the plugin process starts and establishes a connection with the GoQuorum client, GoQuorum invokes the Init() gRPC method to initialize the plugin with data from the plugin configuration file, detailed below. Configure plugins \u00b6 GoQuorum can load plugins from: A JSON file specified using the --plugins command line option. An Ethereum TOML configuration file specified using the --config command line option. Configuration files \u00b6 You can specify the plugin configuration file with the following content. JSON file { \"baseDir\" : s tr i n g , \"central\" : objec t (Plugi n Ce ntral Co nf igura t io n ) , \"providers\" : { <s tr i n g> : objec t (Plugi n De f i n i t io n ) } } TOML file [Node.Plugins] BaseDir = string [Node.Plugins.Central] .. = .. from object ( PluginCentralConfiguration ) [[Node.Plugins.Providers]] [[Node.Plugins.Providers.<string>]] .. = .. from object ( PluginDefinition ) Field Description baseDir The local directory from where GoQuorum reads plugins. The default is <datadir>/plugins . To read from an arbitrary environment variable, for example MY_BASE_DIR , provide the value env://MY_BASE_DIR . central A configuration of the remote Plugin Central . providers The supported plugin interfaces mapped to their respective plugin provider definitions . <string> The plugin interface, for example helloworld . PluginCentralConfiguration \u00b6 Plugin integrity verification uses the GoQuorum Plugin Central Server by default. You can modify this section to configure your own local Plugin Central for plugin integrity verification. JSON file { \"central\" : { { \"baseURL\" : s tr i n g , \"certFingerprint\" : s tr i n g , \"publicKeyURI\" : s tr i n g , \"insecureSkipTLSVerify\" : bool , \"pluginDistPathTemplate\" : s tr i n g , \"pluginSigPathTemplate\" : s tr i n g } }, ... } TOML file ... [Node.Plugins.Central] BaseURL = string CertFingerPrint = string PublicKeyURI = string InsecureSkipTLSVerify = bool PluginDistPathTemplate = string PluginSigPathTemplate = string ... Field Description baseURL The remote plugin central URL. For example, https://plugins.mycorp.com . certFingerprint The HTTP server public key fingerprint, in hex, used for certificate pinning. publicKeyURI The path to the PGP public key used for signature verification. insecureSkipTLSVerify If true, GoQuorum doesn\u2019t verify the server\u2019s certificate chain and host name. pluginDistPathTemplate The path template to the plugin distribution file. The value is a Go text template. The variables are {{.Name}}, {{.Version}}, {{.OS}}, and {{.Arch}}. pluginSigPathTemplate The path template to the plugin sha256 signature file. The value is a Go text template. The variables are {{.Name}}, {{.Version}}, {{.OS}}, and {{.Arch}}. PluginDefinition \u00b6 You can define each supported plugin and its configuration in this section. JSON file { \"providers\" : { <s tr i n g> : { \"name\" : s tr i n g , \"version\" : s tr i n g , \"config\" : f ile/s tr i n g/array/objec t }, ... }, ... } TOML file ... [[Node.Plugins.Providers]] [[Node.Plugins.Providers.<string>]] Name = string Version = string Config = file / string / array / object ... ... Field Description name The name of the plugin. version The version of the plugin. config The JSON configuration. The value can be: One of the following URI schemes: The path to the plugin configuration file. For example, file:///opt/plugin.cfg . The configuration as an environment variable. For example, env://MY_CONFIG_JSON . To indicate the value is a file location, append ?type=file . For example, env://MY_CONFIG_FILE?type=file . An arbitrary JSON string. A valid JSON array. For example, [\"1\", \"2\", \"3\"] . A valid JSON object. For example, {\"foo\" : \"bar\"} . Distribute plugins \u00b6 File format \u00b6 A plugin distribution file must be a ZIP file. The file name format is <name>-<version>.zip . <name> and <version> must be the same as the values defined in the PluginDefinition object in the configuration file. Metadata \u00b6 A plugin metadata file plugin-meta.json must be included in the distribution ZIP file. plugin-meta.json contains a valid JSON object with key value pairs. The following key value pairs are required: Syntax { \"name\" : s tr i n g , \"version\" : s tr i n g , \"entrypoint\" : s tr i n g , \"parameters\" : array(s tr i n g) , ... } Example { \"name\" : \"quorum-plugin-helloWorld\" , \"version\" : \"1.0.0\" , \"entrypoint\" : \"helloWorldPlugin\" } Field Description name The name of the plugin. version The version of the plugin. entrypoint The command to execute the plugin process. parameters The command parameters to be passed to the plugin process. Example plugin \u00b6 Follow the HelloWorld plugin tutorial for an example. Plugin interface definitions \u00b6 You can view the gRPC definitions for the initialization interface, HelloWorld plugin interface, account plugin interface, and security plugin interface. Advanced topics for non-Go plugins \u00b6 View the go-plugin GitHub for a guide on developing non-Go plugins. Some additional advanced topics are described here. Magic cookie \u00b6 A magic cookie key and value are used as basic verification that a plugin is intended to be launched. This is a UX feature, not a security measure. Set the magic cookie key and value as an environment variable while executing the plugin process: QUORUM_PLUGIN_MAGIC_COOKIE = \"CB9F51969613126D93468868990F77A8470EB9177503C5A38D437FEFF7786E0941152E05C06A9A3313391059132A7F9CED86C0783FE63A8B38F01623C8257664\" The plugin and the GoQuorum client\u2019s magic cookies are compared. If they are equal then the plugin is loaded. If they aren\u2019t equal, the plugin should show human-friendly output. Mutual TLS authentication \u00b6 The GoQuorum client requires each plugin to authenticate and secure its connection via mutual TLS. The PLUGIN_CLIENT_CERT environment variable is populated with the GoQuorum client certificate (in PEM format). Each plugin must include this certificate to its trusted certificate pool, generate a self-signed certificate, and append the base64-encoded value of the certificate (in DER format) in the handshake message.","title":"Develop plugins"},{"location":"develop/develop-plugins/#develop-plugins","text":"GoQuorum uses HashiCorp\u2019s go-plugin library to enable a plugin-based architecture using gRPC. We recommend reading the go-plugin gRPC examples . Some advanced topics not available in the go-plugin documentation are covered in this page.","title":"Develop plugins"},{"location":"develop/develop-plugins/#lifecycle","text":"Each plugin starts as a separate process and communicates with the GoQuorum client host process via the gRPC service interfaces, over a mutual TLS connection on the local machine. The implementation is inside the go-plugin library. Developing plugins in Go is simplest. For plugins written in other languages , plugin authors must understand the following lifecycle: geth looks for the plugin distribution file after reading the plugin definition from settings. geth verifies the plugin distribution file integrity. geth generates a self-signed certificate (client certificate). geth spawns the plugin with the client certificate. The plugin imports the client certificate and generates a self-signed server certificate for its RPC server. The plugin includes the RPC server certificate in the handshake. geth imports the plugin RPC server certificate. geth communicates with the plugin via RPC over TLS, using mutual TLS. Each plugin must implement the PluginInitializer gRPC service interface . After the plugin process starts and establishes a connection with the GoQuorum client, GoQuorum invokes the Init() gRPC method to initialize the plugin with data from the plugin configuration file, detailed below.","title":"Lifecycle"},{"location":"develop/develop-plugins/#configure-plugins","text":"GoQuorum can load plugins from: A JSON file specified using the --plugins command line option. An Ethereum TOML configuration file specified using the --config command line option.","title":"Configure plugins"},{"location":"develop/develop-plugins/#configuration-files","text":"You can specify the plugin configuration file with the following content. JSON file { \"baseDir\" : s tr i n g , \"central\" : objec t (Plugi n Ce ntral Co nf igura t io n ) , \"providers\" : { <s tr i n g> : objec t (Plugi n De f i n i t io n ) } } TOML file [Node.Plugins] BaseDir = string [Node.Plugins.Central] .. = .. from object ( PluginCentralConfiguration ) [[Node.Plugins.Providers]] [[Node.Plugins.Providers.<string>]] .. = .. from object ( PluginDefinition ) Field Description baseDir The local directory from where GoQuorum reads plugins. The default is <datadir>/plugins . To read from an arbitrary environment variable, for example MY_BASE_DIR , provide the value env://MY_BASE_DIR . central A configuration of the remote Plugin Central . providers The supported plugin interfaces mapped to their respective plugin provider definitions . <string> The plugin interface, for example helloworld .","title":"Configuration files"},{"location":"develop/develop-plugins/#plugincentralconfiguration","text":"Plugin integrity verification uses the GoQuorum Plugin Central Server by default. You can modify this section to configure your own local Plugin Central for plugin integrity verification. JSON file { \"central\" : { { \"baseURL\" : s tr i n g , \"certFingerprint\" : s tr i n g , \"publicKeyURI\" : s tr i n g , \"insecureSkipTLSVerify\" : bool , \"pluginDistPathTemplate\" : s tr i n g , \"pluginSigPathTemplate\" : s tr i n g } }, ... } TOML file ... [Node.Plugins.Central] BaseURL = string CertFingerPrint = string PublicKeyURI = string InsecureSkipTLSVerify = bool PluginDistPathTemplate = string PluginSigPathTemplate = string ... Field Description baseURL The remote plugin central URL. For example, https://plugins.mycorp.com . certFingerprint The HTTP server public key fingerprint, in hex, used for certificate pinning. publicKeyURI The path to the PGP public key used for signature verification. insecureSkipTLSVerify If true, GoQuorum doesn\u2019t verify the server\u2019s certificate chain and host name. pluginDistPathTemplate The path template to the plugin distribution file. The value is a Go text template. The variables are {{.Name}}, {{.Version}}, {{.OS}}, and {{.Arch}}. pluginSigPathTemplate The path template to the plugin sha256 signature file. The value is a Go text template. The variables are {{.Name}}, {{.Version}}, {{.OS}}, and {{.Arch}}.","title":"PluginCentralConfiguration"},{"location":"develop/develop-plugins/#plugindefinition","text":"You can define each supported plugin and its configuration in this section. JSON file { \"providers\" : { <s tr i n g> : { \"name\" : s tr i n g , \"version\" : s tr i n g , \"config\" : f ile/s tr i n g/array/objec t }, ... }, ... } TOML file ... [[Node.Plugins.Providers]] [[Node.Plugins.Providers.<string>]] Name = string Version = string Config = file / string / array / object ... ... Field Description name The name of the plugin. version The version of the plugin. config The JSON configuration. The value can be: One of the following URI schemes: The path to the plugin configuration file. For example, file:///opt/plugin.cfg . The configuration as an environment variable. For example, env://MY_CONFIG_JSON . To indicate the value is a file location, append ?type=file . For example, env://MY_CONFIG_FILE?type=file . An arbitrary JSON string. A valid JSON array. For example, [\"1\", \"2\", \"3\"] . A valid JSON object. For example, {\"foo\" : \"bar\"} .","title":"PluginDefinition"},{"location":"develop/develop-plugins/#distribute-plugins","text":"","title":"Distribute plugins"},{"location":"develop/develop-plugins/#file-format","text":"A plugin distribution file must be a ZIP file. The file name format is <name>-<version>.zip . <name> and <version> must be the same as the values defined in the PluginDefinition object in the configuration file.","title":"File format"},{"location":"develop/develop-plugins/#metadata","text":"A plugin metadata file plugin-meta.json must be included in the distribution ZIP file. plugin-meta.json contains a valid JSON object with key value pairs. The following key value pairs are required: Syntax { \"name\" : s tr i n g , \"version\" : s tr i n g , \"entrypoint\" : s tr i n g , \"parameters\" : array(s tr i n g) , ... } Example { \"name\" : \"quorum-plugin-helloWorld\" , \"version\" : \"1.0.0\" , \"entrypoint\" : \"helloWorldPlugin\" } Field Description name The name of the plugin. version The version of the plugin. entrypoint The command to execute the plugin process. parameters The command parameters to be passed to the plugin process.","title":"Metadata"},{"location":"develop/develop-plugins/#example-plugin","text":"Follow the HelloWorld plugin tutorial for an example.","title":"Example plugin"},{"location":"develop/develop-plugins/#plugin-interface-definitions","text":"You can view the gRPC definitions for the initialization interface, HelloWorld plugin interface, account plugin interface, and security plugin interface.","title":"Plugin interface definitions"},{"location":"develop/develop-plugins/#advanced-topics-for-non-go-plugins","text":"View the go-plugin GitHub for a guide on developing non-Go plugins. Some additional advanced topics are described here.","title":"Advanced topics for non-Go plugins"},{"location":"develop/develop-plugins/#magic-cookie","text":"A magic cookie key and value are used as basic verification that a plugin is intended to be launched. This is a UX feature, not a security measure. Set the magic cookie key and value as an environment variable while executing the plugin process: QUORUM_PLUGIN_MAGIC_COOKIE = \"CB9F51969613126D93468868990F77A8470EB9177503C5A38D437FEFF7786E0941152E05C06A9A3313391059132A7F9CED86C0783FE63A8B38F01623C8257664\" The plugin and the GoQuorum client\u2019s magic cookies are compared. If they are equal then the plugin is loaded. If they aren\u2019t equal, the plugin should show human-friendly output.","title":"Magic cookie"},{"location":"develop/develop-plugins/#mutual-tls-authentication","text":"The GoQuorum client requires each plugin to authenticate and secure its connection via mutual TLS. The PLUGIN_CLIENT_CERT environment variable is populated with the GoQuorum client certificate (in PEM format). Each plugin must include this certificate to its trusted certificate pool, generate a self-signed certificate, and append the base64-encoded value of the certificate (in DER format) in the handshake message.","title":"Mutual TLS authentication"},{"location":"develop/json-rpc-apis/","text":"JSON-RPC Server \u00b6 GoQuorum is based on the Geth Go Ethereum client and supports all standard web3 JSON-RPC APIs . JSON-RPC is supported over HTTP, WebSocket, and Unix Domain Sockets, which are enabled through command-line options Ethereum JSON-RPC APIs use a namespace system, and methods are grouped into categories depending on their purpose. The general form for a method name is the namespace and the actual method name, separated by an underscore. In addition to the standard APIs, GoQuorum adds extra capabilities with to permissioning, privacy, consensus methods, and contracts, all of which are detailed in the API documentation .","title":"JSON-RPC APIs"},{"location":"develop/json-rpc-apis/#json-rpc-server","text":"GoQuorum is based on the Geth Go Ethereum client and supports all standard web3 JSON-RPC APIs . JSON-RPC is supported over HTTP, WebSocket, and Unix Domain Sockets, which are enabled through command-line options Ethereum JSON-RPC APIs use a namespace system, and methods are grouped into categories depending on their purpose. The general form for a method name is the namespace and the actual method name, separated by an underscore. In addition to the standard APIs, GoQuorum adds extra capabilities with to permissioning, privacy, consensus methods, and contracts, all of which are detailed in the API documentation .","title":"JSON-RPC Server"},{"location":"develop/smart-contracts-transactions/","text":"Transactions \u00b6 A blockchain is a shared, immutable electronic ledger (or digital database) that records of transactional data, referred to as transactions . The block in blockchain refers to a block of transactions that\u2019s been broadcast to the network. The chain refers to a string of these blocks in chronological order. When a new block of transactions is securely validated by the network, it is attached to the end of the existing chain. This chain of blocks is an growing ledger of transactions, each of which can be traced, providing accountability and transparency unavailable on traditional ledgers. Smart contracts \u00b6 Smart contracts provide controlled access and a range of functions (such as querying, transacting, and updating state) to blockchain users. Smart contracts encapsulate data and keep it consistent across the network. They can allow or restrict participants from executing certain functions, and can restrict access to the network itself. Smart contracts are written in Solidity (the most popular smart contract language), Vyper, and Serpent. Smart contracts work on the general conditional principle (if/then) of programming, written into code on the blockchain. When conditions defined in the contract are met and verified, it is submitted as a transaction onto the chain where a network of peers validate and execute it. When the transaction is complete, the chain is then updated and its new state is immutable, meaning that you cannot change the state once it is written to the chain. Transactions can be public or private. The contents of a puublic transaction are visible to all participants on the blockchain network, and the contents of private transactions can only be seen by parties of the transaction, or those that have been granted access to view it. Typically transactions are used to deploy contracts , interact with contracts or transfer funds and the links provide tutorials of each. Dapps \u00b6 Decentralized applications (dapps), like any other software application, can be a website or mobile app. Dapps are built on a decentralized network (Ethereum) and interact with smart contracts deployed to the network. They can be thought of as a GUI (front end) for a smart contract (back end), and can be written in any language (for example, JavaScript). If using the Quorum Developer Quickstart , or existing blockchain, you can use a demo dapp called Pet Shop , provided by Truffle .","title":"Smart contracts and transactions"},{"location":"develop/smart-contracts-transactions/#transactions","text":"A blockchain is a shared, immutable electronic ledger (or digital database) that records of transactional data, referred to as transactions . The block in blockchain refers to a block of transactions that\u2019s been broadcast to the network. The chain refers to a string of these blocks in chronological order. When a new block of transactions is securely validated by the network, it is attached to the end of the existing chain. This chain of blocks is an growing ledger of transactions, each of which can be traced, providing accountability and transparency unavailable on traditional ledgers.","title":"Transactions"},{"location":"develop/smart-contracts-transactions/#smart-contracts","text":"Smart contracts provide controlled access and a range of functions (such as querying, transacting, and updating state) to blockchain users. Smart contracts encapsulate data and keep it consistent across the network. They can allow or restrict participants from executing certain functions, and can restrict access to the network itself. Smart contracts are written in Solidity (the most popular smart contract language), Vyper, and Serpent. Smart contracts work on the general conditional principle (if/then) of programming, written into code on the blockchain. When conditions defined in the contract are met and verified, it is submitted as a transaction onto the chain where a network of peers validate and execute it. When the transaction is complete, the chain is then updated and its new state is immutable, meaning that you cannot change the state once it is written to the chain. Transactions can be public or private. The contents of a puublic transaction are visible to all participants on the blockchain network, and the contents of private transactions can only be seen by parties of the transaction, or those that have been granted access to view it. Typically transactions are used to deploy contracts , interact with contracts or transfer funds and the links provide tutorials of each.","title":"Smart contracts"},{"location":"develop/smart-contracts-transactions/#dapps","text":"Decentralized applications (dapps), like any other software application, can be a website or mobile app. Dapps are built on a decentralized network (Ethereum) and interact with smart contracts deployed to the network. They can be thought of as a GUI (front end) for a smart contract (back end), and can be written in any language (for example, JavaScript). If using the Quorum Developer Quickstart , or existing blockchain, you can use a demo dapp called Pet Shop , provided by Truffle .","title":"Dapps"},{"location":"develop/manage-keys/","text":"Manage keys \u00b6 Options for managing keys in GoQuorum include: keystore files - As with geth , you can store keys in password-protected keystore files. clef - Introduced in GoQuorum v2.6.0, clef runs as a standalone process that increases flexibility and security by handling GoQuorum\u2019s account management responsibilities. account plugins - Introduced in GoQuorum v2.7.0, account plugins allow you to extend GoQuorum or clef with alternative methods of managing accounts.","title":"Manage keys"},{"location":"develop/manage-keys/#manage-keys","text":"Options for managing keys in GoQuorum include: keystore files - As with geth , you can store keys in password-protected keystore files. clef - Introduced in GoQuorum v2.6.0, clef runs as a standalone process that increases flexibility and security by handling GoQuorum\u2019s account management responsibilities. account plugins - Introduced in GoQuorum v2.7.0, account plugins allow you to extend GoQuorum or clef with alternative methods of managing accounts.","title":"Manage keys"},{"location":"develop/manage-keys/account-plugins/","text":"account plugins \u00b6 You can use account plugins with GoQuorum or clef to provide additional account management. See the account plugin reference for more information. Available account plugins \u00b6 Name Version Description hashicorp-vault 0.0.1 Enables storage of GoQuorum account keys in a HashiCorp Vault KV v2 engine. Written in Go. Using GoQuorum and clef \u00b6 Run an account plugin using GoQuorum or clef : GoQuorum geth --plugins file:///path/to/plugins.json ... clef clef --plugins file:///path/to/plugins.json ... plugins.json is the plugins configuration file that defines an account provider: { \"providers\" : { \"account\" : { \"name\" : \"quorum-account-plugin-<NAME>\" , \"version\" : \"<VERSION>\" , \"config\" : \"file:///path/to/plugin.json\" } } } RPC API \u00b6 A limited API allows users to interact directly with account plugins. Important GoQuorum must expose the API using the --http.api plugin@account or --ws.api plugin@account command line options. plugin@account_newAccount \u00b6 Creates a plugin-managed account with a new key. Parameters \u00b6 config : object - Plugin-specific JSON configuration for creating an account. See the plugin\u2019s documentation for more information on the JSON configuration required. Example GoQuorum curl -X POST \\ -H \"Content-Type:application/json\" \\ -d ' { \"jsonrpc\":\"2.0\", \"method\":\"plugin@account_newAccount\", \"params\":[{<config>}], \"id\":1 }' \\ http://localhost:22000 JS console plugin_account . newAccount ({ < config > }) clef echo ' { \"jsonrpc\":\"2.0\", \"method\":\"plugin@account_newAccount\", \"params\":[{<config>}], \"id\":1 } ' | nc -U /path/to/clef.ipc plugin@account_importRawKey \u00b6 Creates a plugin-managed account from an existing private key. Note Although you can use this API to move plugin-managed accounts between nodes, the plugin may provide a preferable alternative. See the plugin\u2019s documentation for more information. Parameters \u00b6 rawkey : string - Hex-encoded account private key (without the 0x prefix). config : object - Plugin-specific JSON configuration for creating a new account. See the plugin\u2019s documentation for more information on the JSON configuration required. Example GoQuorum curl -X POST \\ -H \"Content-Type:application/json\" \\ -d ' { \"jsonrpc\":\"2.0\", \"method\":\"plugin@account_importRawKey\", \"params\":[\"<rawkey>\", {<config>}], \"id\":1 }' \\ http://localhost:22000 JS console plugin_account . importRawKey ( < rawkey > , { < config > }) clef Not supported, use CLI instead Command line interface \u00b6 A limited command line interface allows users to interact directly with account plugins. Run the following command to view all geth account plugin subcommands and options: geth account plugin --help Info Use the --verbosity option to hide log output. For example, geth --verbosity 1 account plugin new ... . geth account plugin new \u00b6 Creates a plugin-managed account from an existing key. Parameters \u00b6 plugins.account.config : Plugin-specific configuration for creating an account. The value can be file://... or inline JSON. See the plugin\u2019s documentation for more information on the JSON configuration required. JSON file geth account plugin new \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config file:///path/to/new-acct-config.json inline JSON geth account plugin new \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config '{<json>}' geth account plugin import \u00b6 Creates a plugin-managed account from an existing private key. Parameters \u00b6 plugins.account.config : Plugin-specific configuration for creating an account. The value can be file://... or inline JSON. See the plugin\u2019s documentation for more information on the JSON configuration required. rawkey : Path to the file containing a hex-encoded account private key (without the 0x prefix) (for example /path/to/raw.key ). JSON file geth account plugin import \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config file:///path/to/new-acct-config.json \\ /path/to/raw.key inline JSON geth account plugin import \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config '{<json>}' /path/to/raw.key geth account plugin list \u00b6 Lists all the plugin-managed accounts for a given configuration. geth account plugin list \\ --plugins file:///path/to/plugin-config.json","title":"Use account plugins"},{"location":"develop/manage-keys/account-plugins/#account-plugins","text":"You can use account plugins with GoQuorum or clef to provide additional account management. See the account plugin reference for more information.","title":"account plugins"},{"location":"develop/manage-keys/account-plugins/#available-account-plugins","text":"Name Version Description hashicorp-vault 0.0.1 Enables storage of GoQuorum account keys in a HashiCorp Vault KV v2 engine. Written in Go.","title":"Available account plugins"},{"location":"develop/manage-keys/account-plugins/#using-goquorum-and-clef","text":"Run an account plugin using GoQuorum or clef : GoQuorum geth --plugins file:///path/to/plugins.json ... clef clef --plugins file:///path/to/plugins.json ... plugins.json is the plugins configuration file that defines an account provider: { \"providers\" : { \"account\" : { \"name\" : \"quorum-account-plugin-<NAME>\" , \"version\" : \"<VERSION>\" , \"config\" : \"file:///path/to/plugin.json\" } } }","title":"Using GoQuorum and clef"},{"location":"develop/manage-keys/account-plugins/#rpc-api","text":"A limited API allows users to interact directly with account plugins. Important GoQuorum must expose the API using the --http.api plugin@account or --ws.api plugin@account command line options.","title":"RPC API"},{"location":"develop/manage-keys/account-plugins/#pluginaccount_newaccount","text":"Creates a plugin-managed account with a new key.","title":"plugin@account_newAccount"},{"location":"develop/manage-keys/account-plugins/#parameters","text":"config : object - Plugin-specific JSON configuration for creating an account. See the plugin\u2019s documentation for more information on the JSON configuration required. Example GoQuorum curl -X POST \\ -H \"Content-Type:application/json\" \\ -d ' { \"jsonrpc\":\"2.0\", \"method\":\"plugin@account_newAccount\", \"params\":[{<config>}], \"id\":1 }' \\ http://localhost:22000 JS console plugin_account . newAccount ({ < config > }) clef echo ' { \"jsonrpc\":\"2.0\", \"method\":\"plugin@account_newAccount\", \"params\":[{<config>}], \"id\":1 } ' | nc -U /path/to/clef.ipc","title":"Parameters"},{"location":"develop/manage-keys/account-plugins/#pluginaccount_importrawkey","text":"Creates a plugin-managed account from an existing private key. Note Although you can use this API to move plugin-managed accounts between nodes, the plugin may provide a preferable alternative. See the plugin\u2019s documentation for more information.","title":"plugin@account_importRawKey"},{"location":"develop/manage-keys/account-plugins/#parameters_1","text":"rawkey : string - Hex-encoded account private key (without the 0x prefix). config : object - Plugin-specific JSON configuration for creating a new account. See the plugin\u2019s documentation for more information on the JSON configuration required. Example GoQuorum curl -X POST \\ -H \"Content-Type:application/json\" \\ -d ' { \"jsonrpc\":\"2.0\", \"method\":\"plugin@account_importRawKey\", \"params\":[\"<rawkey>\", {<config>}], \"id\":1 }' \\ http://localhost:22000 JS console plugin_account . importRawKey ( < rawkey > , { < config > }) clef Not supported, use CLI instead","title":"Parameters"},{"location":"develop/manage-keys/account-plugins/#command-line-interface","text":"A limited command line interface allows users to interact directly with account plugins. Run the following command to view all geth account plugin subcommands and options: geth account plugin --help Info Use the --verbosity option to hide log output. For example, geth --verbosity 1 account plugin new ... .","title":"Command line interface"},{"location":"develop/manage-keys/account-plugins/#geth-account-plugin-new","text":"Creates a plugin-managed account from an existing key.","title":"geth account plugin new"},{"location":"develop/manage-keys/account-plugins/#parameters_2","text":"plugins.account.config : Plugin-specific configuration for creating an account. The value can be file://... or inline JSON. See the plugin\u2019s documentation for more information on the JSON configuration required. JSON file geth account plugin new \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config file:///path/to/new-acct-config.json inline JSON geth account plugin new \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config '{<json>}'","title":"Parameters"},{"location":"develop/manage-keys/account-plugins/#geth-account-plugin-import","text":"Creates a plugin-managed account from an existing private key.","title":"geth account plugin import"},{"location":"develop/manage-keys/account-plugins/#parameters_3","text":"plugins.account.config : Plugin-specific configuration for creating an account. The value can be file://... or inline JSON. See the plugin\u2019s documentation for more information on the JSON configuration required. rawkey : Path to the file containing a hex-encoded account private key (without the 0x prefix) (for example /path/to/raw.key ). JSON file geth account plugin import \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config file:///path/to/new-acct-config.json \\ /path/to/raw.key inline JSON geth account plugin import \\ --plugins file:///path/to/plugin-config.json \\ --plugins.account.config '{<json>}' /path/to/raw.key","title":"Parameters"},{"location":"develop/manage-keys/account-plugins/#geth-account-plugin-list","text":"Lists all the plugin-managed accounts for a given configuration. geth account plugin list \\ --plugins file:///path/to/plugin-config.json","title":"geth account plugin list"},{"location":"develop/manage-keys/clef/","text":"Using clef \u00b6 clef was introduced in Quorum v2.6.0 . clef for GoQuorum is the standard go-ethereum clef tool, with support for GoQuorum-specific features including: Support for private transactions. Ability to extend functionality with account plugins . clef runs as a separate process to geth and provides an alternative method of managing accounts and signing transactions/data. Instead of geth loading and using accounts directly, geth delegates account management responsibilities to clef . Important Account management will be deprecated within geth in the future and replaced with clef . Using clef instead of geth for account management has several benefits: Users and dapps no longer depend on access to a synchronized local node loaded with accounts. Transactions and dapp data can instead be signed using clef . Future account-related features will only be available in clef and not in geth . (For example, EIP-191 and EIP-712 are implemented in clef , but there is no intention of implementing them in geth .) User-experience improvements to ease use and improve security. Installing \u00b6 You can install geth and all included tools ( clef , bootnode , \u2026) to PATH by building GoQuorum from source with make all . Verify the installation with: clef help Getting started \u00b6 Read the overview and step-by-step guide on clef initialization, startup, and automation rules configuration . Using \u00b6 clef can be used in one of two ways: As an external signer. As a geth signer. Warning In the long term, the preferred way of using clef will be as an external signer. However, while waiting for clef API support, the go-ethereum project has included the option to use clef as a geth signer. This ensures existing tooling and user flows can remain unchanged. The option to use clef as a geth signer will be deprecated in a future release of go-ethereum once the migration of account management from geth to clef is complete. As an external signer \u00b6 Using clef as an external signer requires interacting with clef through its RPC API. By default this is exposed over IPC socket. The API can also be exposed over HTTP by using the --http.addr CLI flag. Example An example workflow: Start clef and make your accounts available to it. Sign a transaction with the account by using clef \u2018s account_signTransaction API. clef returns the signed transaction. Use eth_sendRawTransaction or eth_sendRawPrivateTransaction to send the signed transaction to a GoQuorum node that doesn\u2019t have your accounts available to it. The GoQuorum node validates the transaction and propagates it through the network for minting. List accounts echo '{\"id\": 1, \"jsonrpc\": \"2.0\", \"method\": \"account_list\"}' | nc -U /path/to/clef.ipc Sign data echo '{\"id\": 1, \"jsonrpc\": \"2.0\", \"method\": \"account_signData\", \"params\": [\"data/plain\", \"0x6038dc01869425004ca0b8370f6c81cf464213b3\", \"0xaaaaaa\"]}' | nc -U /path/to/clef.ipc As a geth signer \u00b6 Using clef as a geth signer doesn\u2019t require direct interaction through the clef API. Use geth as normal and it automatically delegates to clef . To use clef as a geth signer: Start clef . Start geth with the --signer /path/to/clef.ipc CLI flag. An example workflow: Start clef and make your accounts available to it. Start geth and don\u2019t make your accounts available to it. Use eth_sendTransaction to sign and submit a transaction for validation, propagation, and minting. Extending with account plugins \u00b6 By default, clef manages file-stored keystore accounts. You can enable alternative account management options using account plugins . clef --plugins file:///path/to/plugin-config.json More information \u00b6 More information can be found in the .md files in the cmd/clef directory .","title":"Use clef"},{"location":"develop/manage-keys/clef/#using-clef","text":"clef was introduced in Quorum v2.6.0 . clef for GoQuorum is the standard go-ethereum clef tool, with support for GoQuorum-specific features including: Support for private transactions. Ability to extend functionality with account plugins . clef runs as a separate process to geth and provides an alternative method of managing accounts and signing transactions/data. Instead of geth loading and using accounts directly, geth delegates account management responsibilities to clef . Important Account management will be deprecated within geth in the future and replaced with clef . Using clef instead of geth for account management has several benefits: Users and dapps no longer depend on access to a synchronized local node loaded with accounts. Transactions and dapp data can instead be signed using clef . Future account-related features will only be available in clef and not in geth . (For example, EIP-191 and EIP-712 are implemented in clef , but there is no intention of implementing them in geth .) User-experience improvements to ease use and improve security.","title":"Using clef"},{"location":"develop/manage-keys/clef/#installing","text":"You can install geth and all included tools ( clef , bootnode , \u2026) to PATH by building GoQuorum from source with make all . Verify the installation with: clef help","title":"Installing"},{"location":"develop/manage-keys/clef/#getting-started","text":"Read the overview and step-by-step guide on clef initialization, startup, and automation rules configuration .","title":"Getting started"},{"location":"develop/manage-keys/clef/#using","text":"clef can be used in one of two ways: As an external signer. As a geth signer. Warning In the long term, the preferred way of using clef will be as an external signer. However, while waiting for clef API support, the go-ethereum project has included the option to use clef as a geth signer. This ensures existing tooling and user flows can remain unchanged. The option to use clef as a geth signer will be deprecated in a future release of go-ethereum once the migration of account management from geth to clef is complete.","title":"Using"},{"location":"develop/manage-keys/clef/#as-an-external-signer","text":"Using clef as an external signer requires interacting with clef through its RPC API. By default this is exposed over IPC socket. The API can also be exposed over HTTP by using the --http.addr CLI flag. Example An example workflow: Start clef and make your accounts available to it. Sign a transaction with the account by using clef \u2018s account_signTransaction API. clef returns the signed transaction. Use eth_sendRawTransaction or eth_sendRawPrivateTransaction to send the signed transaction to a GoQuorum node that doesn\u2019t have your accounts available to it. The GoQuorum node validates the transaction and propagates it through the network for minting. List accounts echo '{\"id\": 1, \"jsonrpc\": \"2.0\", \"method\": \"account_list\"}' | nc -U /path/to/clef.ipc Sign data echo '{\"id\": 1, \"jsonrpc\": \"2.0\", \"method\": \"account_signData\", \"params\": [\"data/plain\", \"0x6038dc01869425004ca0b8370f6c81cf464213b3\", \"0xaaaaaa\"]}' | nc -U /path/to/clef.ipc","title":"As an external signer"},{"location":"develop/manage-keys/clef/#as-a-geth-signer","text":"Using clef as a geth signer doesn\u2019t require direct interaction through the clef API. Use geth as normal and it automatically delegates to clef . To use clef as a geth signer: Start clef . Start geth with the --signer /path/to/clef.ipc CLI flag. An example workflow: Start clef and make your accounts available to it. Start geth and don\u2019t make your accounts available to it. Use eth_sendTransaction to sign and submit a transaction for validation, propagation, and minting.","title":"As a geth signer"},{"location":"develop/manage-keys/clef/#extending-with-account-plugins","text":"By default, clef manages file-stored keystore accounts. You can enable alternative account management options using account plugins . clef --plugins file:///path/to/plugin-config.json","title":"Extending with account plugins"},{"location":"develop/manage-keys/clef/#more-information","text":"More information can be found in the .md files in the cmd/clef directory .","title":"More information"},{"location":"reference/accounts-for-testing/","text":"Accounts for testing \u00b6 You can use existing accounts for testing by including them in the genesis file for a private network. The genesis files in the IBFT network tutorial and Raft network tutorial define the following accounts used for testing. Security warning Do not use the test accounts on Ethereum Mainnet or any production network. The following accounts are test accounts and their private keys are publicly visible in this documentation and in publicly available source code. They are not secure and everyone can use them. Using test accounts on Ethereum Mainnet and production networks can lead to loss of funds and identity fraud. In this documentation, we only provide test accounts for ease of testing and learning purposes; never use them for other purposes. Always secure your Ethereum Mainnet and any production account properly. See for instance MyCrypto \u201cProtecting Yourself and Your Funds\u201d guide . Test Account 1 (address 0xfe3b557e8fb62b89f4916b721be55ceb828dbd73 ) Private key to copy : 0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63 Initial balance : 200 Eth (200000000000000000000 Wei) Test Account 2 (address 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 ) Private key to copy : 0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 Initial balance : 90000 Eth (90000000000000000000000 Wei) Test Account 3 (address 0xf17f52151EbEF6C7334FAD080c5704D77216b732 ) Private key to copy : 0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f Initial balance : 90000 Eth (90000000000000000000000 Wei) Genesis file \u00b6 To use existing test accounts, specify the accounts and balances in a genesis file for your test network, as in this example .","title":"Accounts for testing"},{"location":"reference/accounts-for-testing/#accounts-for-testing","text":"You can use existing accounts for testing by including them in the genesis file for a private network. The genesis files in the IBFT network tutorial and Raft network tutorial define the following accounts used for testing. Security warning Do not use the test accounts on Ethereum Mainnet or any production network. The following accounts are test accounts and their private keys are publicly visible in this documentation and in publicly available source code. They are not secure and everyone can use them. Using test accounts on Ethereum Mainnet and production networks can lead to loss of funds and identity fraud. In this documentation, we only provide test accounts for ease of testing and learning purposes; never use them for other purposes. Always secure your Ethereum Mainnet and any production account properly. See for instance MyCrypto \u201cProtecting Yourself and Your Funds\u201d guide . Test Account 1 (address 0xfe3b557e8fb62b89f4916b721be55ceb828dbd73 ) Private key to copy : 0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63 Initial balance : 200 Eth (200000000000000000000 Wei) Test Account 2 (address 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 ) Private key to copy : 0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 Initial balance : 90000 Eth (90000000000000000000000 Wei) Test Account 3 (address 0xf17f52151EbEF6C7334FAD080c5704D77216b732 ) Private key to copy : 0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f Initial balance : 90000 Eth (90000000000000000000000 Wei)","title":"Accounts for testing"},{"location":"reference/accounts-for-testing/#genesis-file","text":"To use existing test accounts, specify the accounts and balances in a genesis file for your test network, as in this example .","title":"Genesis file"},{"location":"reference/api-methods/","text":"GoQuorum API methods \u00b6 This reference describes the GoQuorum JSON-RPC API methods. Important GoQuorum is based on Geth Go Ethereum client but only the GoQuorum-specific API methods are listed here. Visit the Go Ethereum documentation to view the Geth API methods. Contract extension methods \u00b6 The following API methods provide functionality for GoQuorum contract extension . quorumExtension_activeExtensionContracts \u00b6 Lists all active contract extensions involving this node (either as initiator or receiver). Parameters \u00b6 None Returns \u00b6 result : array of objects - list of contract extension objects with the following fields: managementContractAddress : string - address of the extension management contract contractExtended : string - address of the private contract getting extended creationData : data - Tessera hash of creation data for extension management contract initiator : string - contract extension initiator\u2019s Ethereum address recipient : string - new participant\u2019s Ethereum address; the participant must later approve the extension using this address. recipientPtmKey : string - new participant\u2019s Tessera public key Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_activeExtensionContracts\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : [{ \"managementContractAddress\" : \"0xc4e9de0bd5e0a5fd55ef5d6f2b46eba930a694a3\" , \"contractExtended\" : \"0x027692c7ebdc81c590250e615ab571a0d14eff2d\" , \"creationData\" : \"Zvo1Rnrfq4phIJbzKObyCBWSXTbEJGPOq5+jDCWccnPpA7K6OvIssCMLJ54f32uuEeczeVNC46QMk52lCOWbtg==\" , \"initiator\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"recipient\" : \"0x0fbdc686b912d7722dc86510934589e0aaf3b55a\" , \"recipientPtmKey\" : \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" }] } geth console request quorumExtension . activeExtensionContracts geth console result [{ \"managementContractAddress\" : \"0xc4e9de0bd5e0a5fd55ef5d6f2b46eba930a694a3\" , \"contractExtended\" : \"0x027692c7ebdc81c590250e615ab571a0d14eff2d\" , \"creationData\" : \"Zvo1Rnrfq4phIJbzKObyCBWSXTbEJGPOq5+jDCWccnPpA7K6OvIssCMLJ54f32uuEeczeVNC46QMk52lCOWbtg==\" , \"initiator\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"recipient\" : \"0x0fbdc686b912d7722dc86510934589e0aaf3b55a\" , \"recipientPtmKey\" : \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" }] quorumExtension_approveExtension \u00b6 Submits an approval/denial vote to the specified extension management contract. Parameters \u00b6 addressToVoteOn : string - address of the contract extension\u2019s management contract (this can be found using quorumExtension_activeExtensionContracts ) vote : boolean - true approves the extension process, false cancels the extension process txArgs : object - arguments for the vote submission transaction; privateFor must contain the public key of the node that initiated the contract extension. Returns \u00b6 result : data - hash of the vote submission transaction Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_approveExtension\",\"params\":[\"0xb1c57951a2f3006910115eadf0f167890e99b9cb\",true,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"privateFor\":[\"QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc=\"]}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"0x8d34a594b286087f45029daad2d5a8fd42f70abb0ae2492429a256a2ba4cb0dd\" } geth console request quorumExtension . approveExtension ( \"0xb1c57951a2f3006910115eadf0f167890e99b9cb\" , true ,{ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"privateFor\" : [ \"QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc=\" ]}) geth console result \"0x8d34a594b286087f45029daad2d5a8fd42f70abb0ae2492429a256a2ba4cb0dd\" Frequent issues If you attempt to extend a contract in the process of being extended, the following error is returned: Error: contract extension in progress for the given contract address The recipient can approve the extension only once. Executing quorumExtension.approveExtension once the extension process is completed results in the following error: Error: contract extension process complete. nothing to accept The approver (the from address in txArgs ) must be the receiver of the extension ( recipientAddress from quorumExtension_extendContract ): Error: account is not acceptor of this extension request quorumExtension_cancelExtension \u00b6 Cancels the specified active contract extension. This can only be invoked by the initiator of the extension process (the caller of quorumExtension_extendContract ). Parameters \u00b6 extensionContract : string - address of the contract extension\u2019s management contract txArgs : object - arguments for the cancellation transaction Returns \u00b6 result : data - hash of the cancellation transaction Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_cancelExtension\",\"params\":[\"0x622aff909c081783613c9d3f5f4c47be78b310ac\",{\"from\":\"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\",\"value\":\"0x0\",\"privateFor\":[\"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\"],\"privacyFlag\":1}],\"id\":63}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"0xb43da7dbeae5347df86c6933786b8c536b4622463b577a990d4c87214845d16a\" } geth console request quorumExtension . cancelExtension ( \"0x622aff909c081783613c9d3f5f4c47be78b310ac\" ,{ \"from\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"value\" : \"0x0\" , \"privateFor\" : [ \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\" ]}) geth console result \"0xb43da7dbeae5347df86c6933786b8c536b4622463b577a990d4c87214845d16a\" Frequent issues The canceller ( from address in txArgs ) must be the same as the initiator of the extension (the from address in txArgs for the quorumExtension_extendContract call) or the following error is returned: Error: account is not the creator of this extension request quorumExtension_extendContract \u00b6 Starts the process of extending an existing private contract to a new participant by deploying a new extension management contract to the blockchain. Parameters \u00b6 toExtend : string - address of the private contract to extend newRecipientPtmPublicKey : string - new participant\u2019s Tessera public key recipientAddress : string - new participant\u2019s Ethereum address; the participant must later approve the extension using this address. txArgs : object - arguments for the transaction that deploys the extension management contract; privateFor must contain only the newRecipientPtmPublicKey . Returns \u00b6 result : data - hash of the creation transaction for the new extension management contract Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_extendContract\",\"params\":[\"0x9aff347f193ca4560276c3322193224dcdbbe578\",\"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\",\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",{\"from\":\"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\",\"value\":\"0x0\",\"privateFor\":[\"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\"],\"privacyFlag\":1}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"0xceffe8051d098920ac84e33b8a05c48180ed9b26581a6a06ce9874a1bf1502bd\" } geth console request quorumExtension . extendContract ( \"0x9aff347f193ca4560276c3322193224dcdbbe578\" , \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\" , \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" ,{ from : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"privateFor\" : [ \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\" ]}) geth console result \"0xceffe8051d098920ac84e33b8a05c48180ed9b26581a6a06ce9874a1bf1502bd\" Frequent issues If you attempt to extend a contract in the process of being extended, the following error is returned: Error: contract extension in progress for the given contract address You must execute quorumExtension_extendContract from the node that initially created the contract. If the network is using enhanced network permissioning , then both initiator (the from address in txArgs ) and receiver ( recipientAddress ) of the extension must be network or org admin accounts. quorumExtension_getExtensionStatus \u00b6 Retrieves the status of the specified contract extension. Parameters \u00b6 managementContractAddress : string - address of the extension management contract Returns \u00b6 result : string - status of contract extension ( ACTIVE or DONE ) Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_getExtensionStatus\",\"params\":[\"0x1349f3e1b8d71effb47b840594ff27da7e603d17\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"DONE\" } geth console request quorumExtension . getExtensionStatus ( \"0x1349f3e1b8d71effb47b840594ff27da7e603d17\" ) geth console result \"DONE\" Debug methods \u00b6 The following API methods allow you to inspect and debug the network. debug_dumpAddress \u00b6 Retrieves the state of an address at the specified block number. Parameters \u00b6 address : string - account address of the state to retrieve blockNumber : number - integer representing a block number or one of the string tags latest (the last block mined) or pending (the last block mined plus pending transactions) Returns \u00b6 result : object - state of the account address Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"debug_dumpAddress\",\"params\":[\"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\",10],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : { \"balance\" : \"49358640978154672\" , \"code\" : \"\" , \"codeHash\" : \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" , \"nonce\" : 2 , \"root\" : \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"storage\" :{} } } geth console request ```javascript debug.dumpAddress(\u201c0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\u201d,10) geth console result { \"balance\" : \"49358640978154672\" , \"code\" : \"\" , \"codeHash\" : \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" , \"nonce\" : 2 , \"root\" : \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"storage\" :{} } debug_privateStateRoot \u00b6 Returns the private state root hash at the specified block number. Parameters \u00b6 blockNumber : number - integer representing a block number or one of the string tags latest (the last block mined) or pending (the last block mined plus pending transactions). Returns \u00b6 result : data - private state root hash Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"debug_privateStateRoot\",\"params\":[\"latest\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" } geth console request debug . privateStateRoot ( \"latest\" ) geth console result \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" IBFT methods \u00b6 The following API methods provide access to the IBFT and QBFT consensus engines. To use these methods: Run Istanbul geth with --http.api \"istanbul\" . Run geth attach . istanbul_candidates \u00b6 Returns the current candidates which the node tries to vote in or out. Parameters \u00b6 None Returns \u00b6 result : map of strings to booleans - current candidates map Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_candidates\",\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" : true } } geth console request istanbul . candidates geth console result { \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" : true } istanbul_discard \u00b6 Drops a currently running candidate, stopping further votes from being cast either for or against the candidate. Parameters \u00b6 address : string - address of the candidate Returns \u00b6 result : null Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_discard\",\"params\":[\"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : null } geth console request istanbul . discard ( \"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\" ) geth console result null istanbul_getSignersFromBlock \u00b6 Retrieves the public addresses whose seals are included in the specified block number. This means that they participated in the consensus for this block and attested to its validity. Parameters \u00b6 blockNumber : number - (optional) block number to retrieve; defaults to current block Returns \u00b6 result : object - result object with the following fields: number : number - retrieved block\u2019s number hash : string - retrieved block\u2019s hash author : string - address of the block proposer committers : array of strings - list of all addresses whose seal appears in this block Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSignersFromBlock\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"number\" : 10 , \"hash\" : \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" , \"author\" : \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"committers\" : [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } } geth console request istanbul . getSignersFromBlock ( 10 ) == \u201cgeth console result\u201d ```js { \"number\":10, \"hash\":\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\", \"author\":\"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\", \"committers\": [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\", \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } ``` istanbul_getSignersFromBlockByHash \u00b6 Retrieves the public addresses whose seals are included in the specified block number. This means that they participated in the consensus for this block and attested to its validity. Parameters \u00b6 blockHash : string - hash of the block to retrieve (required) Returns \u00b6 result : object - result object with the following fields: number : number - retrieved block\u2019s number hash : string - retrieved block\u2019s hash author : string - address of the block proposer committers : array of strings - list of all addresses whose seal appears in this block Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSignersFromBlockByHash\",\"params\":[\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"number\" : 10 , \"hash\" : \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" , \"author\" : \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"committers\" : [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } } geth console request istanbul . getSignersFromBlockByHash ( \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" ) geth console result { \"number\" : 10 , \"hash\" : \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" , \"author\" : \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"committers\" : [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } istanbul_getSnapshot \u00b6 Retrieves the state snapshot at the specified block number. Parameters \u00b6 blockNumber : number or string - (optional) integer representing a block number or the string tag latest (the last block mined); defaults to latest Returns \u00b6 result : object - snapshot object Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSnapshot\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"epoch\" : 30000 , \"number\" : 16 , \"hash\" : \"0x2d7df0a0dc7b1136687bb5a8b7ca3e7b00414a8f8d3a9c756ff59c49b78ce08e\" , \"votes\" :[], \"tally\" :{}, \"validators\" : [ \"0x6571d97f340c8495b661a823f2c2145ca47d63c2\" , \"0xd8dba507e85f116b1f7e231ca8525fc9008a6966\" , \"0xe36cbeb565b061217930767886474e3cde903ac5\" , \"0xf512a992f3fb749857d758ffda1330e590fa915e\" ], \"policy\" : 0 } } geth console request istanbul . getSnapshot ( 10 ) geth console result { \"epoch\" : 30000 , \"number\" : 16 , \"hash\" : \"0x2d7df0a0dc7b1136687bb5a8b7ca3e7b00414a8f8d3a9c756ff59c49b78ce08e\" , \"votes\" : [], \"tally\" : {}, \"validators\" : [ \"0x6571d97f340c8495b661a823f2c2145ca47d63c2\" , \"0xd8dba507e85f116b1f7e231ca8525fc9008a6966\" , \"0xe36cbeb565b061217930767886474e3cde903ac5\" , \"0xf512a992f3fb749857d758ffda1330e590fa915e\" ], \"policy\" : 0 } istanbul_getSnapshotAtHash \u00b6 Retrieves the state snapshot at the specified block hash. Parameters \u00b6 blockHash : string - block hash Returns \u00b6 result : object - snapshot object Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSnapshotAtHash\",\"params\":[\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { } } geth console request istanbul . getSnapshotAtHash ( \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" ) geth console result {} istanbul_getValidators \u00b6 Retrieves the list of authorized validators at the specified block number. Parameters \u00b6 blockNumber : number or string - (optional) integer representing a block number or the string tag latest (the last block mined); defaults to latest Returns \u00b6 result : array of strings - list of validator addresses Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getValidators\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } geth console request istanbul . getValidators ( 10 ) geth console result [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] istanbul_getValidatorsAtHash \u00b6 Retrieves the list of authorized validators at the specified block hash. Parameters \u00b6 blockHash : string - block hash Returns \u00b6 result : array of strings - list of validator addresses Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getValidatorsAtHash\",\"params\":[\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } geth console request istanbul . getValidatorsAtHash ( \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" ) geth console result [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] istanbul_isValidator \u00b6 Indicates if this node is the validator for the specified block number. Parameters \u00b6 blockNumber : number - (optional) block number; defaults to latest block number Returns \u00b6 result : boolean - true if this node is the validator for the given blockNumber , otherwise false Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_isValidator\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : true } geth console request istanbul . isValidator ( 10 ) geth console result true istanbul_nodeAddress \u00b6 Retrieves the public address that is used to sign proposals, which is derived from the node\u2019s nodekey . Parameters \u00b6 None Returns \u00b6 result : string - node\u2019s public signing address Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_nodeAddress\",\"id\":1}' --header \"Content-Type: application/json\" JSON result ```JSON { \u201cjsonrpc\u201d:\u201d2.0\u201d, \u201cid\u201d:1, \u201cresult\u201d:\u201d0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\u201d } geth console request istanbul . nodeAddress () geth console result \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" istanbul_propose \u00b6 Injects a new authorization candidate that the validator attempts to push through. If a majority of the validators vote the candidate in/out, the candidate is added/removed in the validator set. Parameters \u00b6 address : string - address of candidate auth : boolean - true votes the candidate in and false votes out Returns \u00b6 result : null Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_propose\",\"params\":[\"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\",true],\"id\":1}' --header \"Content-Type: application/json\" JSON result ```JSON { \u201cjsonrpc\u201d:\u201d2.0\u201d, \u201cid\u201d:1, \u201cresult\u201d:null } geth console request istanbul . propose ( \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" , true ) geth console result null istanbul_status \u00b6 Returns the signing status of blocks for the specified block range. Parameters \u00b6 startBlockNumber : number - start block number endBlockNumber : number - end block number If the start block and end block numbers are not provided, the status of the last 64 blocks is returned. Returns \u00b6 result : object - result object with the following fields: numBlocks : number - number of blocks for which sealer activity is retrieved sealerActivity : map of strings to numbers - key is the validator and value is the number of blocks sealed by the validator Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_status\",\"params\":[1,10],\"id\":1}' --header \"Content-Type: application/json\" JSON result ```JSON { \u201cjsonrpc\u201d:\u201d2.0\u201d, \u201cid\u201d:1, \u201cresult\u201d: { \u201cnumBlocks\u201d:2, \u201csealerActivity\u201d: { \u201c0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\u201d: 3, \u201c0x71c7656ec7ab88b098defb751b7401b5f6d8976f\u201d: 1 } } } geth console request istanbul . status ( 1 , 10 ) geth console result { \"numblocks\" : 2 , \"sealerActivity\" : { \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" : 3 , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" : 1 } } Permission methods \u00b6 The following API methods provide functionality for GoQuorum permissioning . quorumPermission_acctList \u00b6 Returns a list of permissioned accounts in the network. Parameters \u00b6 None Returns \u00b6 result : array of objects - list of permissioned account objects with the following fields: acctId : string - account ID isOrgAdmin : boolean - indicates if the account is admin account for the organization orgId : string - organization ID roleId : string - role assigned to the account status : number - account status Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_acctList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 53 , \"result\" : [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }] } geth console request quorumPermission . acctList geth console result [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }] quorumPermission_addAccountToOrg \u00b6 Adds an account to an organization and assigns a role to the account. This method can be called by an organization admin account. The account can only be linked to a single organization or sub-organization. Parameters \u00b6 acctId : string - account ID orgId : string - organization ID roleId : string - role ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addAccountToOrg\",\"params\":[\"0xf017976fdf1521de2e108e63b423380307f501f8\",\"ABC\",\"TRANSACT\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addAccountToOrg ( \"0xf017976fdf1521de2e108e63b423380307f501f8\" , \"ABC\" , \"TRANSACT\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_addNewRole \u00b6 Creates a new role for the organization. This method can be called by an organization admin account. Parameters \u00b6 orgId : string - organization ID for which the role is being created roleId : string - unique role ID accountAccess : number - account level access isVoter : boolean - indicates if the role is a voting role isAdminRole : boolean - indicates if the role is an admin role Note When adding a new role to a sub-organization, the role ID must exist in the master organization under which the sub-organization falls. Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addNewRole\",\"params\":[\"ABC\",\"TRANSACT\",1,false,false,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addNewRole ( \"ABC\" , \"TRANSACT\" , 1 , false , false ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_addNode \u00b6 Adds a node to the specified organization or sub-organization. This method can be called by an organization admin account. A node cannot be part of multiple organizations. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addNode\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addNode ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_addOrg \u00b6 Proposes a new organization into the network. This method can be called by a network admin account. If there are any pending items for approval, proposal of any new organization fails. Also, the enode ID and account ID can only be linked to one organization. Parameter \u00b6 orgId : string - unique organization ID enodeId : string - complete enode ID accountId : string - account to be the organization admin account Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addOrg\",\"params\":[\"ABC\",\"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\",\"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addOrg ( \"ABC\" , \"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" ,{ from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_addSubOrg \u00b6 Creates a sub-organization under the master organization. This method can be called by an organization admin account. Parameters \u00b6 parentOrgId : string - parent organization ID under which the sub-organization is being added Note The parent organization ID should contain the complete organization hierarchy from master organization ID to the immediate parent. The organization hierarchy is separated by . (dot character). For example, if master organization ABC has a sub-organization SUB1 , then while creating the sub-organization at SUB1 level, the parent organization should be given as ABC.SUB1 . subOrgId : string - sub-organization ID enodeId : string - complete enode ID of the node linked to the sub-organization ID; if left as an empty string, inherits the enode ID from the parent organization. Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addSubOrg\",\"params\":[\"ABC.SUB1\",\"SUB2\",\"\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addSubOrg ( \"ABC.SUB1\" , \"SUB2\" , \"\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_approveAdminRole \u00b6 Approves the organization admin or network admin role assignment to the specified account. This method can be called by a network admin account. The role is approved once the majority of network admins approve. Parameters \u00b6 orgId : string - organization ID to which the account belongs acctId : string - account ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveAdminRole\",\"params\":[\"ABC\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveAdminRole ( \"ABC\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_approveBlackListedAccountRecovery \u00b6 Approves the recovery of the specified denylisted (blacklisted) account . This method can be called by a network admin account. Once a majority of the network admins approve, the account is marked as active. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the node belongs acctId : string - denylisted account ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveBlackListedNodeRecovery\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveBlackListedNodeRecovery ( \"ABC.SUB1.SUB2.SUB3\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_approveBlackListedNodeRecovery \u00b6 Approves the recovery of the specified denylisted (blacklisted) node . This method can be called by a network admin account. Once the majority of network admins approve, the denylisted node is marked as active. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveBlackListedNodeRecovery\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveBlackListedNodeRecovery ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_approveOrg \u00b6 Approves the specified proposed organization into the network. This method can be called by a network admin account. Parameters \u00b6 orgId : string - unique organization ID enodeId : string - complete enode ID accountId : string - account to be the organization admin account Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveOrg\",\"params\":[\"ABC\",\"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\",\"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveOrg ( \"ABC\" , \"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_approveOrgStatus \u00b6 Approves an organization status change proposal . This method can be called by a network admin account. Once a majority of the network admins approve the status update, the organization status is updated. When an organization is in suspended status, no transactions or contract deployment activities are allowed from any nodes linked to the organization and sub-organizations under it. Similarly, no transactions are allowed from any accounts linked to the organization. Parameters \u00b6 orgId : string - organization ID action : number - 1 - for approving organization suspension 2 - for approving activation of the suspended organization Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveOrgStatus\",\"params\":[\"ABC\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveOrgStatus ( \"ABC\" , 1 ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_assignAdminRole \u00b6 Adds a new account as network admin or changes the organization admin account for an organization. This method can be called by a network admin account. Once a majority of the network admins approve , the role is approved. Parameters \u00b6 orgId : string - organization ID to which the account belongs acctId : string - account ID roleId : string - new role ID to be assigned to the account; this can be the network admin role or an organization admin role only. Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_assignAdminRole\",\"params\":[\"ABC\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",\"NWADMIN\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . assignAdminRole ( \"ABC\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" , \"NWADMIN\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" quorumPermission_changeAccountRole \u00b6 Assigns a role to the specified account. This method can be called by an organization admin account. Parameters \u00b6 acctId : string - account ID orgId : string - organization ID roleId : string - new role ID to be assigned to the account Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_changeAccountRole\",\"params\":[\"0xf017976fdf1521de2e108e63b423380307f501f8\",\"ABC\",\"TRANSACT\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . changeAccountRole ( \"0xf017976fdf1521de2e108e63b423380307f501f8\" , \"ABC\" , \"TRANSACT\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_connectionAllowed \u00b6 Checks if the specified node is allowed to join the network. Parameters \u00b6 enodeId : string - enode ID ipAddress : string - IP address of the node portNum : number - port number Returns \u00b6 result : boolean - indicates if the connection is allowed or not Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_connectionAllowed\",\"params\":[\"239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf\",\"127.0.0.1\",21006],\"id\":50}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : true } geth console request quorumPermission . connectionAllowed ( \"579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778\" , \"127.0.0.1\" , 21003 ) geth console result true quorumPermission_getOrgDetails \u00b6 Returns lists of accounts, nodes, roles, and sub-organizations linked to the specified organization. Parameters \u00b6 orgId : string - organization or sub-organization ID Returns \u00b6 result : object - result object with the following fields: acctList : array of objects - list of account objects nodeList : array of objects - list of node objects roleList : array of objects - list of role objects subOrgList : array of objects - list of sub-organization objects Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_getOrgDetails\",\"params\":[\"INITORG\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"acctList\" : [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }], \"nodeList\" : [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }], \"roleList\" : [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }], \"subOrgList\" : null } } geth console request quorumPermission_getOrgDetails ( \"INITORG\" ) geth console result { \"acctList\" : [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }], \"nodeList\" : [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }], \"roleList\" : [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }], \"subOrgList\" : null } quorumPermission_nodeList \u00b6 Returns a list of permissioned nodes in the network. Parameters \u00b6 None Returns \u00b6 result : array of objects - list of permissioned node objects with the following fields: orgId : string - organization ID to which the node belongs status : number - node status url : string - complete enode ID Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_nodeList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 53 , \"result\" : [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }] } geth console request quorumPermission . nodeList geth console result [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }] quorumPermission_orgList \u00b6 Returns a list of all organizations with the status of each organization in the network. Parameters \u00b6 None Returns \u00b6 result : array of objects - list of organization objects with the following fields: fullOrgId : string - complete organization ID including all the parent organization IDs separated by . level : number - level of the organization in the organization hierarchy orgId : string - organization ID parentOrgId : string - immediate parent organization ID status : number - organization status subOrgList : array of strings - list of sub-organizations linked to the organization ultimateParent : string - master organization under which the organization falls Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_orgList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 51 , \"result\" : [{ \"fullOrgId\" : \"INITORG\" , \"level\" : 1 , \"orgId\" : \"INITORG\" , \"parentOrgId\" : \"\" , \"status\" : 2 , \"subOrgList\" : null , \"ultimateParent\" : \"INITORG\" }] } geth console request quorumPermission . orgList geth console result [{ \"fullOrgId\" : \"INITORG\" , \"level\" : 1 , \"orgId\" : \"INITORG\" , \"parentOrgId\" : \"\" , \"status\" : 2 , \"subOrgList\" : null , \"ultimateParent\" : \"INITORG\" }] quorumPermission_recoverBlackListedAccount \u00b6 Initiates the recovery of the specified denylisted (blacklisted) account. This method can be called by a network admin account. Once a majority of the network admins approve , the denylisted account is marked as active. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the node belongs acctId : string - denylisted account ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_recoverBlackListedAccount\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . recoverBlackListedAccount ( \"ABC.SUB1.SUB2.SUB3\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_recoverBlackListedNode \u00b6 Initiates the recovery of the specified denylisted (blacklisted) node. This method can be called by a network admin account. Once the majority of network admins approve , the denylisted node is marked as active. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_recoverBlackListedNode\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . recoverBlackListedNode ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_removeRole \u00b6 Removes the specified role from an organization. This method can be called by an organization admin account. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the role belongs roleId : string - role ID Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_removeRole\",\"params\":[\"ABC\",\"TRANSACT\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . removeRole ( \"ABC.SUB1.SUB2.SUB3\" , \"TRANSACT\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_roleList \u00b6 Returns a list of roles in the network. Parameters \u00b6 None Returns \u00b6 result : array of objects - list of role objects with the following fields: access : number - account access active : boolean - indicates if the role is active or not isAdmin : boolean - indicates if the role is organization admin role isVoter : boolean - indicates if the role is enabled for voting - applicable only for network admin role orgId : string - organization ID to which the role is linked roleId : string - unique role ID Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_roleList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }] } geth console request quorumPermission . roleList geth console result [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }] quorumPermission_transactionAllowed \u00b6 Checks if the account initiating the specified transaction has sufficient permissions to execute the transaction. Parameters \u00b6 txArgs : object - transaction arguments object Returns \u00b6 result : boolean - indicates if transaction is allowed or not Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_transactionAllowed\",\"params\":[{\"from\":\"0xf2cd20ed7904c103ce2ca0ef73fb77539930c59f\"}],\"id\":50}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : true } geth console request quorumPermission . transactionAllowed ({ \"from\" : eth . accounts [ 0 ]} geth console result true quorumPermission_updateAccountStatus \u00b6 Updates the status of the specified account. This method can be called by an organization admin account. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the account belongs acctId : string - account ID action : number - 1 - for suspending the account 2 - for activating the suspended account 3 - for denylisting (blacklisting) the account Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_updateAccountStatus\",\"params\":[\"ABC\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . updateAccountStatus ( \"ABC\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" , 1 ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_updateNodeStatus \u00b6 Updates the status of the specified node. This method can be called by an organization admin account. Parameters \u00b6 orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID action : number - 1 - for deactivating the node 2 - for activating the deactivated node 3 - for denylisting (blacklisting) the node Returns \u00b6 result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_updateNodeStatus\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . updateNodeStatus ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" , 3 ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\" quorumPermission_updateOrgStatus \u00b6 Temporarily suspends the specified organization or re-activates the specified suspended organization. This method can be called by a network admin account. This can only be performed for the master organization and requires the majority of network admins to approve . Parameters \u00b6 orgId : string - organization ID action : number - 1 - for suspending the organization 2 - for activating the suspended organization Returns \u00b6 result : string - response message Example curl HTTP curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_updateOrgStatus\",\"params\":[\"ABC\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . updateOrgStatus ( \"ABC\" , 1 ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\" Privacy methods \u00b6 The following API methods provide functionality for GoQuorum privacy . Note Gas price is removed from GoQuorum networks , so is not included as a transaction object parameter in GoQuorum privacy methods. When using standard Ethereum JSON-RPC methods such as sendSignedTransaction , set gasPrice to 0. eth_distributePrivateTransaction \u00b6 Send a signed private transaction to the local private transaction manager and share with private participant\u2019s transaction managers. This API method is to be used as part of the process for sending externally signed privacy marker transactions . The private transaction should be signed, sent to participants with this API, and the resulting hash set as the PMT\u2019s data . Note Two step process: Performs the same as eth_sendRawPrivateTransaction (simulation and calling /sendsignedtx ), but doesn\u2019t submit private transaction to txpool. Sends the private transaction to Tessera to generate a hash, which should be placed in the privacy marker transaction. Parameters \u00b6 string - signed private transaction in hex format object - private data to send, with the following fields: privateFor : List<String> - an array of the recipients\u2019 base64-encoded public keys privateFrom : String - (optional) the sending party\u2019s base64-encoded public key to use (Privacy Manager default if not provided) privacyFlag : Number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : List<String> - an array of the recipients\u2019 base64-encoded public keys Returns \u00b6 string - Transaction Manager hash to be used as a privacy marker transaction\u2019s data when externally signing Example \u00b6 Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_distributePrivateTransaction\",\"params\":[\"0xf88d01808347b7608080b84034ec48699ce5877f0f97a5bea4550d52296368b1dcdc89667559555066c9894525e4878d0689cfeb4b6fda3dd6566aa06ce772f2e19e0404e45fe6351ebf640326a0ffecedc570d3520d283508f00d8b2c162096ebddca753979da95062c1df234cea033ceb36d46e3e86a399e8fde35b078248c90fb71344aadcc7e83b9324958a4ed\", {\"privateFor\": [\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : \"0xb33c67830588b746d7824e650d242bbe31a72018560f82ffe69692fd087c068c61bf3ed82c76ece771e11fef4a85035053911c6ae7589cac4c3e06ffc23da34c\" } geth console request web3 . eth . distributePrivateTransaction ( \"0xf88d01808347b7608080b84034ec48699ce5877f0f97a5bea4550d52296368b1dcdc89667559555066c9894525e4878d0689cfeb4b6fda3dd6566aa06ce772f2e19e0404e45fe6351ebf640326a0ffecedc570d3520d283508f00d8b2c162096ebddca753979da95062c1df234cea033ceb36d46e3e86a399e8fde35b078248c90fb71344aadcc7e83b9324958a4ed\" , { \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0xb33c67830588b746d7824e650d242bbe31a72018560f82ffe69692fd087c068c61bf3ed82c76ece771e11fef4a85035053911c6ae7589cac4c3e06ffc23da34c\" eth_fillTransaction \u00b6 Supports offline signing of the specified transaction. This can be used to fill and sign both public and private transactions. Defaults to RLP plus json . Parameters \u00b6 transaction : object - transaction object to send, with the following fields: from : string - address for the sending account to : string - (optional) destination address of the message value : number - (optional) value transferred for the transaction in Wei, also the endowment if it\u2019s a contract-creation transaction data : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code privateFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys Returns \u00b6 result : object - result object with the following fields: raw : data - RLP -encoded bytes for the passed transaction object tx : object - transaction object Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_fillTransaction\",\"params\":[{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"data\":\"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\",\"gas\":0x47b760,\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : { \"raw\" : \"0xf84d02808347b7608080b84075902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6258080\" , \"tx\" : { \"gas\" : \"0x47b760\" , \"gasPrice\" : \"0x0\" , \"hash\" : \"0xc0bbb6326ebafb7b0b18cf85d7b93e73ec8ae72b1c8d043d77d7ac5fecd9ccb5\" , \"input\" : \"0x75902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6\" , \"nonce\" : \"0x2\" , \"r\" : \"0x0\" , \"s\" : \"0x0\" , \"to\" : null , \"v\" : \"0x25\" , \"value\" : \"0x0\" } } } geth console request eth . fillTransaction ({ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"data\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" , \"gas\" : 0x47b760 , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result { \"raw\" : \"0xf84d02808347b7608080b84075902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6258080\" , \"tx\" : { \"gas\" : \"0x47b760\" , \"gasPrice\" : \"0x0\" , \"hash\" : \"0xc0bbb6326ebafb7b0b18cf85d7b93e73ec8ae72b1c8d043d77d7ac5fecd9ccb5\" , \"input\" : \"0x75902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6\" , \"nonce\" : \"0x2\" , \"r\" : \"0x0\" , \"s\" : \"0x0\" , \"to\" : null , \"v\" : \"0x25\" , \"value\" : \"0x0\" } } eth_getContractPrivacyMetadata \u00b6 Queries the privacy metadata for the specified contract account address. Parameter \u00b6 string - contract address Returns \u00b6 result : object - result object with the following fields: creationTxHash : data - affected contract\u2019s original transaction\u2019s encrypted payload hash privacyFlag : number - 0 for SP , 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : string - an array of the recipients\u2019 base64-encoded public keys Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getContractPrivacyMetadata\",\"params\":[\"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\"],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : { \"creationTxHash\" : \"0xf67c748bbed92110cb66510d413af99144b4434fa325771b6323f7f00c35192d2f861076f68061ed2d324f614edd2f0159Ba5ee2408bb42402a876c4b295598b7\" , \"mandatoryFor\" :[ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ] \"privacyFlag\" : 2 } } geth console request eth . getContractPrivacyMetadata ( \"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\" ); geth console result { \"creationTxHash\" : \"0xf67c748bbed92110cb66510d413af99144b4434fa325771b6323f7f00c35192d2f861076f68061ed2d324f614edd2f0159Ba5ee2408bb42402a876c4b295598b7\" , \"mandatoryFor\" :[ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], \"privacyFlag\" : 2 } eth_getPrivacyPrecompileAddress \u00b6 Get the address of the privacy precompile contract, to be used as the to address for privacy marker transactions . Parameters \u00b6 None Returns \u00b6 string - contract address for the privacy precompile in hex format Examples \u00b6 Example curl HTTP request curl -X POST http://localhost:22000 --data '{ \"jsonrpc\":\"2.0\", \"id\":2, \"method\":\"eth_getPrivacyPrecompileAddress\"}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 2 , \"result\" : \"0x000000000000000000000000000000000000007a\" } geth console request eth . getPrivacyPrecompileAddress (); geth console result \"0x000000000000000000000000000000000000007a\" eth_getPrivateTransactionByHash \u00b6 Retrieve the details of a privacy marker transaction \u2018s internal private transaction using the PMT\u2019s transaction hash. Parameters \u00b6 string - privacy marker transaction\u2019s hash in hex format Returns \u00b6 object - private transaction (nil if caller is not a participant) Examples \u00b6 Example curl HTTP request curl -X POST http://localhost:22000 --data '{ \"jsonrpc\":\"2.0\", \"id\":2, \"method\":\"eth_getPrivateTransactionByHash\", \"params\": [\"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\"]}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 2 , \"result\" :{ \"blockHash\" : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , \"blockNumber\" : \"0x5\" , \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"gas\" : \"0x47b760\" , \"gasPrice\" : \"0x0\" , \"hash\" : \"0x7cb8fbda0c76632ee801e27cc3ef5445378cf65cc0c36ffaf79b738c16d6ff18\" , \"input\" : \"0xc23a8cc005b977ff5b736f8fa670e3a68c0ce4c9609494a9d482d12b2bae9a5037fdad0164d0e6fd21527e20363507262e528eb3187a0f0a1f097eaaedc845b7\" , \"nonce\" : \"0x3\" , \"to\" : null , \"transactionIndex\" : \"0x0\" , \"value\" : \"0x0\" , \"v\" : \"0x25\" , \"r\" : \"0xef2562c04b2da7a90007068990b5279d6cb468e5347d40fe0aaa523485367bff\" , \"s\" : \"0x3530a3a6188cb0a3ebcfce29ada3ff3ed59976e6c88d1557f48554dfc0c3849e\" }} geth console request eth . getPrivateTransaction ( \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" ); geth console result { blockHash : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , blockNumber : 5 , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , gas : 4700000 , gasPrice : 0 , hash : \"0x7cb8fbda0c76632ee801e27cc3ef5445378cf65cc0c36ffaf79b738c16d6ff18\" , i n pu t : \"0xc23a8cc005b977ff5b736f8fa670e3a68c0ce4c9609494a9d482d12b2bae9a5037fdad0164d0e6fd21527e20363507262e528eb3187a0f0a1f097eaaedc845b7\" , n o n ce : 3 , r : \"0xef2562c04b2da7a90007068990b5279d6cb468e5347d40fe0aaa523485367bff\" , s : \"0x3530a3a6188cb0a3ebcfce29ada3ff3ed59976e6c88d1557f48554dfc0c3849e\" , t o : null , transa c t io n I n dex : 0 , v : \"0x25\" , value : 0 } eth_getPrivateTransactionReceipt \u00b6 Retrieve the receipt of a privacy marker transaction\u2019s (PMT) internal private transaction using the PMT\u2019s transaction hash. Parameters \u00b6 string - privacy marker transaction\u2019s hash in hex format Returns \u00b6 object - private transaction receipt (nil if caller is not a participant) Examples \u00b6 Example curl HTTP request curl -X POST http://localhost:22000 --data '{ \"jsonrpc\":\"2.0\", \"id\":2, \"method\":\"eth_getPrivateTransactionReceipt\", \"params\": [\"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\"]}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 2 , \"result\" :{ \"blockHash\" : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , \"blockNumber\" : \"0x5\" , \"contractAddress\" : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , \"cumulativeGasUsed\" : \"0x0\" , \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"gasUsed\" : \"0x0\" , \"logs\" :[], \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"status\" : \"0x1\" , \"to\" : null , \"transactionHash\" : \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" , \"transactionIndex\" : \"0x0\" }} geth console request eth . getPrivateTransactionReceipt ( \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" ); geth console result { blockHash : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , blockNumber : 5 , co ntra c t Address : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , cumula t iveGasUsed : 0 , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , gasUsed : 0 , logs : [], logsBloom : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , s tatus : \"0x1\" , t o : null , transa c t io n Hash : \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" , transa c t io n I n dex : 0 } eth_getPSI \u00b6 When using multiple private states , returns the private state the user is operating on. Parameters \u00b6 None Returns \u00b6 result : string - the private state identifier (PSI) Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getPSI\",\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"PS1\" } geth console request eth . getPSI geth console result \"PS1\" eth_getQuorumPayload \u00b6 Returns the unencrypted payload from Tessera . Parameters \u00b6 id : string - the generated SHA3-512 hash of the encrypted payload from the Private Transaction Manager, in hex (This is seen in the transaction as the input field.) Returns \u00b6 result : string - unencrypted transaction payload in hex format Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getQuorumPayload\",\"params\":[\"0x5e902fa2af51b186468df6ffc21fd2c26235f4959bf900fc48c17dc1774d86d046c0e466230225845ddf2cf98f23ede5221c935aac27476e77b16604024bade0\"],\"id\":67}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 67 , \"result\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" } geth console request eth . getQuorumPayload ( \"0x5e902fa2af51b186468df6ffc21fd2c26235f4959bf900fc48c17dc1774d86d046c0e466230225845ddf2cf98f23ede5221c935aac27476e77b16604024bade0\" ) geth console result \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" eth_sendRawPrivateTransaction \u00b6 Sends the specified pre-signed transaction, for example using SilentCicero/ethereumjs-accounts . If the transaction is a contract creation, use web3.eth.getTransactionReceipt() to get the contract address after the transaction is mined. Important Before calling this method, storeraw needs to be called to Tessera. Parameters \u00b6 string - signed transaction data in hex format object - private data to send, with the following fields: privateFor : array of strings - when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys privacyFlag : number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : array of strings - when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys callback : function - (optional) callback function; if you pass a callback, the HTTP request is made asynchronous. Returns \u00b6 result : string - 32-byte transaction hash as a hex string Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendRawPrivateTransaction\",\"params\":[\"0xf889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f\", {\"privateFor\": [\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : \"0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385\" } geth console request web3 . eth . sendRawPrivateTransaction ( \"0xf889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f\" , { \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385\" eth_sendTransaction \u00b6 Note To support private transactions in GoQuorum, the Web3js web3.eth.sendTransaction(object) API method has been modified to include private transaction parameters. Sends the specified transaction to the network. If the transaction is a contract creation, use web3.eth.getTransactionReceipt() ( eth_getTransactionReceipt ) to get the contract address after the transaction is mined. Parameters \u00b6 transaction : object - transaction object to send, with the following fields: from : string - address for the sending account; defaults to web3.eth.defaultAccount to : string - (optional) destination address of the message; defaults to undefined value : number - (optional) value transferred for the transaction in Wei, also the endowment if it\u2019s a contract-creation transaction gas : number - (optional) amount of gas to use for the transaction (unused gas is refunded) data : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code input : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code nonce : number - (optional) integer of a nonce; allows you to overwrite your own pending transactions that use the same nonce privateFrom : string - (optional) when sending a private transaction, the sending party\u2019s base64-encoded public key to use; if not present and passing privateFor , use the default key as configured in the TransactionManager . privateFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys privacyFlag : number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys callback : function - (optional) callback function; if you pass a callback, the HTTP request is made asynchronous. Note input cannot co-exist with data if they are set to different values. input is the new naming of data . They are the same parameters, but both remain for backwards compatibility. Returns \u00b6 result : string - 32-byte transaction hash as a hex string Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getContractPrivacyMetadata\",\"params\":[{\"data\":\"603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3\",\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : \"0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385\" } geth console request web3 . eth . sendTransaction ({ \"data\" : \"603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3\" , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385\" eth_sendTransactionAsync \u00b6 Sends the specified transaction to the network asynchronously. This returns immediately, potentially before the transaction has been submitted to the transaction pool. A callback can be provided to receive the result of submitting the transaction; a server must be set up to receive POST requests at the given URL. If the transaction is a contract creation, use web3.eth.getTransactionReceipt() to get the contract address after the transaction is mined. Parameters \u00b6 transaction : object - transaction object to send, with the following fields: from : string - address for the sending account; defaults to web3.eth.defaultAccount to : string - (optional) destination address of the message; defaults to undefined value : number - (optional) value transferred for the transaction in Wei, also the endowment if it\u2019s a contract-creation transaction gas : number - (optional) amount of gas to use for the transaction (unused gas is refunded) data : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code input : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code nonce : number - (optional) integer of a nonce; allows you to overwrite your own pending transactions that use the same nonce privateFrom : string - (optional) when sending a private transaction, the sending party\u2019s base64-encoded public key to use; if not present and passing privateFor , use the default key as configured in the TransactionManager . privateFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys privacyFlag : number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys callbackUrl : string - (optional) URL to perform a POST request to post the result of submitting the transaction Note input cannot co-exist with data if they are set to different values. input is the new naming of data . They are the same parameters, but both remain for backwards compatibility. Returns \u00b6 result : string - empty hash, defined as 0x0000000000000000000000000000000000000000000000000000000000000000 The callback URL receives the following object: result : object - result object with the following fields: id : string - ID in the original RPC call, used to match this result to the request txHash : string - transaction hash that was generated, if successful error : string - error that occurred while submitting the transaction Example The call and the immediate response: curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransactionAsync\",\"params\":[{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"data\":\"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\",\"gas\":\"0x47b760\",\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":67}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 67 , \"result\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } geth console request eth . sendTransactionAsync ({ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"data\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" , \"gas\" : \"0x47b760\" , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0x0000000000000000000000000000000000000000000000000000000000000000\" If you provide the callback URL, you receive the following response after submitting the transaction. This example assumes a webserver that can be accessed by calling http://localhost:8080 has been set up to accept POST requests: curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransactionAsync\",\"params\":[{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"data\":\"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\",\"gas\":\"0x47b760\",\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"],\"callbackUrl\":\"http://localhost:8080\"}],\"id\":67}' JSON result { \"id\" : 67 , \"txHash\" : \"0x75ebbf4fbe29355fc8a4b8d1e14ecddf0228b64ef41e6d2fce56047650e2bf17\" } geth console request eth . sendTransactionAsync ({ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"data\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" , \"gas\" : \"0x47b760\" , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], \"callbackUrl\" : \"http://localhost:8080\" }) geth console result { \"id\" : 67 , \"txHash\" : \"0x75ebbf4fbe29355fc8a4b8d1e14ecddf0228b64ef41e6d2fce56047650e2bf17\" } eth_storageRoot \u00b6 Returns the storage root hash of the specified address. If the contract is a private contract , returns the storage root hash from the private state database. Parameters \u00b6 address : String - address to fetch the storage root from in hex block : string - (optional) block number to fetch the storage root from in hex; defaults to the latest block Returns \u00b6 result : string - 32-byte storage root hash as a hex string Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_storageRoot\",\"params\":[\"0x1349f3e1b8d71effb47b840594ff27da7e603d17\",\"0x1\"],\"id\":67}' JSON result { \"jsonrpc\" : \"2.0\" \"id\" : 67 , \"result\" : \"0x81d1fa699f807735499cf6f7df860797cf66f6a66b565cfcda3fae3521eb6861\" } geth console request eth . storageRoot ( \"0x1349f3e1b8d71effb47b840594ff27da7e603d17\" , \"0x1\" ) geth console result \"0x81d1fa699f807735499cf6f7df860797cf66f6a66b565cfcda3fae3521eb6861\" Raft methods \u00b6 The following API methods provide access to the Raft consensus engine. raft_addLearner \u00b6 Adds a new node to the network as a learner node. The learner node syncs with the network and can transact, but isn\u2019t part of the Raft cluster and doesn\u2019t provide block confirmation to the minter node. Parameters \u00b6 enodeId : string - enode ID of the node to add Returns \u00b6 result : string - Raft ID for the node being added Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_addLearner\",\"params\":[\"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : 5 } geth console request raft . addLearner ( \"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\" ) geth console result 5 raft_addPeer \u00b6 Adds a new peer to the network. Parameters \u00b6 enodeId : string - enode ID of the node to be added to the network Returns \u00b6 result : string - Raft ID for the node being added, or an error message if the node is already part of the network Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_addPeer\",\"params\":[\"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : 5 } geth console request raft . addPeer ( \"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\" ) geth console result 5 raft_cluster \u00b6 Returns the details of all nodes part of the Raft cluster. Parameters \u00b6 None Returns \u00b6 result : array - list of node objects with the following fields: hostName : string - DNS name or the host IP address nodeActive : boolean - indicates if the node is active in the Raft cluster nodeId : string - enode ID of the node p2pPort : number - p2p port raftId : string - Raft ID of the node raftPort : number - Raft port role : string - role of the node in the Raft cluster (minter/verifier/learner); \"\" if there is no leader at the network level Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_cluster\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : [{ \"raftId\" : 1 , \"nodeId\" : \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" , \"p2pPort\" : 21000 , \"raftPort\" : 50401 , \"hostname\" : \"127.0.0.1\" , \"role\" : \"minter\" , \"nodeActive\" : true }, { \"raftId\" : 3 , \"nodeId\" : \"579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778\" , \"p2pPort\" : 21002 , \"raftPort\" : 50403 , \"hostname\" : \"127.0.0.1\" , \"role\" : \"verifier\" , \"nodeActive\" : true }, { \"raftId\" : 2 , \"nodeId\" : \"0ba6b9f606a43a95edc6247cdb1c1e105145817be7bcafd6b2c0ba15d58145f0dc1a194f70ba73cd6f4cdd6864edc7687f311254c7555cc32e4d45aeb1b80416\" , \"p2pPort\" : 21001 , \"raftPort\" : 50402 , \"hostname\" : \"127.0.0.1\" , \"role\" : \"verifier\" , \"nodeActive\" : true }] } geth console request raft . cluster geth console result [{ \"hostname\" : \"127.0.0.1\" , \"nodeActive\" : true , \"nodeId\" : \"0ba6b9f606a43a95edc6247cdb1c1e105145817be7bcafd6b2c0ba15d58145f0dc1a194f70ba73cd6f4cdd6864edc7687f311254c7555cc32e4d45aeb1b80416\" , \"p2pPort\" : 21001 , \"raftId\" : 2 , \"raftPort\" : 50402 , \"role\" : \"verifier\" }, { \"hostname\" : \"127.0.0.1\" , \"nodeActive\" : true , \"nodeId\" : \"579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778\" , \"p2pPort\" : 21002 , \"raftId\" : 3 , \"raftPort\" : 50403 , \"role\" : \"verifier\" }, { \"hostname\" : \"127.0.0.1\" , \"nodeActive\" : true , \"nodeId\" : \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" , \"p2pPort\" : 21000 , \"raftId\" : 1 , \"raftPort\" : 50401 , \"role\" : \"minter\" }] raft_leader \u00b6 Returns the enode ID of the leader node. Parameters \u00b6 None Returns \u00b6 result : string - enode ID of the leader, or an error message if there is no leader Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_leader\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" } geth console request raft . leader geth console result \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" raft_promoteToPeer \u00b6 Promotes the specified learner node to peer and thus to be part of the Raft cluster. Parameters \u00b6 raftId : string - Raft ID of the node to be promoted Returns \u00b6 result : boolean - indicates if the node is promoted Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_promoteToPeer\",\"params\":[4],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : true } geth console request raft . promoteToPeer ( 4 ) geth console result true raft_removePeer \u00b6 Removes the specified peer from the Raft cluster. Parameters \u00b6 raftId : string - Raft ID of the peer to be removed from the cluster Returns \u00b6 result : null Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_removePeer\",\"params\":[4],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : null } geth console request raft . removePeer ( 4 ) geth console result null raft_role \u00b6 Returns the role of the current node in the Raft cluster. Parameters \u00b6 None Returns \u00b6 result : string - role of the node in the Raft cluster (minter/verifier/learner); \"\" if there is no leader at the network level Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_role\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"verifier\" } geth console request raft . role geth console result \"minter\"","title":"GoQuorum API methods"},{"location":"reference/api-methods/#goquorum-api-methods","text":"This reference describes the GoQuorum JSON-RPC API methods. Important GoQuorum is based on Geth Go Ethereum client but only the GoQuorum-specific API methods are listed here. Visit the Go Ethereum documentation to view the Geth API methods.","title":"GoQuorum API methods"},{"location":"reference/api-methods/#contract-extension-methods","text":"The following API methods provide functionality for GoQuorum contract extension .","title":"Contract extension methods"},{"location":"reference/api-methods/#quorumextension_activeextensioncontracts","text":"Lists all active contract extensions involving this node (either as initiator or receiver).","title":"quorumExtension_activeExtensionContracts"},{"location":"reference/api-methods/#parameters","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns","text":"result : array of objects - list of contract extension objects with the following fields: managementContractAddress : string - address of the extension management contract contractExtended : string - address of the private contract getting extended creationData : data - Tessera hash of creation data for extension management contract initiator : string - contract extension initiator\u2019s Ethereum address recipient : string - new participant\u2019s Ethereum address; the participant must later approve the extension using this address. recipientPtmKey : string - new participant\u2019s Tessera public key Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_activeExtensionContracts\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : [{ \"managementContractAddress\" : \"0xc4e9de0bd5e0a5fd55ef5d6f2b46eba930a694a3\" , \"contractExtended\" : \"0x027692c7ebdc81c590250e615ab571a0d14eff2d\" , \"creationData\" : \"Zvo1Rnrfq4phIJbzKObyCBWSXTbEJGPOq5+jDCWccnPpA7K6OvIssCMLJ54f32uuEeczeVNC46QMk52lCOWbtg==\" , \"initiator\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"recipient\" : \"0x0fbdc686b912d7722dc86510934589e0aaf3b55a\" , \"recipientPtmKey\" : \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" }] } geth console request quorumExtension . activeExtensionContracts geth console result [{ \"managementContractAddress\" : \"0xc4e9de0bd5e0a5fd55ef5d6f2b46eba930a694a3\" , \"contractExtended\" : \"0x027692c7ebdc81c590250e615ab571a0d14eff2d\" , \"creationData\" : \"Zvo1Rnrfq4phIJbzKObyCBWSXTbEJGPOq5+jDCWccnPpA7K6OvIssCMLJ54f32uuEeczeVNC46QMk52lCOWbtg==\" , \"initiator\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"recipient\" : \"0x0fbdc686b912d7722dc86510934589e0aaf3b55a\" , \"recipientPtmKey\" : \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" }]","title":"Returns"},{"location":"reference/api-methods/#quorumextension_approveextension","text":"Submits an approval/denial vote to the specified extension management contract.","title":"quorumExtension_approveExtension"},{"location":"reference/api-methods/#parameters_1","text":"addressToVoteOn : string - address of the contract extension\u2019s management contract (this can be found using quorumExtension_activeExtensionContracts ) vote : boolean - true approves the extension process, false cancels the extension process txArgs : object - arguments for the vote submission transaction; privateFor must contain the public key of the node that initiated the contract extension.","title":"Parameters"},{"location":"reference/api-methods/#returns_1","text":"result : data - hash of the vote submission transaction Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_approveExtension\",\"params\":[\"0xb1c57951a2f3006910115eadf0f167890e99b9cb\",true,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"privateFor\":[\"QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc=\"]}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"0x8d34a594b286087f45029daad2d5a8fd42f70abb0ae2492429a256a2ba4cb0dd\" } geth console request quorumExtension . approveExtension ( \"0xb1c57951a2f3006910115eadf0f167890e99b9cb\" , true ,{ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"privateFor\" : [ \"QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc=\" ]}) geth console result \"0x8d34a594b286087f45029daad2d5a8fd42f70abb0ae2492429a256a2ba4cb0dd\" Frequent issues If you attempt to extend a contract in the process of being extended, the following error is returned: Error: contract extension in progress for the given contract address The recipient can approve the extension only once. Executing quorumExtension.approveExtension once the extension process is completed results in the following error: Error: contract extension process complete. nothing to accept The approver (the from address in txArgs ) must be the receiver of the extension ( recipientAddress from quorumExtension_extendContract ): Error: account is not acceptor of this extension request","title":"Returns"},{"location":"reference/api-methods/#quorumextension_cancelextension","text":"Cancels the specified active contract extension. This can only be invoked by the initiator of the extension process (the caller of quorumExtension_extendContract ).","title":"quorumExtension_cancelExtension"},{"location":"reference/api-methods/#parameters_2","text":"extensionContract : string - address of the contract extension\u2019s management contract txArgs : object - arguments for the cancellation transaction","title":"Parameters"},{"location":"reference/api-methods/#returns_2","text":"result : data - hash of the cancellation transaction Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_cancelExtension\",\"params\":[\"0x622aff909c081783613c9d3f5f4c47be78b310ac\",{\"from\":\"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\",\"value\":\"0x0\",\"privateFor\":[\"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\"],\"privacyFlag\":1}],\"id\":63}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"0xb43da7dbeae5347df86c6933786b8c536b4622463b577a990d4c87214845d16a\" } geth console request quorumExtension . cancelExtension ( \"0x622aff909c081783613c9d3f5f4c47be78b310ac\" ,{ \"from\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"value\" : \"0x0\" , \"privateFor\" : [ \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\" ]}) geth console result \"0xb43da7dbeae5347df86c6933786b8c536b4622463b577a990d4c87214845d16a\" Frequent issues The canceller ( from address in txArgs ) must be the same as the initiator of the extension (the from address in txArgs for the quorumExtension_extendContract call) or the following error is returned: Error: account is not the creator of this extension request","title":"Returns"},{"location":"reference/api-methods/#quorumextension_extendcontract","text":"Starts the process of extending an existing private contract to a new participant by deploying a new extension management contract to the blockchain.","title":"quorumExtension_extendContract"},{"location":"reference/api-methods/#parameters_3","text":"toExtend : string - address of the private contract to extend newRecipientPtmPublicKey : string - new participant\u2019s Tessera public key recipientAddress : string - new participant\u2019s Ethereum address; the participant must later approve the extension using this address. txArgs : object - arguments for the transaction that deploys the extension management contract; privateFor must contain only the newRecipientPtmPublicKey .","title":"Parameters"},{"location":"reference/api-methods/#returns_3","text":"result : data - hash of the creation transaction for the new extension management contract Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_extendContract\",\"params\":[\"0x9aff347f193ca4560276c3322193224dcdbbe578\",\"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\",\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",{\"from\":\"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\",\"value\":\"0x0\",\"privateFor\":[\"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\"],\"privacyFlag\":1}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"0xceffe8051d098920ac84e33b8a05c48180ed9b26581a6a06ce9874a1bf1502bd\" } geth console request quorumExtension . extendContract ( \"0x9aff347f193ca4560276c3322193224dcdbbe578\" , \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\" , \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" ,{ from : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"privateFor\" : [ \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\" ]}) geth console result \"0xceffe8051d098920ac84e33b8a05c48180ed9b26581a6a06ce9874a1bf1502bd\" Frequent issues If you attempt to extend a contract in the process of being extended, the following error is returned: Error: contract extension in progress for the given contract address You must execute quorumExtension_extendContract from the node that initially created the contract. If the network is using enhanced network permissioning , then both initiator (the from address in txArgs ) and receiver ( recipientAddress ) of the extension must be network or org admin accounts.","title":"Returns"},{"location":"reference/api-methods/#quorumextension_getextensionstatus","text":"Retrieves the status of the specified contract extension.","title":"quorumExtension_getExtensionStatus"},{"location":"reference/api-methods/#parameters_4","text":"managementContractAddress : string - address of the extension management contract","title":"Parameters"},{"location":"reference/api-methods/#returns_4","text":"result : string - status of contract extension ( ACTIVE or DONE ) Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumExtension_getExtensionStatus\",\"params\":[\"0x1349f3e1b8d71effb47b840594ff27da7e603d17\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"DONE\" } geth console request quorumExtension . getExtensionStatus ( \"0x1349f3e1b8d71effb47b840594ff27da7e603d17\" ) geth console result \"DONE\"","title":"Returns"},{"location":"reference/api-methods/#debug-methods","text":"The following API methods allow you to inspect and debug the network.","title":"Debug methods"},{"location":"reference/api-methods/#debug_dumpaddress","text":"Retrieves the state of an address at the specified block number.","title":"debug_dumpAddress"},{"location":"reference/api-methods/#parameters_5","text":"address : string - account address of the state to retrieve blockNumber : number - integer representing a block number or one of the string tags latest (the last block mined) or pending (the last block mined plus pending transactions)","title":"Parameters"},{"location":"reference/api-methods/#returns_5","text":"result : object - state of the account address Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"debug_dumpAddress\",\"params\":[\"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\",10],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : { \"balance\" : \"49358640978154672\" , \"code\" : \"\" , \"codeHash\" : \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" , \"nonce\" : 2 , \"root\" : \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"storage\" :{} } } geth console request ```javascript debug.dumpAddress(\u201c0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\u201d,10) geth console result { \"balance\" : \"49358640978154672\" , \"code\" : \"\" , \"codeHash\" : \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" , \"nonce\" : 2 , \"root\" : \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"storage\" :{} }","title":"Returns"},{"location":"reference/api-methods/#debug_privatestateroot","text":"Returns the private state root hash at the specified block number.","title":"debug_privateStateRoot"},{"location":"reference/api-methods/#parameters_6","text":"blockNumber : number - integer representing a block number or one of the string tags latest (the last block mined) or pending (the last block mined plus pending transactions).","title":"Parameters"},{"location":"reference/api-methods/#returns_6","text":"result : data - private state root hash Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"debug_privateStateRoot\",\"params\":[\"latest\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" } geth console request debug . privateStateRoot ( \"latest\" ) geth console result \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"","title":"Returns"},{"location":"reference/api-methods/#ibft-methods","text":"The following API methods provide access to the IBFT and QBFT consensus engines. To use these methods: Run Istanbul geth with --http.api \"istanbul\" . Run geth attach .","title":"IBFT methods"},{"location":"reference/api-methods/#istanbul_candidates","text":"Returns the current candidates which the node tries to vote in or out.","title":"istanbul_candidates"},{"location":"reference/api-methods/#parameters_7","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_7","text":"result : map of strings to booleans - current candidates map Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_candidates\",\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" : true } } geth console request istanbul . candidates geth console result { \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" : true }","title":"Returns"},{"location":"reference/api-methods/#istanbul_discard","text":"Drops a currently running candidate, stopping further votes from being cast either for or against the candidate.","title":"istanbul_discard"},{"location":"reference/api-methods/#parameters_8","text":"address : string - address of the candidate","title":"Parameters"},{"location":"reference/api-methods/#returns_8","text":"result : null Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_discard\",\"params\":[\"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : null } geth console request istanbul . discard ( \"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181\" ) geth console result null","title":"Returns"},{"location":"reference/api-methods/#istanbul_getsignersfromblock","text":"Retrieves the public addresses whose seals are included in the specified block number. This means that they participated in the consensus for this block and attested to its validity.","title":"istanbul_getSignersFromBlock"},{"location":"reference/api-methods/#parameters_9","text":"blockNumber : number - (optional) block number to retrieve; defaults to current block","title":"Parameters"},{"location":"reference/api-methods/#returns_9","text":"result : object - result object with the following fields: number : number - retrieved block\u2019s number hash : string - retrieved block\u2019s hash author : string - address of the block proposer committers : array of strings - list of all addresses whose seal appears in this block Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSignersFromBlock\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"number\" : 10 , \"hash\" : \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" , \"author\" : \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"committers\" : [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } } geth console request istanbul . getSignersFromBlock ( 10 ) == \u201cgeth console result\u201d ```js { \"number\":10, \"hash\":\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\", \"author\":\"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\", \"committers\": [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\", \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } ```","title":"Returns"},{"location":"reference/api-methods/#istanbul_getsignersfromblockbyhash","text":"Retrieves the public addresses whose seals are included in the specified block number. This means that they participated in the consensus for this block and attested to its validity.","title":"istanbul_getSignersFromBlockByHash"},{"location":"reference/api-methods/#parameters_10","text":"blockHash : string - hash of the block to retrieve (required)","title":"Parameters"},{"location":"reference/api-methods/#returns_10","text":"result : object - result object with the following fields: number : number - retrieved block\u2019s number hash : string - retrieved block\u2019s hash author : string - address of the block proposer committers : array of strings - list of all addresses whose seal appears in this block Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSignersFromBlockByHash\",\"params\":[\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"number\" : 10 , \"hash\" : \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" , \"author\" : \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"committers\" : [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } } geth console request istanbul . getSignersFromBlockByHash ( \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" ) geth console result { \"number\" : 10 , \"hash\" : \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" , \"author\" : \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"committers\" : [ \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] }","title":"Returns"},{"location":"reference/api-methods/#istanbul_getsnapshot","text":"Retrieves the state snapshot at the specified block number.","title":"istanbul_getSnapshot"},{"location":"reference/api-methods/#parameters_11","text":"blockNumber : number or string - (optional) integer representing a block number or the string tag latest (the last block mined); defaults to latest","title":"Parameters"},{"location":"reference/api-methods/#returns_11","text":"result : object - snapshot object Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSnapshot\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"epoch\" : 30000 , \"number\" : 16 , \"hash\" : \"0x2d7df0a0dc7b1136687bb5a8b7ca3e7b00414a8f8d3a9c756ff59c49b78ce08e\" , \"votes\" :[], \"tally\" :{}, \"validators\" : [ \"0x6571d97f340c8495b661a823f2c2145ca47d63c2\" , \"0xd8dba507e85f116b1f7e231ca8525fc9008a6966\" , \"0xe36cbeb565b061217930767886474e3cde903ac5\" , \"0xf512a992f3fb749857d758ffda1330e590fa915e\" ], \"policy\" : 0 } } geth console request istanbul . getSnapshot ( 10 ) geth console result { \"epoch\" : 30000 , \"number\" : 16 , \"hash\" : \"0x2d7df0a0dc7b1136687bb5a8b7ca3e7b00414a8f8d3a9c756ff59c49b78ce08e\" , \"votes\" : [], \"tally\" : {}, \"validators\" : [ \"0x6571d97f340c8495b661a823f2c2145ca47d63c2\" , \"0xd8dba507e85f116b1f7e231ca8525fc9008a6966\" , \"0xe36cbeb565b061217930767886474e3cde903ac5\" , \"0xf512a992f3fb749857d758ffda1330e590fa915e\" ], \"policy\" : 0 }","title":"Returns"},{"location":"reference/api-methods/#istanbul_getsnapshotathash","text":"Retrieves the state snapshot at the specified block hash.","title":"istanbul_getSnapshotAtHash"},{"location":"reference/api-methods/#parameters_12","text":"blockHash : string - block hash","title":"Parameters"},{"location":"reference/api-methods/#returns_12","text":"result : object - snapshot object Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getSnapshotAtHash\",\"params\":[\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { } } geth console request istanbul . getSnapshotAtHash ( \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" ) geth console result {}","title":"Returns"},{"location":"reference/api-methods/#istanbul_getvalidators","text":"Retrieves the list of authorized validators at the specified block number.","title":"istanbul_getValidators"},{"location":"reference/api-methods/#parameters_13","text":"blockNumber : number or string - (optional) integer representing a block number or the string tag latest (the last block mined); defaults to latest","title":"Parameters"},{"location":"reference/api-methods/#returns_13","text":"result : array of strings - list of validator addresses Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getValidators\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } geth console request istanbul . getValidators ( 10 ) geth console result [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ]","title":"Returns"},{"location":"reference/api-methods/#istanbul_getvalidatorsathash","text":"Retrieves the list of authorized validators at the specified block hash.","title":"istanbul_getValidatorsAtHash"},{"location":"reference/api-methods/#parameters_14","text":"blockHash : string - block hash","title":"Parameters"},{"location":"reference/api-methods/#returns_14","text":"result : array of strings - list of validator addresses Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_getValidatorsAtHash\",\"params\":[\"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\"],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ] } geth console request istanbul . getValidatorsAtHash ( \"0xfe88c94d860f01a17f961bf4bdfb6e0c6cd10d3fda5cc861e805ca1240c58553\" ) geth console result [ \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" , \"0xdc25ef3F5b8a186998338a2ada83795fba2d695\" ]","title":"Returns"},{"location":"reference/api-methods/#istanbul_isvalidator","text":"Indicates if this node is the validator for the specified block number.","title":"istanbul_isValidator"},{"location":"reference/api-methods/#parameters_15","text":"blockNumber : number - (optional) block number; defaults to latest block number","title":"Parameters"},{"location":"reference/api-methods/#returns_15","text":"result : boolean - true if this node is the validator for the given blockNumber , otherwise false Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_isValidator\",\"params\":[10],\"id\":1}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : true } geth console request istanbul . isValidator ( 10 ) geth console result true","title":"Returns"},{"location":"reference/api-methods/#istanbul_nodeaddress","text":"Retrieves the public address that is used to sign proposals, which is derived from the node\u2019s nodekey .","title":"istanbul_nodeAddress"},{"location":"reference/api-methods/#parameters_16","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_16","text":"result : string - node\u2019s public signing address Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_nodeAddress\",\"id\":1}' --header \"Content-Type: application/json\" JSON result ```JSON { \u201cjsonrpc\u201d:\u201d2.0\u201d, \u201cid\u201d:1, \u201cresult\u201d:\u201d0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\u201d } geth console request istanbul . nodeAddress () geth console result \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\"","title":"Returns"},{"location":"reference/api-methods/#istanbul_propose","text":"Injects a new authorization candidate that the validator attempts to push through. If a majority of the validators vote the candidate in/out, the candidate is added/removed in the validator set.","title":"istanbul_propose"},{"location":"reference/api-methods/#parameters_17","text":"address : string - address of candidate auth : boolean - true votes the candidate in and false votes out","title":"Parameters"},{"location":"reference/api-methods/#returns_17","text":"result : null Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_propose\",\"params\":[\"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\",true],\"id\":1}' --header \"Content-Type: application/json\" JSON result ```JSON { \u201cjsonrpc\u201d:\u201d2.0\u201d, \u201cid\u201d:1, \u201cresult\u201d:null } geth console request istanbul . propose ( \"0x9811ebc35d7b06b3fa8dc5809a1f9c52751e1deb\" , true ) geth console result null","title":"Returns"},{"location":"reference/api-methods/#istanbul_status","text":"Returns the signing status of blocks for the specified block range.","title":"istanbul_status"},{"location":"reference/api-methods/#parameters_18","text":"startBlockNumber : number - start block number endBlockNumber : number - end block number If the start block and end block numbers are not provided, the status of the last 64 blocks is returned.","title":"Parameters"},{"location":"reference/api-methods/#returns_18","text":"result : object - result object with the following fields: numBlocks : number - number of blocks for which sealer activity is retrieved sealerActivity : map of strings to numbers - key is the validator and value is the number of blocks sealed by the validator Example curl HTTP request curl -X POST http://localhost:8545 --data '{\"jsonrpc\":\"2.0\",\"method\":\"istanbul_status\",\"params\":[1,10],\"id\":1}' --header \"Content-Type: application/json\" JSON result ```JSON { \u201cjsonrpc\u201d:\u201d2.0\u201d, \u201cid\u201d:1, \u201cresult\u201d: { \u201cnumBlocks\u201d:2, \u201csealerActivity\u201d: { \u201c0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\u201d: 3, \u201c0x71c7656ec7ab88b098defb751b7401b5f6d8976f\u201d: 1 } } } geth console request istanbul . status ( 1 , 10 ) geth console result { \"numblocks\" : 2 , \"sealerActivity\" : { \"0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7\" : 3 , \"0x71c7656ec7ab88b098defb751b7401b5f6d8976f\" : 1 } }","title":"Returns"},{"location":"reference/api-methods/#permission-methods","text":"The following API methods provide functionality for GoQuorum permissioning .","title":"Permission methods"},{"location":"reference/api-methods/#quorumpermission_acctlist","text":"Returns a list of permissioned accounts in the network.","title":"quorumPermission_acctList"},{"location":"reference/api-methods/#parameters_19","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_19","text":"result : array of objects - list of permissioned account objects with the following fields: acctId : string - account ID isOrgAdmin : boolean - indicates if the account is admin account for the organization orgId : string - organization ID roleId : string - role assigned to the account status : number - account status Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_acctList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 53 , \"result\" : [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }] } geth console request quorumPermission . acctList geth console result [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }]","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_addaccounttoorg","text":"Adds an account to an organization and assigns a role to the account. This method can be called by an organization admin account. The account can only be linked to a single organization or sub-organization.","title":"quorumPermission_addAccountToOrg"},{"location":"reference/api-methods/#parameters_20","text":"acctId : string - account ID orgId : string - organization ID roleId : string - role ID","title":"Parameters"},{"location":"reference/api-methods/#returns_20","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addAccountToOrg\",\"params\":[\"0xf017976fdf1521de2e108e63b423380307f501f8\",\"ABC\",\"TRANSACT\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addAccountToOrg ( \"0xf017976fdf1521de2e108e63b423380307f501f8\" , \"ABC\" , \"TRANSACT\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_addnewrole","text":"Creates a new role for the organization. This method can be called by an organization admin account.","title":"quorumPermission_addNewRole"},{"location":"reference/api-methods/#parameters_21","text":"orgId : string - organization ID for which the role is being created roleId : string - unique role ID accountAccess : number - account level access isVoter : boolean - indicates if the role is a voting role isAdminRole : boolean - indicates if the role is an admin role Note When adding a new role to a sub-organization, the role ID must exist in the master organization under which the sub-organization falls.","title":"Parameters"},{"location":"reference/api-methods/#returns_21","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addNewRole\",\"params\":[\"ABC\",\"TRANSACT\",1,false,false,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addNewRole ( \"ABC\" , \"TRANSACT\" , 1 , false , false ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_addnode","text":"Adds a node to the specified organization or sub-organization. This method can be called by an organization admin account. A node cannot be part of multiple organizations.","title":"quorumPermission_addNode"},{"location":"reference/api-methods/#parameters_22","text":"orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID","title":"Parameters"},{"location":"reference/api-methods/#returns_22","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addNode\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addNode ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_addorg","text":"Proposes a new organization into the network. This method can be called by a network admin account. If there are any pending items for approval, proposal of any new organization fails. Also, the enode ID and account ID can only be linked to one organization.","title":"quorumPermission_addOrg"},{"location":"reference/api-methods/#parameter","text":"orgId : string - unique organization ID enodeId : string - complete enode ID accountId : string - account to be the organization admin account","title":"Parameter"},{"location":"reference/api-methods/#returns_23","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addOrg\",\"params\":[\"ABC\",\"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\",\"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addOrg ( \"ABC\" , \"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" ,{ from : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_addsuborg","text":"Creates a sub-organization under the master organization. This method can be called by an organization admin account.","title":"quorumPermission_addSubOrg"},{"location":"reference/api-methods/#parameters_23","text":"parentOrgId : string - parent organization ID under which the sub-organization is being added Note The parent organization ID should contain the complete organization hierarchy from master organization ID to the immediate parent. The organization hierarchy is separated by . (dot character). For example, if master organization ABC has a sub-organization SUB1 , then while creating the sub-organization at SUB1 level, the parent organization should be given as ABC.SUB1 . subOrgId : string - sub-organization ID enodeId : string - complete enode ID of the node linked to the sub-organization ID; if left as an empty string, inherits the enode ID from the parent organization.","title":"Parameters"},{"location":"reference/api-methods/#returns_24","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_addSubOrg\",\"params\":[\"ABC.SUB1\",\"SUB2\",\"\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . addSubOrg ( \"ABC.SUB1\" , \"SUB2\" , \"\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_approveadminrole","text":"Approves the organization admin or network admin role assignment to the specified account. This method can be called by a network admin account. The role is approved once the majority of network admins approve.","title":"quorumPermission_approveAdminRole"},{"location":"reference/api-methods/#parameters_24","text":"orgId : string - organization ID to which the account belongs acctId : string - account ID","title":"Parameters"},{"location":"reference/api-methods/#returns_25","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveAdminRole\",\"params\":[\"ABC\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveAdminRole ( \"ABC\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_approveblacklistedaccountrecovery","text":"Approves the recovery of the specified denylisted (blacklisted) account . This method can be called by a network admin account. Once a majority of the network admins approve, the account is marked as active.","title":"quorumPermission_approveBlackListedAccountRecovery"},{"location":"reference/api-methods/#parameters_25","text":"orgId : string - organization or sub-organization ID to which the node belongs acctId : string - denylisted account ID","title":"Parameters"},{"location":"reference/api-methods/#returns_26","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveBlackListedNodeRecovery\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveBlackListedNodeRecovery ( \"ABC.SUB1.SUB2.SUB3\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_approveblacklistednoderecovery","text":"Approves the recovery of the specified denylisted (blacklisted) node . This method can be called by a network admin account. Once the majority of network admins approve, the denylisted node is marked as active.","title":"quorumPermission_approveBlackListedNodeRecovery"},{"location":"reference/api-methods/#parameters_26","text":"orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID","title":"Parameters"},{"location":"reference/api-methods/#returns_27","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveBlackListedNodeRecovery\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveBlackListedNodeRecovery ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_approveorg","text":"Approves the specified proposed organization into the network. This method can be called by a network admin account.","title":"quorumPermission_approveOrg"},{"location":"reference/api-methods/#parameters_27","text":"orgId : string - unique organization ID enodeId : string - complete enode ID accountId : string - account to be the organization admin account","title":"Parameters"},{"location":"reference/api-methods/#returns_28","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveOrg\",\"params\":[\"ABC\",\"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\",\"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveOrg ( \"ABC\" , \"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\" , \"0x0638e1574728b6d862dd5d3a3e0942c3be47d996\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_approveorgstatus","text":"Approves an organization status change proposal . This method can be called by a network admin account. Once a majority of the network admins approve the status update, the organization status is updated. When an organization is in suspended status, no transactions or contract deployment activities are allowed from any nodes linked to the organization and sub-organizations under it. Similarly, no transactions are allowed from any accounts linked to the organization.","title":"quorumPermission_approveOrgStatus"},{"location":"reference/api-methods/#parameters_28","text":"orgId : string - organization ID action : number - 1 - for approving organization suspension 2 - for approving activation of the suspended organization","title":"Parameters"},{"location":"reference/api-methods/#returns_29","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_approveOrgStatus\",\"params\":[\"ABC\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . approveOrgStatus ( \"ABC\" , 1 ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_assignadminrole","text":"Adds a new account as network admin or changes the organization admin account for an organization. This method can be called by a network admin account. Once a majority of the network admins approve , the role is approved.","title":"quorumPermission_assignAdminRole"},{"location":"reference/api-methods/#parameters_29","text":"orgId : string - organization ID to which the account belongs acctId : string - account ID roleId : string - new role ID to be assigned to the account; this can be the network admin role or an organization admin role only.","title":"Parameters"},{"location":"reference/api-methods/#returns_30","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_assignAdminRole\",\"params\":[\"ABC\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",\"NWADMIN\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . assignAdminRole ( \"ABC\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" , \"NWADMIN\" ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_changeaccountrole","text":"Assigns a role to the specified account. This method can be called by an organization admin account.","title":"quorumPermission_changeAccountRole"},{"location":"reference/api-methods/#parameters_30","text":"acctId : string - account ID orgId : string - organization ID roleId : string - new role ID to be assigned to the account","title":"Parameters"},{"location":"reference/api-methods/#returns_31","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_changeAccountRole\",\"params\":[\"0xf017976fdf1521de2e108e63b423380307f501f8\",\"ABC\",\"TRANSACT\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . changeAccountRole ( \"0xf017976fdf1521de2e108e63b423380307f501f8\" , \"ABC\" , \"TRANSACT\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_connectionallowed","text":"Checks if the specified node is allowed to join the network.","title":"quorumPermission_connectionAllowed"},{"location":"reference/api-methods/#parameters_31","text":"enodeId : string - enode ID ipAddress : string - IP address of the node portNum : number - port number","title":"Parameters"},{"location":"reference/api-methods/#returns_32","text":"result : boolean - indicates if the connection is allowed or not Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_connectionAllowed\",\"params\":[\"239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf\",\"127.0.0.1\",21006],\"id\":50}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : true } geth console request quorumPermission . connectionAllowed ( \"579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778\" , \"127.0.0.1\" , 21003 ) geth console result true","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_getorgdetails","text":"Returns lists of accounts, nodes, roles, and sub-organizations linked to the specified organization.","title":"quorumPermission_getOrgDetails"},{"location":"reference/api-methods/#parameters_32","text":"orgId : string - organization or sub-organization ID","title":"Parameters"},{"location":"reference/api-methods/#returns_33","text":"result : object - result object with the following fields: acctList : array of objects - list of account objects nodeList : array of objects - list of node objects roleList : array of objects - list of role objects subOrgList : array of objects - list of sub-organization objects Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_getOrgDetails\",\"params\":[\"INITORG\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : { \"acctList\" : [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }], \"nodeList\" : [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }], \"roleList\" : [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }], \"subOrgList\" : null } } geth console request quorumPermission_getOrgDetails ( \"INITORG\" ) geth console result { \"acctList\" : [{ \"acctId\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }, { \"acctId\" : \"0xca843569e3427144cead5e4d5999a3d0ccf92b8e\" , \"isOrgAdmin\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" , \"status\" : 2 }], \"nodeList\" : [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }], \"roleList\" : [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }], \"subOrgList\" : null }","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_nodelist","text":"Returns a list of permissioned nodes in the network.","title":"quorumPermission_nodeList"},{"location":"reference/api-methods/#parameters_33","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_34","text":"result : array of objects - list of permissioned node objects with the following fields: orgId : string - organization ID to which the node belongs status : number - node status url : string - complete enode ID Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_nodeList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 53 , \"result\" : [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }] } geth console request quorumPermission . nodeList geth console result [{ \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://72c0572f7a2492cffb5efc3463ef350c68a0446402a123dacec9db5c378789205b525b3f5f623f7548379ab0e5957110bffcf43a6115e450890f97a9f65a681a@127.0.0.1:21000?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://7a1e3b5c6ad614086a4e5fb55b6fe0a7cf7a7ac92ac3a60e6033de29df14148e7a6a7b4461eb70639df9aa379bd77487937bea0a8da862142b12d326c7285742@127.0.0.1:21001?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://5085e86db5324ca4a55aeccfbb35befb412def36e6bc74f166102796ac3c8af3cc83a5dec9c32e6fd6d359b779dba9a911da8f3e722cb11eb4e10694c59fd4a1@127.0.0.1:21002?discport=0\" }, { \"orgId\" : \"INITORG\" , \"status\" : 2 , \"url\" : \"enode://28a4afcf56ee5e435c65b9581fc36896cc684695fa1db83c9568de4353dc6664b5cab09694d9427e9cf26a5cd2ac2fb45a63b43bb24e46ee121f21beb3a7865e@127.0.0.1:21003?discport=0\" }]","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_orglist","text":"Returns a list of all organizations with the status of each organization in the network.","title":"quorumPermission_orgList"},{"location":"reference/api-methods/#parameters_34","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_35","text":"result : array of objects - list of organization objects with the following fields: fullOrgId : string - complete organization ID including all the parent organization IDs separated by . level : number - level of the organization in the organization hierarchy orgId : string - organization ID parentOrgId : string - immediate parent organization ID status : number - organization status subOrgList : array of strings - list of sub-organizations linked to the organization ultimateParent : string - master organization under which the organization falls Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_orgList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 51 , \"result\" : [{ \"fullOrgId\" : \"INITORG\" , \"level\" : 1 , \"orgId\" : \"INITORG\" , \"parentOrgId\" : \"\" , \"status\" : 2 , \"subOrgList\" : null , \"ultimateParent\" : \"INITORG\" }] } geth console request quorumPermission . orgList geth console result [{ \"fullOrgId\" : \"INITORG\" , \"level\" : 1 , \"orgId\" : \"INITORG\" , \"parentOrgId\" : \"\" , \"status\" : 2 , \"subOrgList\" : null , \"ultimateParent\" : \"INITORG\" }]","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_recoverblacklistedaccount","text":"Initiates the recovery of the specified denylisted (blacklisted) account. This method can be called by a network admin account. Once a majority of the network admins approve , the denylisted account is marked as active.","title":"quorumPermission_recoverBlackListedAccount"},{"location":"reference/api-methods/#parameters_35","text":"orgId : string - organization or sub-organization ID to which the node belongs acctId : string - denylisted account ID","title":"Parameters"},{"location":"reference/api-methods/#returns_36","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_recoverBlackListedAccount\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . recoverBlackListedAccount ( \"ABC.SUB1.SUB2.SUB3\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_recoverblacklistednode","text":"Initiates the recovery of the specified denylisted (blacklisted) node. This method can be called by a network admin account. Once the majority of network admins approve , the denylisted node is marked as active.","title":"quorumPermission_recoverBlackListedNode"},{"location":"reference/api-methods/#parameters_36","text":"orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID","title":"Parameters"},{"location":"reference/api-methods/#returns_37","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_recoverBlackListedNode\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . recoverBlackListedNode ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_removerole","text":"Removes the specified role from an organization. This method can be called by an organization admin account.","title":"quorumPermission_removeRole"},{"location":"reference/api-methods/#parameters_37","text":"orgId : string - organization or sub-organization ID to which the role belongs roleId : string - role ID","title":"Parameters"},{"location":"reference/api-methods/#returns_38","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_removeRole\",\"params\":[\"ABC\",\"TRANSACT\",{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . removeRole ( \"ABC.SUB1.SUB2.SUB3\" , \"TRANSACT\" ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_rolelist","text":"Returns a list of roles in the network.","title":"quorumPermission_roleList"},{"location":"reference/api-methods/#parameters_38","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_39","text":"result : array of objects - list of role objects with the following fields: access : number - account access active : boolean - indicates if the role is active or not isAdmin : boolean - indicates if the role is organization admin role isVoter : boolean - indicates if the role is enabled for voting - applicable only for network admin role orgId : string - organization ID to which the role is linked roleId : string - unique role ID Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_roleList\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }] } geth console request quorumPermission . roleList geth console result [{ \"access\" : 3 , \"active\" : true , \"isAdmin\" : true , \"isVoter\" : true , \"orgId\" : \"INITORG\" , \"roleId\" : \"NWADMIN\" }]","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_transactionallowed","text":"Checks if the account initiating the specified transaction has sufficient permissions to execute the transaction.","title":"quorumPermission_transactionAllowed"},{"location":"reference/api-methods/#parameters_39","text":"txArgs : object - transaction arguments object","title":"Parameters"},{"location":"reference/api-methods/#returns_40","text":"result : boolean - indicates if transaction is allowed or not Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_transactionAllowed\",\"params\":[{\"from\":\"0xf2cd20ed7904c103ce2ca0ef73fb77539930c59f\"}],\"id\":50}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : true } geth console request quorumPermission . transactionAllowed ({ \"from\" : eth . accounts [ 0 ]} geth console result true","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_updateaccountstatus","text":"Updates the status of the specified account. This method can be called by an organization admin account.","title":"quorumPermission_updateAccountStatus"},{"location":"reference/api-methods/#parameters_40","text":"orgId : string - organization or sub-organization ID to which the account belongs acctId : string - account ID action : number - 1 - for suspending the account 2 - for activating the suspended account 3 - for denylisting (blacklisting) the account","title":"Parameters"},{"location":"reference/api-methods/#returns_41","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_updateAccountStatus\",\"params\":[\"ABC\",\"0xf017976fdf1521de2e108e63b423380307f501f8\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . updateAccountStatus ( \"ABC\" , \"0xf017976fdf1521de2e108e63b423380307f501f8\" , 1 ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_updatenodestatus","text":"Updates the status of the specified node. This method can be called by an organization admin account.","title":"quorumPermission_updateNodeStatus"},{"location":"reference/api-methods/#parameters_41","text":"orgId : string - organization or sub-organization ID to which the node belongs enodeId : string - complete enode ID action : number - 1 - for deactivating the node 2 - for activating the deactivated node 3 - for denylisting (blacklisting) the node","title":"Parameters"},{"location":"reference/api-methods/#returns_42","text":"result : string - response message Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_updateNodeStatus\",\"params\":[\"ABC.SUB1.SUB2.SUB3\",\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . updateNodeStatus ( \"ABC.SUB1.SUB2.SUB3\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" , 3 ,{ \"from\" : eth . accounts [ 1 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#quorumpermission_updateorgstatus","text":"Temporarily suspends the specified organization or re-activates the specified suspended organization. This method can be called by a network admin account. This can only be performed for the master organization and requires the majority of network admins to approve .","title":"quorumPermission_updateOrgStatus"},{"location":"reference/api-methods/#parameters_42","text":"orgId : string - organization ID action : number - 1 - for suspending the organization 2 - for activating the suspended organization","title":"Parameters"},{"location":"reference/api-methods/#returns_43","text":"result : string - response message Example curl HTTP curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"quorumPermission_updateOrgStatus\",\"params\":[\"ABC\",1,{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\"}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"Action completed successfully\" } geth console request quorumPermission . updateOrgStatus ( \"ABC\" , 1 ,{ \"from\" : eth . accounts [ 0 ]}) geth console result \"Action completed successfully\"","title":"Returns"},{"location":"reference/api-methods/#privacy-methods","text":"The following API methods provide functionality for GoQuorum privacy . Note Gas price is removed from GoQuorum networks , so is not included as a transaction object parameter in GoQuorum privacy methods. When using standard Ethereum JSON-RPC methods such as sendSignedTransaction , set gasPrice to 0.","title":"Privacy methods"},{"location":"reference/api-methods/#eth_distributeprivatetransaction","text":"Send a signed private transaction to the local private transaction manager and share with private participant\u2019s transaction managers. This API method is to be used as part of the process for sending externally signed privacy marker transactions . The private transaction should be signed, sent to participants with this API, and the resulting hash set as the PMT\u2019s data . Note Two step process: Performs the same as eth_sendRawPrivateTransaction (simulation and calling /sendsignedtx ), but doesn\u2019t submit private transaction to txpool. Sends the private transaction to Tessera to generate a hash, which should be placed in the privacy marker transaction.","title":"eth_distributePrivateTransaction"},{"location":"reference/api-methods/#parameters_43","text":"string - signed private transaction in hex format object - private data to send, with the following fields: privateFor : List<String> - an array of the recipients\u2019 base64-encoded public keys privateFrom : String - (optional) the sending party\u2019s base64-encoded public key to use (Privacy Manager default if not provided) privacyFlag : Number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : List<String> - an array of the recipients\u2019 base64-encoded public keys","title":"Parameters"},{"location":"reference/api-methods/#returns_44","text":"string - Transaction Manager hash to be used as a privacy marker transaction\u2019s data when externally signing","title":"Returns"},{"location":"reference/api-methods/#example","text":"Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_distributePrivateTransaction\",\"params\":[\"0xf88d01808347b7608080b84034ec48699ce5877f0f97a5bea4550d52296368b1dcdc89667559555066c9894525e4878d0689cfeb4b6fda3dd6566aa06ce772f2e19e0404e45fe6351ebf640326a0ffecedc570d3520d283508f00d8b2c162096ebddca753979da95062c1df234cea033ceb36d46e3e86a399e8fde35b078248c90fb71344aadcc7e83b9324958a4ed\", {\"privateFor\": [\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : \"0xb33c67830588b746d7824e650d242bbe31a72018560f82ffe69692fd087c068c61bf3ed82c76ece771e11fef4a85035053911c6ae7589cac4c3e06ffc23da34c\" } geth console request web3 . eth . distributePrivateTransaction ( \"0xf88d01808347b7608080b84034ec48699ce5877f0f97a5bea4550d52296368b1dcdc89667559555066c9894525e4878d0689cfeb4b6fda3dd6566aa06ce772f2e19e0404e45fe6351ebf640326a0ffecedc570d3520d283508f00d8b2c162096ebddca753979da95062c1df234cea033ceb36d46e3e86a399e8fde35b078248c90fb71344aadcc7e83b9324958a4ed\" , { \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0xb33c67830588b746d7824e650d242bbe31a72018560f82ffe69692fd087c068c61bf3ed82c76ece771e11fef4a85035053911c6ae7589cac4c3e06ffc23da34c\"","title":"Example"},{"location":"reference/api-methods/#eth_filltransaction","text":"Supports offline signing of the specified transaction. This can be used to fill and sign both public and private transactions. Defaults to RLP plus json .","title":"eth_fillTransaction"},{"location":"reference/api-methods/#parameters_44","text":"transaction : object - transaction object to send, with the following fields: from : string - address for the sending account to : string - (optional) destination address of the message value : number - (optional) value transferred for the transaction in Wei, also the endowment if it\u2019s a contract-creation transaction data : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code privateFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys","title":"Parameters"},{"location":"reference/api-methods/#returns_45","text":"result : object - result object with the following fields: raw : data - RLP -encoded bytes for the passed transaction object tx : object - transaction object Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_fillTransaction\",\"params\":[{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"data\":\"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\",\"gas\":0x47b760,\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : { \"raw\" : \"0xf84d02808347b7608080b84075902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6258080\" , \"tx\" : { \"gas\" : \"0x47b760\" , \"gasPrice\" : \"0x0\" , \"hash\" : \"0xc0bbb6326ebafb7b0b18cf85d7b93e73ec8ae72b1c8d043d77d7ac5fecd9ccb5\" , \"input\" : \"0x75902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6\" , \"nonce\" : \"0x2\" , \"r\" : \"0x0\" , \"s\" : \"0x0\" , \"to\" : null , \"v\" : \"0x25\" , \"value\" : \"0x0\" } } } geth console request eth . fillTransaction ({ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"data\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" , \"gas\" : 0x47b760 , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result { \"raw\" : \"0xf84d02808347b7608080b84075902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6258080\" , \"tx\" : { \"gas\" : \"0x47b760\" , \"gasPrice\" : \"0x0\" , \"hash\" : \"0xc0bbb6326ebafb7b0b18cf85d7b93e73ec8ae72b1c8d043d77d7ac5fecd9ccb5\" , \"input\" : \"0x75902a24f8f3248a8c6d342506f018b2ef735bca0badecbaf7dc98b5799b3c8db4cc65f1a9294f29f018ce603cf93a212ebdde4a8f2d83d44a98eb97ffa690d6\" , \"nonce\" : \"0x2\" , \"r\" : \"0x0\" , \"s\" : \"0x0\" , \"to\" : null , \"v\" : \"0x25\" , \"value\" : \"0x0\" } }","title":"Returns"},{"location":"reference/api-methods/#eth_getcontractprivacymetadata","text":"Queries the privacy metadata for the specified contract account address.","title":"eth_getContractPrivacyMetadata"},{"location":"reference/api-methods/#parameter_1","text":"string - contract address","title":"Parameter"},{"location":"reference/api-methods/#returns_46","text":"result : object - result object with the following fields: creationTxHash : data - affected contract\u2019s original transaction\u2019s encrypted payload hash privacyFlag : number - 0 for SP , 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : string - an array of the recipients\u2019 base64-encoded public keys Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getContractPrivacyMetadata\",\"params\":[\"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\"],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : { \"creationTxHash\" : \"0xf67c748bbed92110cb66510d413af99144b4434fa325771b6323f7f00c35192d2f861076f68061ed2d324f614edd2f0159Ba5ee2408bb42402a876c4b295598b7\" , \"mandatoryFor\" :[ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ] \"privacyFlag\" : 2 } } geth console request eth . getContractPrivacyMetadata ( \"0x1932c48b2bf8102ba33b4a6b545c32236e342f34\" ); geth console result { \"creationTxHash\" : \"0xf67c748bbed92110cb66510d413af99144b4434fa325771b6323f7f00c35192d2f861076f68061ed2d324f614edd2f0159Ba5ee2408bb42402a876c4b295598b7\" , \"mandatoryFor\" :[ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], \"privacyFlag\" : 2 }","title":"Returns"},{"location":"reference/api-methods/#eth_getprivacyprecompileaddress","text":"Get the address of the privacy precompile contract, to be used as the to address for privacy marker transactions .","title":"eth_getPrivacyPrecompileAddress"},{"location":"reference/api-methods/#parameters_45","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_47","text":"string - contract address for the privacy precompile in hex format","title":"Returns"},{"location":"reference/api-methods/#examples","text":"Example curl HTTP request curl -X POST http://localhost:22000 --data '{ \"jsonrpc\":\"2.0\", \"id\":2, \"method\":\"eth_getPrivacyPrecompileAddress\"}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 2 , \"result\" : \"0x000000000000000000000000000000000000007a\" } geth console request eth . getPrivacyPrecompileAddress (); geth console result \"0x000000000000000000000000000000000000007a\"","title":"Examples"},{"location":"reference/api-methods/#eth_getprivatetransactionbyhash","text":"Retrieve the details of a privacy marker transaction \u2018s internal private transaction using the PMT\u2019s transaction hash.","title":"eth_getPrivateTransactionByHash"},{"location":"reference/api-methods/#parameters_46","text":"string - privacy marker transaction\u2019s hash in hex format","title":"Parameters"},{"location":"reference/api-methods/#returns_48","text":"object - private transaction (nil if caller is not a participant)","title":"Returns"},{"location":"reference/api-methods/#examples_1","text":"Example curl HTTP request curl -X POST http://localhost:22000 --data '{ \"jsonrpc\":\"2.0\", \"id\":2, \"method\":\"eth_getPrivateTransactionByHash\", \"params\": [\"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\"]}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 2 , \"result\" :{ \"blockHash\" : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , \"blockNumber\" : \"0x5\" , \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"gas\" : \"0x47b760\" , \"gasPrice\" : \"0x0\" , \"hash\" : \"0x7cb8fbda0c76632ee801e27cc3ef5445378cf65cc0c36ffaf79b738c16d6ff18\" , \"input\" : \"0xc23a8cc005b977ff5b736f8fa670e3a68c0ce4c9609494a9d482d12b2bae9a5037fdad0164d0e6fd21527e20363507262e528eb3187a0f0a1f097eaaedc845b7\" , \"nonce\" : \"0x3\" , \"to\" : null , \"transactionIndex\" : \"0x0\" , \"value\" : \"0x0\" , \"v\" : \"0x25\" , \"r\" : \"0xef2562c04b2da7a90007068990b5279d6cb468e5347d40fe0aaa523485367bff\" , \"s\" : \"0x3530a3a6188cb0a3ebcfce29ada3ff3ed59976e6c88d1557f48554dfc0c3849e\" }} geth console request eth . getPrivateTransaction ( \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" ); geth console result { blockHash : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , blockNumber : 5 , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , gas : 4700000 , gasPrice : 0 , hash : \"0x7cb8fbda0c76632ee801e27cc3ef5445378cf65cc0c36ffaf79b738c16d6ff18\" , i n pu t : \"0xc23a8cc005b977ff5b736f8fa670e3a68c0ce4c9609494a9d482d12b2bae9a5037fdad0164d0e6fd21527e20363507262e528eb3187a0f0a1f097eaaedc845b7\" , n o n ce : 3 , r : \"0xef2562c04b2da7a90007068990b5279d6cb468e5347d40fe0aaa523485367bff\" , s : \"0x3530a3a6188cb0a3ebcfce29ada3ff3ed59976e6c88d1557f48554dfc0c3849e\" , t o : null , transa c t io n I n dex : 0 , v : \"0x25\" , value : 0 }","title":"Examples"},{"location":"reference/api-methods/#eth_getprivatetransactionreceipt","text":"Retrieve the receipt of a privacy marker transaction\u2019s (PMT) internal private transaction using the PMT\u2019s transaction hash.","title":"eth_getPrivateTransactionReceipt"},{"location":"reference/api-methods/#parameters_47","text":"string - privacy marker transaction\u2019s hash in hex format","title":"Parameters"},{"location":"reference/api-methods/#returns_49","text":"object - private transaction receipt (nil if caller is not a participant)","title":"Returns"},{"location":"reference/api-methods/#examples_2","text":"Example curl HTTP request curl -X POST http://localhost:22000 --data '{ \"jsonrpc\":\"2.0\", \"id\":2, \"method\":\"eth_getPrivateTransactionReceipt\", \"params\": [\"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\"]}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 2 , \"result\" :{ \"blockHash\" : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , \"blockNumber\" : \"0x5\" , \"contractAddress\" : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , \"cumulativeGasUsed\" : \"0x0\" , \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"gasUsed\" : \"0x0\" , \"logs\" :[], \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"status\" : \"0x1\" , \"to\" : null , \"transactionHash\" : \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" , \"transactionIndex\" : \"0x0\" }} geth console request eth . getPrivateTransactionReceipt ( \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" ); geth console result { blockHash : \"0x7b2b52bf505e27e8a93249c589d8e93c68b20c589f27fd98ddeb53083fcd3276\" , blockNumber : 5 , co ntra c t Address : \"0xd9d64b7dc034fafdba5dc2902875a67b5d586420\" , cumula t iveGasUsed : 0 , fr om : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , gasUsed : 0 , logs : [], logsBloom : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , s tatus : \"0x1\" , t o : null , transa c t io n Hash : \"0xcb1f39245a88d5be49dca35e1a34a11f98bcb825ea4aa70829923ff5404c8a82\" , transa c t io n I n dex : 0 }","title":"Examples"},{"location":"reference/api-methods/#eth_getpsi","text":"When using multiple private states , returns the private state the user is operating on.","title":"eth_getPSI"},{"location":"reference/api-methods/#parameters_48","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_50","text":"result : string - the private state identifier (PSI) Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getPSI\",\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"PS1\" } geth console request eth . getPSI geth console result \"PS1\"","title":"Returns"},{"location":"reference/api-methods/#eth_getquorumpayload","text":"Returns the unencrypted payload from Tessera .","title":"eth_getQuorumPayload"},{"location":"reference/api-methods/#parameters_49","text":"id : string - the generated SHA3-512 hash of the encrypted payload from the Private Transaction Manager, in hex (This is seen in the transaction as the input field.)","title":"Parameters"},{"location":"reference/api-methods/#returns_51","text":"result : string - unencrypted transaction payload in hex format Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getQuorumPayload\",\"params\":[\"0x5e902fa2af51b186468df6ffc21fd2c26235f4959bf900fc48c17dc1774d86d046c0e466230225845ddf2cf98f23ede5221c935aac27476e77b16604024bade0\"],\"id\":67}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 67 , \"result\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" } geth console request eth . getQuorumPayload ( \"0x5e902fa2af51b186468df6ffc21fd2c26235f4959bf900fc48c17dc1774d86d046c0e466230225845ddf2cf98f23ede5221c935aac27476e77b16604024bade0\" ) geth console result \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\"","title":"Returns"},{"location":"reference/api-methods/#eth_sendrawprivatetransaction","text":"Sends the specified pre-signed transaction, for example using SilentCicero/ethereumjs-accounts . If the transaction is a contract creation, use web3.eth.getTransactionReceipt() to get the contract address after the transaction is mined. Important Before calling this method, storeraw needs to be called to Tessera.","title":"eth_sendRawPrivateTransaction"},{"location":"reference/api-methods/#parameters_50","text":"string - signed transaction data in hex format object - private data to send, with the following fields: privateFor : array of strings - when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys privacyFlag : number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : array of strings - when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys callback : function - (optional) callback function; if you pass a callback, the HTTP request is made asynchronous.","title":"Parameters"},{"location":"reference/api-methods/#returns_52","text":"result : string - 32-byte transaction hash as a hex string Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendRawPrivateTransaction\",\"params\":[\"0xf889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f\", {\"privateFor\": [\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : \"0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385\" } geth console request web3 . eth . sendRawPrivateTransaction ( \"0xf889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f\" , { \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385\"","title":"Returns"},{"location":"reference/api-methods/#eth_sendtransaction","text":"Note To support private transactions in GoQuorum, the Web3js web3.eth.sendTransaction(object) API method has been modified to include private transaction parameters. Sends the specified transaction to the network. If the transaction is a contract creation, use web3.eth.getTransactionReceipt() ( eth_getTransactionReceipt ) to get the contract address after the transaction is mined.","title":"eth_sendTransaction"},{"location":"reference/api-methods/#parameters_51","text":"transaction : object - transaction object to send, with the following fields: from : string - address for the sending account; defaults to web3.eth.defaultAccount to : string - (optional) destination address of the message; defaults to undefined value : number - (optional) value transferred for the transaction in Wei, also the endowment if it\u2019s a contract-creation transaction gas : number - (optional) amount of gas to use for the transaction (unused gas is refunded) data : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code input : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code nonce : number - (optional) integer of a nonce; allows you to overwrite your own pending transactions that use the same nonce privateFrom : string - (optional) when sending a private transaction, the sending party\u2019s base64-encoded public key to use; if not present and passing privateFor , use the default key as configured in the TransactionManager . privateFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys privacyFlag : number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys callback : function - (optional) callback function; if you pass a callback, the HTTP request is made asynchronous. Note input cannot co-exist with data if they are set to different values. input is the new naming of data . They are the same parameters, but both remain for backwards compatibility.","title":"Parameters"},{"location":"reference/api-methods/#returns_53","text":"result : string - 32-byte transaction hash as a hex string Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getContractPrivacyMetadata\",\"params\":[{\"data\":\"603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3\",\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":15}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 15 , \"result\" : \"0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385\" } geth console request web3 . eth . sendTransaction ({ \"data\" : \"603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3\" , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385\"","title":"Returns"},{"location":"reference/api-methods/#eth_sendtransactionasync","text":"Sends the specified transaction to the network asynchronously. This returns immediately, potentially before the transaction has been submitted to the transaction pool. A callback can be provided to receive the result of submitting the transaction; a server must be set up to receive POST requests at the given URL. If the transaction is a contract creation, use web3.eth.getTransactionReceipt() to get the contract address after the transaction is mined.","title":"eth_sendTransactionAsync"},{"location":"reference/api-methods/#parameters_52","text":"transaction : object - transaction object to send, with the following fields: from : string - address for the sending account; defaults to web3.eth.defaultAccount to : string - (optional) destination address of the message; defaults to undefined value : number - (optional) value transferred for the transaction in Wei, also the endowment if it\u2019s a contract-creation transaction gas : number - (optional) amount of gas to use for the transaction (unused gas is refunded) data : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code input : data - (optional) either a byte string containing the associated data of the message, or in the case of a contract-creation transaction, the initialization code nonce : number - (optional) integer of a nonce; allows you to overwrite your own pending transactions that use the same nonce privateFrom : string - (optional) when sending a private transaction, the sending party\u2019s base64-encoded public key to use; if not present and passing privateFor , use the default key as configured in the TransactionManager . privateFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys privacyFlag : number - (optional) 0 for SP (default if not provided), 1 for PP , 2 for MPP , and 3 for PSV transactions mandatoryFor : array of strings - (optional) when sending a private transaction, an array of the recipients\u2019 base64-encoded public keys callbackUrl : string - (optional) URL to perform a POST request to post the result of submitting the transaction Note input cannot co-exist with data if they are set to different values. input is the new naming of data . They are the same parameters, but both remain for backwards compatibility.","title":"Parameters"},{"location":"reference/api-methods/#returns_54","text":"result : string - empty hash, defined as 0x0000000000000000000000000000000000000000000000000000000000000000 The callback URL receives the following object: result : object - result object with the following fields: id : string - ID in the original RPC call, used to match this result to the request txHash : string - transaction hash that was generated, if successful error : string - error that occurred while submitting the transaction Example The call and the immediate response: curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransactionAsync\",\"params\":[{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"data\":\"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\",\"gas\":\"0x47b760\",\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"]}],\"id\":67}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 67 , \"result\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } geth console request eth . sendTransactionAsync ({ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"data\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" , \"gas\" : \"0x47b760\" , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) geth console result \"0x0000000000000000000000000000000000000000000000000000000000000000\" If you provide the callback URL, you receive the following response after submitting the transaction. This example assumes a webserver that can be accessed by calling http://localhost:8080 has been set up to accept POST requests: curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransactionAsync\",\"params\":[{\"from\":\"0xed9d02e382b34818e88b88a309c7fe71e65f419d\",\"data\":\"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\",\"gas\":\"0x47b760\",\"privateFor\":[\"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\"],\"callbackUrl\":\"http://localhost:8080\"}],\"id\":67}' JSON result { \"id\" : 67 , \"txHash\" : \"0x75ebbf4fbe29355fc8a4b8d1e14ecddf0228b64ef41e6d2fce56047650e2bf17\" } geth console request eth . sendTransactionAsync ({ \"from\" : \"0xed9d02e382b34818e88b88a309c7fe71e65f419d\" , \"data\" : \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029000000000000000000000000000000000000000000000000000000000000002a\" , \"gas\" : \"0x47b760\" , \"privateFor\" : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], \"callbackUrl\" : \"http://localhost:8080\" }) geth console result { \"id\" : 67 , \"txHash\" : \"0x75ebbf4fbe29355fc8a4b8d1e14ecddf0228b64ef41e6d2fce56047650e2bf17\" }","title":"Returns"},{"location":"reference/api-methods/#eth_storageroot","text":"Returns the storage root hash of the specified address. If the contract is a private contract , returns the storage root hash from the private state database.","title":"eth_storageRoot"},{"location":"reference/api-methods/#parameters_53","text":"address : String - address to fetch the storage root from in hex block : string - (optional) block number to fetch the storage root from in hex; defaults to the latest block","title":"Parameters"},{"location":"reference/api-methods/#returns_55","text":"result : string - 32-byte storage root hash as a hex string Example curl HTTP request curl -X POST http://127.0.0.1:22000 --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_storageRoot\",\"params\":[\"0x1349f3e1b8d71effb47b840594ff27da7e603d17\",\"0x1\"],\"id\":67}' JSON result { \"jsonrpc\" : \"2.0\" \"id\" : 67 , \"result\" : \"0x81d1fa699f807735499cf6f7df860797cf66f6a66b565cfcda3fae3521eb6861\" } geth console request eth . storageRoot ( \"0x1349f3e1b8d71effb47b840594ff27da7e603d17\" , \"0x1\" ) geth console result \"0x81d1fa699f807735499cf6f7df860797cf66f6a66b565cfcda3fae3521eb6861\"","title":"Returns"},{"location":"reference/api-methods/#raft-methods","text":"The following API methods provide access to the Raft consensus engine.","title":"Raft methods"},{"location":"reference/api-methods/#raft_addlearner","text":"Adds a new node to the network as a learner node. The learner node syncs with the network and can transact, but isn\u2019t part of the Raft cluster and doesn\u2019t provide block confirmation to the minter node.","title":"raft_addLearner"},{"location":"reference/api-methods/#parameters_54","text":"enodeId : string - enode ID of the node to add","title":"Parameters"},{"location":"reference/api-methods/#returns_56","text":"result : string - Raft ID for the node being added Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_addLearner\",\"params\":[\"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : 5 } geth console request raft . addLearner ( \"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\" ) geth console result 5","title":"Returns"},{"location":"reference/api-methods/#raft_addpeer","text":"Adds a new peer to the network.","title":"raft_addPeer"},{"location":"reference/api-methods/#parameters_55","text":"enodeId : string - enode ID of the node to be added to the network","title":"Parameters"},{"location":"reference/api-methods/#returns_57","text":"result : string - Raft ID for the node being added, or an error message if the node is already part of the network Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_addPeer\",\"params\":[\"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\"],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : 5 } geth console request raft . addPeer ( \"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\" ) geth console result 5","title":"Returns"},{"location":"reference/api-methods/#raft_cluster","text":"Returns the details of all nodes part of the Raft cluster.","title":"raft_cluster"},{"location":"reference/api-methods/#parameters_56","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_58","text":"result : array - list of node objects with the following fields: hostName : string - DNS name or the host IP address nodeActive : boolean - indicates if the node is active in the Raft cluster nodeId : string - enode ID of the node p2pPort : number - p2p port raftId : string - Raft ID of the node raftPort : number - Raft port role : string - role of the node in the Raft cluster (minter/verifier/learner); \"\" if there is no leader at the network level Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_cluster\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : [{ \"raftId\" : 1 , \"nodeId\" : \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" , \"p2pPort\" : 21000 , \"raftPort\" : 50401 , \"hostname\" : \"127.0.0.1\" , \"role\" : \"minter\" , \"nodeActive\" : true }, { \"raftId\" : 3 , \"nodeId\" : \"579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778\" , \"p2pPort\" : 21002 , \"raftPort\" : 50403 , \"hostname\" : \"127.0.0.1\" , \"role\" : \"verifier\" , \"nodeActive\" : true }, { \"raftId\" : 2 , \"nodeId\" : \"0ba6b9f606a43a95edc6247cdb1c1e105145817be7bcafd6b2c0ba15d58145f0dc1a194f70ba73cd6f4cdd6864edc7687f311254c7555cc32e4d45aeb1b80416\" , \"p2pPort\" : 21001 , \"raftPort\" : 50402 , \"hostname\" : \"127.0.0.1\" , \"role\" : \"verifier\" , \"nodeActive\" : true }] } geth console request raft . cluster geth console result [{ \"hostname\" : \"127.0.0.1\" , \"nodeActive\" : true , \"nodeId\" : \"0ba6b9f606a43a95edc6247cdb1c1e105145817be7bcafd6b2c0ba15d58145f0dc1a194f70ba73cd6f4cdd6864edc7687f311254c7555cc32e4d45aeb1b80416\" , \"p2pPort\" : 21001 , \"raftId\" : 2 , \"raftPort\" : 50402 , \"role\" : \"verifier\" }, { \"hostname\" : \"127.0.0.1\" , \"nodeActive\" : true , \"nodeId\" : \"579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778\" , \"p2pPort\" : 21002 , \"raftId\" : 3 , \"raftPort\" : 50403 , \"role\" : \"verifier\" }, { \"hostname\" : \"127.0.0.1\" , \"nodeActive\" : true , \"nodeId\" : \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" , \"p2pPort\" : 21000 , \"raftId\" : 1 , \"raftPort\" : 50401 , \"role\" : \"minter\" }]","title":"Returns"},{"location":"reference/api-methods/#raft_leader","text":"Returns the enode ID of the leader node.","title":"raft_leader"},{"location":"reference/api-methods/#parameters_57","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_59","text":"result : string - enode ID of the leader, or an error message if there is no leader Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_leader\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\" } geth console request raft . leader geth console result \"ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef\"","title":"Returns"},{"location":"reference/api-methods/#raft_promotetopeer","text":"Promotes the specified learner node to peer and thus to be part of the Raft cluster.","title":"raft_promoteToPeer"},{"location":"reference/api-methods/#parameters_58","text":"raftId : string - Raft ID of the node to be promoted","title":"Parameters"},{"location":"reference/api-methods/#returns_60","text":"result : boolean - indicates if the node is promoted Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_promoteToPeer\",\"params\":[4],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : true } geth console request raft . promoteToPeer ( 4 ) geth console result true","title":"Returns"},{"location":"reference/api-methods/#raft_removepeer","text":"Removes the specified peer from the Raft cluster.","title":"raft_removePeer"},{"location":"reference/api-methods/#parameters_59","text":"raftId : string - Raft ID of the peer to be removed from the cluster","title":"Parameters"},{"location":"reference/api-methods/#returns_61","text":"result : null Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_removePeer\",\"params\":[4],\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : null } geth console request raft . removePeer ( 4 ) geth console result null","title":"Returns"},{"location":"reference/api-methods/#raft_role","text":"Returns the role of the current node in the Raft cluster.","title":"raft_role"},{"location":"reference/api-methods/#parameters_60","text":"None","title":"Parameters"},{"location":"reference/api-methods/#returns_62","text":"result : string - role of the node in the Raft cluster (minter/verifier/learner); \"\" if there is no leader at the network level Example curl HTTP request curl -X POST http://127.0.0.1:22001 --data '{\"jsonrpc\":\"2.0\",\"method\":\"raft_role\",\"id\":10}' --header \"Content-Type: application/json\" JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 10 , \"result\" : \"verifier\" } geth console request raft . role geth console result \"minter\"","title":"Returns"},{"location":"reference/cli-syntax/","text":"GoQuorum command line options \u00b6 This reference describes the syntax of the GoQuorum command line interface (CLI) options. Important GoQuorum is based on the Geth Go Ethereum client but only the GoQuorum-specific CLI options are listed here. Visit the Go Ethereum documentation to view the CLI options for the geth command. Specifying options \u00b6 You can specify GoQuorum options: On the command line. geth [ OPTIONS ] In a configuration file . Options \u00b6 allowedfutureblocktime \u00b6 Syntax --allowedfutureblocktime <INTEGER> Example --allowedfutureblocktime 1 Maximum time from current time allowed for blocks before they\u2019re considered future blocks, in seconds. This allows nodes to be slightly out of sync without receiving \u201cMining too far in the future\u201d messages. The default is 0. emitcheckpoints \u00b6 Syntax --emitcheckpoints If included, emits specially formatted logging checkpoints. immutabilitythreshold \u00b6 Syntax --immutabilitythreshold <INTEGER> Example --immutabilitythreshold 1000000 Overrides the default immutability threshold for GoQuorum nodes. Blocks below the immutability threshold are moved to the ancient data folder. The default is 3162240. istanbul.blockperiod \u00b6 Syntax --istanbul.blockperiod <INTEGER> Example --istanbul.blockperiod 5 Minimum time between two consecutive IBFT or QBFT blocks\u2019 timestamps in seconds. Setting the block period determines how quickly blocks should be minted by the validators. The default is 1. Warning Do not update this value after starting the network because this option is used by nodes to validate block times. istanbul.requesttimeout \u00b6 Syntax --istanbul.requesttimeout <INTEGER> Example --istanbul.requesttimeout 12000 Minimum request timeout for each IBFT or QBFT round in milliseconds. The request timeout is the timeout at which IBFT triggers a new round if the previous one did not complete. This period increases as the timeout is hit more often. The default is 10000. multitenancy \u00b6 Syntax --multitenancy Example --multitenancy Enables multi-tenancy . This requires the JSON-RPC Security plugin to also be configured. override.istanbul \u00b6 Syntax --override.istanbul <INTEGER> Example --override.istanbul 100 Custom fork block when using IBFT or QBFT consensus. The default is 0. permissioned \u00b6 Syntax --permissioned Example --permissioned Enables basic network permissioning . The node allows only a defined list of nodes to connect. plugins \u00b6 Syntax --plugins file:///<path>/<to>/plugins.json Example --plugins file:///opt/geth/plugins.json URI of the plugins settings JSON file . Use this to configure plugins . plugins.localverify \u00b6 Syntax --plugins.localverify If included, verifies plugin integrity from the local file system. This requires a plugin signature file and PGP public key file to be available. plugins.publickey \u00b6 Syntax --plugins.publickey file:///<path>/<to>/<publicKeyFile> Example --plugins.publickey file:///opt/geth/pubkey.pgp.asc URI of the PGP public key for local plugin verification . This option is only valid if --plugins.localverify is set. plugins.skipverify \u00b6 Syntax --plugins.skipverify If included, disables the plugin verification process. privacymarker.enable \u00b6 Syntax --privacymarker.enable If included, GoQuorum creates a privacy marker transaction when a private transaction is submitted. ptm.dialtimeout \u00b6 Syntax --ptm.dialtimeout <INTEGER> Example ---ptm.dialtimeout 0 Dial timeout in seconds for the private transaction manager connection . Setting to 0 disables the timeout. The default is 1 second. ptm.http.idletimeout \u00b6 Syntax --ptm.http.idletimeout <INTEGER> Example ---ptm.http.idletimeout 0 Idle timeout in seconds for the private transaction manager connection . Setting to 0 disables the timeout. The default is 10 seconds. ptm.http.readbuffersize \u00b6 Syntax --ptm.http.readbuffersize <INTEGER> Example ---ptm.http.readbuffersize 0 Size of the read buffer in bytes for the private transaction manager connection . Setting to 0 or not specifying uses the http.Transport default. ptm.http.writebuffersize \u00b6 Syntax --ptm.http.writebuffersize <INTEGER> Example ---ptm.http.writebuffersize 0 Size of the write buffer in bytes for the private transaction manager connection . Setting to 0 or not specifying uses the http.Transport default. ptm.socket \u00b6 Syntax --ptm.socket <path>/<to>/<ipc>/<file> Example ---ptm.socket qdata/c1/tm.ipc Path to the IPC file when using a Unix domain socket for the private transaction manager connection . ptm.timeout \u00b6 Syntax --ptm.timeout <INTEGER> Example ---ptm.timeout 0 Timeout in seconds for communication over the private transaction manager connection . Setting to 0 disables the timeout. The default is 5 seconds. ptm.tls.clientcert \u00b6 Syntax --ptm.tls.clientcert <path>/<to>/<client_cert_pem_file> Example ---ptm.tls.clientcert client.cert.pem Path to the file containing the client certificate (or chain of certificates) when using a TLS connection to the private transaction manager . This is required if the server is configured to use two-way authentication. ptm.tls.clientkey \u00b6 Syntax --ptm.tls.clientkey <path>/<to>/<client_key_pem_file> Example ---ptm.tls.clientkey client.key.pem Path to the file containing the client\u2019s private key when using a TLS connection to private transaction manager . This is required if the server is configured to use two-way authentication. ptm.tls.insecureskipverify \u00b6 Syntax --ptm.tls.insecureskipverify If included, disables verification of the server\u2019s TLS certificate on connection to private transaction manager . ptm.tls.mode \u00b6 Syntax --ptm.tls.mode <STRING> Example ---ptm.tls.mode \"strict\" Setting to off disables TLS. Setting to strict enables TLS when using an HTTPS connection to the private transaction manager . ptm.tls.rootca \u00b6 Syntax --ptm.tls.rootca <path>/<to>/<rootca_pem_file> Example ---ptm.tls.rootca certfile.pem Path to the file containing the root CA certificate when using a TLS connection to the private transaction manager . The default is the host\u2019s certificates. ptm.url \u00b6 Syntax --ptm.url <URL> Example ---ptm.url \"https://127.0.0.1:9101\" URL when using an HTTP/HTTPS connection to the private transaction manager . qlight.client \u00b6 Syntax --qlight.client Enables the qlight client P2P protocol. qlight.client.psi \u00b6 Syntax --qlight.client.psi <STRING> Example --qlight.client.psi \"private\" PSI the qlight client uses to connect to a server node. The default is private . qlight.client.rpc.tls \u00b6 Syntax --qlight.client.rpc.tls Enables the qlight client RPC connection to use TLS. qlight.client.rpc.tls.cacert \u00b6 Syntax --qlight.client.rpc.tls.cacert <path>/<to>/<client-RPC certicate-auth-file> Example --qlight.client.rpc.tls.cacert certfile.pem Path to the qlight client RPC client certificate authority file. qlight.client.rpc.tls.cert \u00b6 Syntax --qlight.client.rpc.tls.cert <path>/<to>/<client-RPC-client-certificate-file> Example --qlight.client.rpc.tls.cert certfile.pem Path to the qlight client RPC client certificate file. qlight.client.rpc.tls.insecureskipverify \u00b6 Syntax --qlight.client.rpc.tls.insecureskipverify Enables the qlight client RPC connection to skip TLS verification. qlight.client.rpc.tls.key \u00b6 Syntax --qlight.client.rpc.tls.key <path>/<to>/<client_TLS_key_pem_file> Example --qlight.client.rpc.tls.key client.TLS.key.pem Path to the qlight client RPC client certificate private key. qlight.client.serverNode \u00b6 Syntax --qlight.client.serverNode <nodeID> Example --qlight.client.serverNode 0xc35c3...d615f The node ID of the target server node. qlight.client.serverNodeRPC \u00b6 Syntax --qlight.client.serverNodeRPC <URL> Example --qlight.client.serverNodeRPC \"http://127.0.0.1:8888\" The RPC URL of the target server node. qlight.client.token.enabled \u00b6 Syntax --qlight.client.token.enabled Enables the client to use a token when connecting to the qlight server. qlight.client.token.management \u00b6 Syntax --qlight.client.token.management <string> Example --qlight.client.token.management \"none\" Mechanism used to refresh the token. Possible values: none - Developer mode external - A new token must be injected via the qlight RPC API client-security-plugin - The client security plugin must be deployed/configured qlight.client.token.value \u00b6 Syntax --qlight.client.token.value <TOKEN> Example --qlight.client.token.value \"bearer AYjcyMzY3ZDhiNmJkNTY\" Token the qlight client uses to connect to a server node. qlight.server \u00b6 Syntax --qlight.server Enables the qlight server P2P protocol. qlight.server.p2p.maxpeers \u00b6 Syntax --qlight.server.p2p.maxpeers <INTEGER> Example --qlight.server.p2p.maxpeers 10 Maximum number of qlight peers. The default is 10. qlight.server.p2p.netrestrict \u00b6 Syntax --qlight.server.p2p.netrestrict <NETWORK MASK> Example --qlight.server.p2p.netrestrict \"xyz\" Restricts network communication to the given IP networks (CIDR masks). qlight.server.p2p.permissioning \u00b6 Syntax --qlight.server.p2p.permissioning Enables the qlight peers to check against a permissioned list and a disallowed list. qlight.server.p2p.permissioning.prefix \u00b6 Syntax --qlight.server.p2p.permissioning.prefix <prefix-filename> Example --qlight.server.p2p.permissioning.prefix \"permissioned-nodes.json\" Prefix for the permissioned-nodes.json and disallowed-nodes.json files. qlight.server.p2p.port \u00b6 Syntax --qlight.server.p2p.port = <INTEGER> Example --qlight.server.p2p.port = 30305 Port the qlight network listens to. The default is 30305. qlight.tls \u00b6 Syntax --qlight.tls Enables the qlight client P2P protocol to use TLS. qlight.tls.cacerts \u00b6 Syntax --qlight.tls.cacerts <path>/<to>/<qlight_tls_cacert_file> Example --qlight.tls.cacerts certfile.pem Path to the certificate authorities file to use for validating P2P connection. qlight.tls.cert \u00b6 Syntax --qlight.tls.cert ` <path>/<to>/<qlight_tls_cert_file> Example --qlight.tls.cert certfile.pem Path to the certificate file to use for the qlight P2P connection. qlight.tls.ciphersuites \u00b6 Syntax --qlight.tls.ciphersuites <STRING> Example --qlight.tls.ciphersuites \"CIPHER_SUITE_1,CIPHER_SUITE_2\" Cipher suites to use for the qlight P2P connection. qlight.tls.clientauth \u00b6 Syntax --qlight.tls.clientauth <INTEGER> Example --qlight.tls.clientauth 0 Sets the method the client is authenticated. Possible values: 0= NoClientCert This is the default. 1= RequestClientCert 2= RequireAnyClientCert 3= VerifyClientCertIfGiven 4= RequireAndVerifyClientCert qlight.tls.key \u00b6 Syntax --qlight.tls.key <path>/<to>/<qlight_tls_key_file> Example --qlight.tls.key certfile.pem Path to the key file to use for qlight P2P connection. raft \u00b6 Syntax --raft Example --raft Enables Raft for consensus. raftblocktime \u00b6 Syntax --raftblocktime <INTEGER> Example --raftblocktime 100 Time between Raft block creations in milliseconds. The default is 50. raftdnsenable \u00b6 Syntax --raftdnsenable Example --raftdnsenable Enables DNS resolution of peers . raftjoinexisting \u00b6 Syntax --raftjoinexisting <INTEGER> Example --raftjoinexisting 1 Raft ID to assume when joining a pre-existing cluster . The default is 0. raftlogdir \u00b6 Syntax --raftlogdir <DIRECTORY> Example --raftlogdir raftlogdir Raft log directory used for the quorum-raft-state , raft-snap , and raft-wal folders. Defaults to the datadir option . raftport \u00b6 Syntax --raftport <PORT> Example --raftport 50500 Port to bind for the Raft transport . The default is 50400. revertreason \u00b6 Syntax --revertreason Example --revertreason Enables including the revert reason in the eth_getTransactionReceipt response. rpcclitls.cacert \u00b6 Syntax --rpcclitls.cacert <path>/<to>/<TLS-CA-pem-file> Example --rpcclitls.cacert certfile.pem Path to the file containing the CA certificate for the server\u2019s TLS certificate when using a secured GoQuorum node connection . rpcclitls.cert \u00b6 Syntax --rpcclitls.cert <path>/<to>/<TLS-pem-file> Example --rpcclitls.cert certfile.pem Path to the file containing the server\u2019s TLS certificate when using a secured GoQuorum node connection . rpcclitls.ciphersuites \u00b6 Syntax --rpcclitls.ciphersuites <STRING> Example --rpcclitls.ciphersuites \"CIPHER_SUITE_1,CIPHER_SUITE_2\" Comma-separated list of cipher suites to support when using a secured GoQuorum node connection . rpcclitls.insecureskipverify \u00b6 Syntax --rpcclitls.insecureskipverify If included, disables verification of the server\u2019s TLS certificate when using a secured GoQuorum node connection . rpcclitoken \u00b6 Syntax --rpcclitoken <STRING> Example --rpcclitoken \"AYjcyMzY3ZDhiNmJkNTY\" JSON-RPC client access token when using a secured GoQuorum node connection . vm.calltimeout \u00b6 Syntax --vm.calltimeout <INTEGER> Example --vm.calltimeout 2 Timeout in seconds when executing eth_call . The default is 5.","title":"Command line options"},{"location":"reference/cli-syntax/#goquorum-command-line-options","text":"This reference describes the syntax of the GoQuorum command line interface (CLI) options. Important GoQuorum is based on the Geth Go Ethereum client but only the GoQuorum-specific CLI options are listed here. Visit the Go Ethereum documentation to view the CLI options for the geth command.","title":"GoQuorum command line options"},{"location":"reference/cli-syntax/#specifying-options","text":"You can specify GoQuorum options: On the command line. geth [ OPTIONS ] In a configuration file .","title":"Specifying options"},{"location":"reference/cli-syntax/#options","text":"","title":"Options"},{"location":"reference/cli-syntax/#allowedfutureblocktime","text":"Syntax --allowedfutureblocktime <INTEGER> Example --allowedfutureblocktime 1 Maximum time from current time allowed for blocks before they\u2019re considered future blocks, in seconds. This allows nodes to be slightly out of sync without receiving \u201cMining too far in the future\u201d messages. The default is 0.","title":"allowedfutureblocktime"},{"location":"reference/cli-syntax/#emitcheckpoints","text":"Syntax --emitcheckpoints If included, emits specially formatted logging checkpoints.","title":"emitcheckpoints"},{"location":"reference/cli-syntax/#immutabilitythreshold","text":"Syntax --immutabilitythreshold <INTEGER> Example --immutabilitythreshold 1000000 Overrides the default immutability threshold for GoQuorum nodes. Blocks below the immutability threshold are moved to the ancient data folder. The default is 3162240.","title":"immutabilitythreshold"},{"location":"reference/cli-syntax/#istanbulblockperiod","text":"Syntax --istanbul.blockperiod <INTEGER> Example --istanbul.blockperiod 5 Minimum time between two consecutive IBFT or QBFT blocks\u2019 timestamps in seconds. Setting the block period determines how quickly blocks should be minted by the validators. The default is 1. Warning Do not update this value after starting the network because this option is used by nodes to validate block times.","title":"istanbul.blockperiod"},{"location":"reference/cli-syntax/#istanbulrequesttimeout","text":"Syntax --istanbul.requesttimeout <INTEGER> Example --istanbul.requesttimeout 12000 Minimum request timeout for each IBFT or QBFT round in milliseconds. The request timeout is the timeout at which IBFT triggers a new round if the previous one did not complete. This period increases as the timeout is hit more often. The default is 10000.","title":"istanbul.requesttimeout"},{"location":"reference/cli-syntax/#multitenancy","text":"Syntax --multitenancy Example --multitenancy Enables multi-tenancy . This requires the JSON-RPC Security plugin to also be configured.","title":"multitenancy"},{"location":"reference/cli-syntax/#overrideistanbul","text":"Syntax --override.istanbul <INTEGER> Example --override.istanbul 100 Custom fork block when using IBFT or QBFT consensus. The default is 0.","title":"override.istanbul"},{"location":"reference/cli-syntax/#permissioned","text":"Syntax --permissioned Example --permissioned Enables basic network permissioning . The node allows only a defined list of nodes to connect.","title":"permissioned"},{"location":"reference/cli-syntax/#plugins","text":"Syntax --plugins file:///<path>/<to>/plugins.json Example --plugins file:///opt/geth/plugins.json URI of the plugins settings JSON file . Use this to configure plugins .","title":"plugins"},{"location":"reference/cli-syntax/#pluginslocalverify","text":"Syntax --plugins.localverify If included, verifies plugin integrity from the local file system. This requires a plugin signature file and PGP public key file to be available.","title":"plugins.localverify"},{"location":"reference/cli-syntax/#pluginspublickey","text":"Syntax --plugins.publickey file:///<path>/<to>/<publicKeyFile> Example --plugins.publickey file:///opt/geth/pubkey.pgp.asc URI of the PGP public key for local plugin verification . This option is only valid if --plugins.localverify is set.","title":"plugins.publickey"},{"location":"reference/cli-syntax/#pluginsskipverify","text":"Syntax --plugins.skipverify If included, disables the plugin verification process.","title":"plugins.skipverify"},{"location":"reference/cli-syntax/#privacymarkerenable","text":"Syntax --privacymarker.enable If included, GoQuorum creates a privacy marker transaction when a private transaction is submitted.","title":"privacymarker.enable"},{"location":"reference/cli-syntax/#ptmdialtimeout","text":"Syntax --ptm.dialtimeout <INTEGER> Example ---ptm.dialtimeout 0 Dial timeout in seconds for the private transaction manager connection . Setting to 0 disables the timeout. The default is 1 second.","title":"ptm.dialtimeout"},{"location":"reference/cli-syntax/#ptmhttpidletimeout","text":"Syntax --ptm.http.idletimeout <INTEGER> Example ---ptm.http.idletimeout 0 Idle timeout in seconds for the private transaction manager connection . Setting to 0 disables the timeout. The default is 10 seconds.","title":"ptm.http.idletimeout"},{"location":"reference/cli-syntax/#ptmhttpreadbuffersize","text":"Syntax --ptm.http.readbuffersize <INTEGER> Example ---ptm.http.readbuffersize 0 Size of the read buffer in bytes for the private transaction manager connection . Setting to 0 or not specifying uses the http.Transport default.","title":"ptm.http.readbuffersize"},{"location":"reference/cli-syntax/#ptmhttpwritebuffersize","text":"Syntax --ptm.http.writebuffersize <INTEGER> Example ---ptm.http.writebuffersize 0 Size of the write buffer in bytes for the private transaction manager connection . Setting to 0 or not specifying uses the http.Transport default.","title":"ptm.http.writebuffersize"},{"location":"reference/cli-syntax/#ptmsocket","text":"Syntax --ptm.socket <path>/<to>/<ipc>/<file> Example ---ptm.socket qdata/c1/tm.ipc Path to the IPC file when using a Unix domain socket for the private transaction manager connection .","title":"ptm.socket"},{"location":"reference/cli-syntax/#ptmtimeout","text":"Syntax --ptm.timeout <INTEGER> Example ---ptm.timeout 0 Timeout in seconds for communication over the private transaction manager connection . Setting to 0 disables the timeout. The default is 5 seconds.","title":"ptm.timeout"},{"location":"reference/cli-syntax/#ptmtlsclientcert","text":"Syntax --ptm.tls.clientcert <path>/<to>/<client_cert_pem_file> Example ---ptm.tls.clientcert client.cert.pem Path to the file containing the client certificate (or chain of certificates) when using a TLS connection to the private transaction manager . This is required if the server is configured to use two-way authentication.","title":"ptm.tls.clientcert"},{"location":"reference/cli-syntax/#ptmtlsclientkey","text":"Syntax --ptm.tls.clientkey <path>/<to>/<client_key_pem_file> Example ---ptm.tls.clientkey client.key.pem Path to the file containing the client\u2019s private key when using a TLS connection to private transaction manager . This is required if the server is configured to use two-way authentication.","title":"ptm.tls.clientkey"},{"location":"reference/cli-syntax/#ptmtlsinsecureskipverify","text":"Syntax --ptm.tls.insecureskipverify If included, disables verification of the server\u2019s TLS certificate on connection to private transaction manager .","title":"ptm.tls.insecureskipverify"},{"location":"reference/cli-syntax/#ptmtlsmode","text":"Syntax --ptm.tls.mode <STRING> Example ---ptm.tls.mode \"strict\" Setting to off disables TLS. Setting to strict enables TLS when using an HTTPS connection to the private transaction manager .","title":"ptm.tls.mode"},{"location":"reference/cli-syntax/#ptmtlsrootca","text":"Syntax --ptm.tls.rootca <path>/<to>/<rootca_pem_file> Example ---ptm.tls.rootca certfile.pem Path to the file containing the root CA certificate when using a TLS connection to the private transaction manager . The default is the host\u2019s certificates.","title":"ptm.tls.rootca"},{"location":"reference/cli-syntax/#ptmurl","text":"Syntax --ptm.url <URL> Example ---ptm.url \"https://127.0.0.1:9101\" URL when using an HTTP/HTTPS connection to the private transaction manager .","title":"ptm.url"},{"location":"reference/cli-syntax/#qlightclient","text":"Syntax --qlight.client Enables the qlight client P2P protocol.","title":"qlight.client"},{"location":"reference/cli-syntax/#qlightclientpsi","text":"Syntax --qlight.client.psi <STRING> Example --qlight.client.psi \"private\" PSI the qlight client uses to connect to a server node. The default is private .","title":"qlight.client.psi"},{"location":"reference/cli-syntax/#qlightclientrpctls","text":"Syntax --qlight.client.rpc.tls Enables the qlight client RPC connection to use TLS.","title":"qlight.client.rpc.tls"},{"location":"reference/cli-syntax/#qlightclientrpctlscacert","text":"Syntax --qlight.client.rpc.tls.cacert <path>/<to>/<client-RPC certicate-auth-file> Example --qlight.client.rpc.tls.cacert certfile.pem Path to the qlight client RPC client certificate authority file.","title":"qlight.client.rpc.tls.cacert"},{"location":"reference/cli-syntax/#qlightclientrpctlscert","text":"Syntax --qlight.client.rpc.tls.cert <path>/<to>/<client-RPC-client-certificate-file> Example --qlight.client.rpc.tls.cert certfile.pem Path to the qlight client RPC client certificate file.","title":"qlight.client.rpc.tls.cert"},{"location":"reference/cli-syntax/#qlightclientrpctlsinsecureskipverify","text":"Syntax --qlight.client.rpc.tls.insecureskipverify Enables the qlight client RPC connection to skip TLS verification.","title":"qlight.client.rpc.tls.insecureskipverify"},{"location":"reference/cli-syntax/#qlightclientrpctlskey","text":"Syntax --qlight.client.rpc.tls.key <path>/<to>/<client_TLS_key_pem_file> Example --qlight.client.rpc.tls.key client.TLS.key.pem Path to the qlight client RPC client certificate private key.","title":"qlight.client.rpc.tls.key"},{"location":"reference/cli-syntax/#qlightclientservernode","text":"Syntax --qlight.client.serverNode <nodeID> Example --qlight.client.serverNode 0xc35c3...d615f The node ID of the target server node.","title":"qlight.client.serverNode"},{"location":"reference/cli-syntax/#qlightclientservernoderpc","text":"Syntax --qlight.client.serverNodeRPC <URL> Example --qlight.client.serverNodeRPC \"http://127.0.0.1:8888\" The RPC URL of the target server node.","title":"qlight.client.serverNodeRPC"},{"location":"reference/cli-syntax/#qlightclienttokenenabled","text":"Syntax --qlight.client.token.enabled Enables the client to use a token when connecting to the qlight server.","title":"qlight.client.token.enabled"},{"location":"reference/cli-syntax/#qlightclienttokenmanagement","text":"Syntax --qlight.client.token.management <string> Example --qlight.client.token.management \"none\" Mechanism used to refresh the token. Possible values: none - Developer mode external - A new token must be injected via the qlight RPC API client-security-plugin - The client security plugin must be deployed/configured","title":"qlight.client.token.management"},{"location":"reference/cli-syntax/#qlightclienttokenvalue","text":"Syntax --qlight.client.token.value <TOKEN> Example --qlight.client.token.value \"bearer AYjcyMzY3ZDhiNmJkNTY\" Token the qlight client uses to connect to a server node.","title":"qlight.client.token.value"},{"location":"reference/cli-syntax/#qlightserver","text":"Syntax --qlight.server Enables the qlight server P2P protocol.","title":"qlight.server"},{"location":"reference/cli-syntax/#qlightserverp2pmaxpeers","text":"Syntax --qlight.server.p2p.maxpeers <INTEGER> Example --qlight.server.p2p.maxpeers 10 Maximum number of qlight peers. The default is 10.","title":"qlight.server.p2p.maxpeers"},{"location":"reference/cli-syntax/#qlightserverp2pnetrestrict","text":"Syntax --qlight.server.p2p.netrestrict <NETWORK MASK> Example --qlight.server.p2p.netrestrict \"xyz\" Restricts network communication to the given IP networks (CIDR masks).","title":"qlight.server.p2p.netrestrict"},{"location":"reference/cli-syntax/#qlightserverp2ppermissioning","text":"Syntax --qlight.server.p2p.permissioning Enables the qlight peers to check against a permissioned list and a disallowed list.","title":"qlight.server.p2p.permissioning"},{"location":"reference/cli-syntax/#qlightserverp2ppermissioningprefix","text":"Syntax --qlight.server.p2p.permissioning.prefix <prefix-filename> Example --qlight.server.p2p.permissioning.prefix \"permissioned-nodes.json\" Prefix for the permissioned-nodes.json and disallowed-nodes.json files.","title":"qlight.server.p2p.permissioning.prefix"},{"location":"reference/cli-syntax/#qlightserverp2pport","text":"Syntax --qlight.server.p2p.port = <INTEGER> Example --qlight.server.p2p.port = 30305 Port the qlight network listens to. The default is 30305.","title":"qlight.server.p2p.port"},{"location":"reference/cli-syntax/#qlighttls","text":"Syntax --qlight.tls Enables the qlight client P2P protocol to use TLS.","title":"qlight.tls"},{"location":"reference/cli-syntax/#qlighttlscacerts","text":"Syntax --qlight.tls.cacerts <path>/<to>/<qlight_tls_cacert_file> Example --qlight.tls.cacerts certfile.pem Path to the certificate authorities file to use for validating P2P connection.","title":"qlight.tls.cacerts"},{"location":"reference/cli-syntax/#qlighttlscert","text":"Syntax --qlight.tls.cert ` <path>/<to>/<qlight_tls_cert_file> Example --qlight.tls.cert certfile.pem Path to the certificate file to use for the qlight P2P connection.","title":"qlight.tls.cert"},{"location":"reference/cli-syntax/#qlighttlsciphersuites","text":"Syntax --qlight.tls.ciphersuites <STRING> Example --qlight.tls.ciphersuites \"CIPHER_SUITE_1,CIPHER_SUITE_2\" Cipher suites to use for the qlight P2P connection.","title":"qlight.tls.ciphersuites"},{"location":"reference/cli-syntax/#qlighttlsclientauth","text":"Syntax --qlight.tls.clientauth <INTEGER> Example --qlight.tls.clientauth 0 Sets the method the client is authenticated. Possible values: 0= NoClientCert This is the default. 1= RequestClientCert 2= RequireAnyClientCert 3= VerifyClientCertIfGiven 4= RequireAndVerifyClientCert","title":"qlight.tls.clientauth"},{"location":"reference/cli-syntax/#qlighttlskey","text":"Syntax --qlight.tls.key <path>/<to>/<qlight_tls_key_file> Example --qlight.tls.key certfile.pem Path to the key file to use for qlight P2P connection.","title":"qlight.tls.key"},{"location":"reference/cli-syntax/#raft","text":"Syntax --raft Example --raft Enables Raft for consensus.","title":"raft"},{"location":"reference/cli-syntax/#raftblocktime","text":"Syntax --raftblocktime <INTEGER> Example --raftblocktime 100 Time between Raft block creations in milliseconds. The default is 50.","title":"raftblocktime"},{"location":"reference/cli-syntax/#raftdnsenable","text":"Syntax --raftdnsenable Example --raftdnsenable Enables DNS resolution of peers .","title":"raftdnsenable"},{"location":"reference/cli-syntax/#raftjoinexisting","text":"Syntax --raftjoinexisting <INTEGER> Example --raftjoinexisting 1 Raft ID to assume when joining a pre-existing cluster . The default is 0.","title":"raftjoinexisting"},{"location":"reference/cli-syntax/#raftlogdir","text":"Syntax --raftlogdir <DIRECTORY> Example --raftlogdir raftlogdir Raft log directory used for the quorum-raft-state , raft-snap , and raft-wal folders. Defaults to the datadir option .","title":"raftlogdir"},{"location":"reference/cli-syntax/#raftport","text":"Syntax --raftport <PORT> Example --raftport 50500 Port to bind for the Raft transport . The default is 50400.","title":"raftport"},{"location":"reference/cli-syntax/#revertreason","text":"Syntax --revertreason Example --revertreason Enables including the revert reason in the eth_getTransactionReceipt response.","title":"revertreason"},{"location":"reference/cli-syntax/#rpcclitlscacert","text":"Syntax --rpcclitls.cacert <path>/<to>/<TLS-CA-pem-file> Example --rpcclitls.cacert certfile.pem Path to the file containing the CA certificate for the server\u2019s TLS certificate when using a secured GoQuorum node connection .","title":"rpcclitls.cacert"},{"location":"reference/cli-syntax/#rpcclitlscert","text":"Syntax --rpcclitls.cert <path>/<to>/<TLS-pem-file> Example --rpcclitls.cert certfile.pem Path to the file containing the server\u2019s TLS certificate when using a secured GoQuorum node connection .","title":"rpcclitls.cert"},{"location":"reference/cli-syntax/#rpcclitlsciphersuites","text":"Syntax --rpcclitls.ciphersuites <STRING> Example --rpcclitls.ciphersuites \"CIPHER_SUITE_1,CIPHER_SUITE_2\" Comma-separated list of cipher suites to support when using a secured GoQuorum node connection .","title":"rpcclitls.ciphersuites"},{"location":"reference/cli-syntax/#rpcclitlsinsecureskipverify","text":"Syntax --rpcclitls.insecureskipverify If included, disables verification of the server\u2019s TLS certificate when using a secured GoQuorum node connection .","title":"rpcclitls.insecureskipverify"},{"location":"reference/cli-syntax/#rpcclitoken","text":"Syntax --rpcclitoken <STRING> Example --rpcclitoken \"AYjcyMzY3ZDhiNmJkNTY\" JSON-RPC client access token when using a secured GoQuorum node connection .","title":"rpcclitoken"},{"location":"reference/cli-syntax/#vmcalltimeout","text":"Syntax --vm.calltimeout <INTEGER> Example --vm.calltimeout 2 Timeout in seconds when executing eth_call . The default is 5.","title":"vm.calltimeout"},{"location":"reference/genesis/","text":"Genesis file items \u00b6 The GoQuorum genesis file contains network configuration items and genesis block parameters . Configuration items \u00b6 Network configuration items are specified in the genesis file in the config object. Item Description Milestone blocks Milestone blocks for the network . chainId Chain ID for the network . istanbul Specifies network uses IBFT or QBFT and contains IBFT or QBFT configuration items, respectively. clique Specifies network uses Clique and contains Clique configuration items. txnSizeLimit Maximum transaction size. The default is 64 (kilobytes), increased from Ethereum\u2019s default 32 . This is configurable up to 128 . maxCodeSize Maximum smart contract code size. The default is 32 (kilobytes), increased from Ethereum\u2019s default 24 . This is configurable up to 128 . isQuorum Set to true to enable geth to work as GoQuorum and make additional checks, for example, ensure the gas fee is zero. Note Using the Raft consensus protocol doesn\u2019t require a specific item in the config object. Genesis block parameters \u00b6 The purpose of some genesis block parameters varies depending on the consensus protocol ( IBFT , QBFT , Raft , or Clique ). These parameters include: difficulty . extraData . mixHash . The following table describes the genesis block parameters with the same purpose across all consensus protocols. Item Description coinbase Address to pay mining rewards to. Can be any value in the genesis block (commonly set to 0x0000000000000000000000000000000000000000 ). gasLimit Block gas limit. Total gas limit for all transactions in a block. nonce Used in block computation. Can be any value in the genesis block (commonly set to 0x0 ). timestamp Creation date and time of the block. Must be before the next block so we recommend specifying 0x0 in the genesis file. alloc Defines accounts with balances or contracts . Milestone blocks \u00b6 In public networks, the milestone blocks specify the blocks at which the network changed protocol. Ethereum Mainnet milestone blocks { \"config\" : { ... \"homesteadBlock\" : 1150000 , \"daoForkBlock\" : 1920000 , \"daoForkSupport\" : true , \"eip150Block\" : 2463000 , \"eip150Hash\" : \"0x2086799aeebeae135c246c65021c82b4e15a2c451340993aacfd2751886514f0\" , \"eip155Block\" : 2675000 , \"eip158Block\" : 2675000 , \"byzantiumBlock\" : 4370000 , \"constantinopleBlock\" : 7280000 , \"constantinopleFixBlock\" : 7280000 , ... }, } In private networks, the milestone block defines the protocol version for the network. Private network milestone blocks { \"config\" : { ... \"constantinopleFixBlock\" : 0 , ... }, } Tip When specifying the milestone block for private networks, you only need to specify the latest milestone. It is implied this includes the preceding milestones.","title":"Genesis file items"},{"location":"reference/genesis/#genesis-file-items","text":"The GoQuorum genesis file contains network configuration items and genesis block parameters .","title":"Genesis file items"},{"location":"reference/genesis/#configuration-items","text":"Network configuration items are specified in the genesis file in the config object. Item Description Milestone blocks Milestone blocks for the network . chainId Chain ID for the network . istanbul Specifies network uses IBFT or QBFT and contains IBFT or QBFT configuration items, respectively. clique Specifies network uses Clique and contains Clique configuration items. txnSizeLimit Maximum transaction size. The default is 64 (kilobytes), increased from Ethereum\u2019s default 32 . This is configurable up to 128 . maxCodeSize Maximum smart contract code size. The default is 32 (kilobytes), increased from Ethereum\u2019s default 24 . This is configurable up to 128 . isQuorum Set to true to enable geth to work as GoQuorum and make additional checks, for example, ensure the gas fee is zero. Note Using the Raft consensus protocol doesn\u2019t require a specific item in the config object.","title":"Configuration items"},{"location":"reference/genesis/#genesis-block-parameters","text":"The purpose of some genesis block parameters varies depending on the consensus protocol ( IBFT , QBFT , Raft , or Clique ). These parameters include: difficulty . extraData . mixHash . The following table describes the genesis block parameters with the same purpose across all consensus protocols. Item Description coinbase Address to pay mining rewards to. Can be any value in the genesis block (commonly set to 0x0000000000000000000000000000000000000000 ). gasLimit Block gas limit. Total gas limit for all transactions in a block. nonce Used in block computation. Can be any value in the genesis block (commonly set to 0x0 ). timestamp Creation date and time of the block. Must be before the next block so we recommend specifying 0x0 in the genesis file. alloc Defines accounts with balances or contracts .","title":"Genesis block parameters"},{"location":"reference/genesis/#milestone-blocks","text":"In public networks, the milestone blocks specify the blocks at which the network changed protocol. Ethereum Mainnet milestone blocks { \"config\" : { ... \"homesteadBlock\" : 1150000 , \"daoForkBlock\" : 1920000 , \"daoForkSupport\" : true , \"eip150Block\" : 2463000 , \"eip150Hash\" : \"0x2086799aeebeae135c246c65021c82b4e15a2c451340993aacfd2751886514f0\" , \"eip155Block\" : 2675000 , \"eip158Block\" : 2675000 , \"byzantiumBlock\" : 4370000 , \"constantinopleBlock\" : 7280000 , \"constantinopleFixBlock\" : 7280000 , ... }, } In private networks, the milestone block defines the protocol version for the network. Private network milestone blocks { \"config\" : { ... \"constantinopleFixBlock\" : 0 , ... }, } Tip When specifying the milestone block for private networks, you only need to specify the latest milestone. It is implied this includes the preceding milestones.","title":"Milestone blocks"},{"location":"reference/goquorum-projects/","text":"GoQuorum projects \u00b6 See the awesome-quorum repository for a list of projects and samples highlighting GoQuorum functionality. quorum-examples is the official sample repository; it provides the means to easily create pre-configured networks for testing and development.","title":"GoQuorum projects"},{"location":"reference/goquorum-projects/#goquorum-projects","text":"See the awesome-quorum repository for a list of projects and samples highlighting GoQuorum functionality. quorum-examples is the official sample repository; it provides the means to easily create pre-configured networks for testing and development.","title":"GoQuorum projects"},{"location":"reference/logging-and-errors/","text":"Logs & errors reference \u00b6 Although there is sufficient logging in GoQuorum ( geth ), the error messages are not always straightforward to decipher. This is our take on cataloguing of error messages along with possible cause and remediation actions, to serve as first point of reference before reaching out to the support team. Note The log level \u201cERROR\u201d is written out in uppercase as part of the log message and can be used for alert monitoring. Reference \u00b6 Message & Parameters Cause Action \"Unable to attach to remote geth: %v\", err This issue occurs when attempting to attach to a local geth node which is not running Check if the geth process is running, if not then restart it. Note that if the geth process crashed or was force-killed, the ipc file can exist even though the node is not running. \"unable to connect to private tx manager using %s due to %s\", socketPath, err This issue occurs when geth is unable to connect to the private transaction manager Check that the transaction manager is running, if not then restart it \"Could not search for pattern\", \"pattern\", pattern, \"contract\", contracts[types[i]], \"err\", err Generated by abigen due to an internal error when generating ABI for a contract Raise an issue ticket \"account listing failed\", \"error\", err Call to Clef API method account_list failed Depends on the error detail in the log message \"operation SelfDerive not supported on external signers\" An unsupported operation was performed by an external wallet Contact the third party provider of the wallet \"Failed to enumerate smart card readers\", \"err\", err A failure occurred when scanning for smart card wallets The logged message should contain further error details and determine the action to take \"Failed to enumerate USB devices\", \"hub\", hub.scheme, \"vendor\", hub.vendorID, \"failcount\", failcount, \"err\", err A failure occurred when scanning for USB wallets. The logged message should contain further error details Depends on the error detail in the log message, if not using USB wallets then add --nousb to command line \"Import error\", \"err\", err Message is generated when using geth import and indicates an issue with the import file You need to use a valid import file \"Import error\", \"file\", arg, \"err\", err Message is generated when using geth import and indicates an issue with the named import file You need to use a valid import file \"Failed to retrieve signer address\", \"err\", err Message is generated when using puppeth and indicates an issue with signer JSON key file Ensure you have a valid key file \"Bootstrap URL invalid\", \"enode\", url, \"err\", err One or more enode values specified on the command line for a bootstrap node, is not a valid url. You need to provide a correct url \"Invalid smartcard daemon path\", \"path\", path, \"type\", fi.Mode().String() This message is generated if the socket file specified for the smartcard daemon (pcscd) is not actually a socket file Ensure that the daemon is running and the correct socket file is specified on the command line \"Failed to get signer address\", \"err\", err This indicates that the public address could not be obtained for the signature on a message in an IBFT network. This is potentially an internal error or an issue with the crypto package. Depends on the root cause in the log message - an issue ticket may need to be raised \"Failed to serialize JavaScript exception\", \"exception\", msg, \"err\", err This is an internal error, occurring if the given message could not be serialized into a JavaScript message by the Otto JS parser. Raise an issue ticket \"Non contiguous block insert\", \"number\", block.Number(), \"hash\", block.Hash() Message is generated if an \u2018out of sequence\u2019 block is received for insertion into the chain. This usually occurs if node is out of sync or holds a corrupt chain. See instructions under the section on Resolution of database corruption issues \"Non contiguous receipt insert\", \"number\", blockChain[i].Number(), \"hash\", blockChain[i].Hash(), \"parent\", blockChain[i].ParentHash() Message is generated if an \u2018out of sequence\u2019 receipt is received for insertion. This usually occurs if node is out of sync or holds corrupt data. See instructions under the section on Resolution of database corruption issues \"Found bad hash, rewinding chain\", \"number\", header.Number, \"hash\", header.ParentHash Message is generated on startup if a block is found in the database with one of a set \u2018bad hash\u2019 values predefined in core/blocks.go . The node will rewind the chain to prior to the bad hash and resync from that point No action should be necessary as node will rewind and recover \"Chain rewind was successful, resuming normal operation\" This message is generated after the chain has been rewound following a \u201cFound bad hash, rewinding chain\u201d message No action is necessary \"Impossible reorg, please file an issue\", \"oldnum\", oldBlock.Number(), \"oldhash\", oldBlock.Hash(), \"newnum\", newBlock.Number(), \"newhash\", newBlock.Hash() This can occur if there was an issue during sync See section on Impossible reorg for actions \"########## BAD BLOCK #########\" This can occur if there was an issue inserting a new block into the chain See section on Bad block for actions \"Failed to commit recent state trie\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Dangling trie nodes after full cleanup\" This occurs if the in-memory cache was not fully flushed to the underlying database during shutdown No action is possible \"Failed writing private state root\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Non contiguous header insert\", \"number\", chain[i].Number, \"hash\", chain[i].Hash() This message is generated if blocks are received with non-contiguous block numbers or block hashes This is most likely a coding error - raise an issue ticket \"Pricing query for empty pool\" This message is generated to catch a coding error scenario Raise an issue ticket \"Demoting invalidated transaction\", \"hash\", hash This occurs if a nonce gap appears in the pending queue after housekeeping (which should not happen) No action should be necessary as the transactions are automatically moved to the non-executable queue \"Unrooted old chain seen by tx pool\", \"block\", oldHead.Number, \"hash\", oldHead.Hash() This can happen on a chain reorg and indicates that the block at the head of the \u2018old\u2019 chain did not have a valid parent hash. This may cause issues with the contents of the transaction pool. In order to ensure integrity of the transaction pool, it may be necessary to follow the instructions under the section on Resolution of database corruption issues \"Unrooted new chain seen by tx pool\", \"block\", newHead.Number, \"hash\", newHead.Hash() This can happen on a chain reorg and indicates that the block at the head of the \u2018new\u2019 chain did not have a valid parent hash. This may cause issues with the contents of the transaction pool. In order to ensure integrity of the transaction pool, it may be necessary to follow the instructions under the section on Resolution of database corruption issues \"Failed to reset txpool state\", \"err\", err This indicates that the transaction pool state could not be retrieved after a reorg; the err message will provide more detail This can be down to mis-configuration, or a corrupt database. See instructions under the section on Resolution of database corruption issues \"Impossible fork ID validation\", \"id\", id This indicates that an internal error occurred when validating the fork ID for chain compatibility checks as per EIP-2124 Raise an issue ticket \"Invalid block body RLP\", \"hash\", hash, \"err\", err This occurs if a block retrieved from the database could not be decode. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid block header RLP\", \"hash\", hash, \"err\", err This occurs if a block header retrieved from the database could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid receipt array RLP\", \"hash\", hash, \"err\", err This occurs if the transaction receipts retrieved from the database for a block, could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Missing body but have receipt\", \"hash\", hash, \"number\", number This occurs if the block body relating to a transaction receipt could not be retrieved from the database. This implies there is an issue with the database or an internal error occurred. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Failed to derive block receipts fields\", \"hash\", hash, \"number\", number, \"err\", err This occurs if the transaction information relating to a receipt could not be retrieved from the database. This implies there is an issue with the database or an internal error occurred. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid block total difficulty RLP\", \"hash\", hash, \"err\", err This occurs if the block difficulty was retrieved from the database but could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Receipt not found\", \"number\", blockNumber, \"hash\", blockHash, \"txhash\", hash This occurs if a transaction receipt could not be retrieved from the database for the block which contains it. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Transaction referenced missing\", \"number\", blockNumber, \"hash\", blockHash This occurs if a transaction could not be retrieved from the database for the block which contains it. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Transaction not found\", \"number\", blockNumber, \"hash\", blockHash, \"txhash\", hash This occurs if transaction data could not be retrieved from the database for a known transaction. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid transaction lookup entry RLP\", \"hash\", hash, \"blob\", data, \"err\", err This occurs if a transaction retrieved from the database could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid chain config JSON\", \"hash\", hash, \"err\", err This occurs if the chain configuration JSON read from the database could not be un-marshalled. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Database contains unaccounted data\", \"size\", unaccounted This occurs if unrecognised/unaccounted data is found in the database. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Failed to append ancient hash\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient header\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient body\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient receipts\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient difficulty\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Current full block number unavailable\", \"hash\", hash This occurs if the block number for the current head block could not be read from the database when checking whether any blocks can be moved to the freezer. This implies there is an issue with the chain database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Current full block unavailable\", \"number\", *number, \"hash\", hash This occurs if the data for the current head block could not be read from the database when checking whether any blocks can be moved to the freezer. This implies there is an issue with the chain database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Canonical hash missing, can't freeze\", \"number\", f.frozen This occurs if the hash for a block could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Block header missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if a block header could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Block body missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if a block could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Block receipts missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if the receipts for a block could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Total difficulty missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if the block difficuly could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Failed to decode the value returned by iterator\", \"error\", err This is most likely due to an internal error. Raise an issue ticket \"Failed to decode state object\", \"addr\", addr, \"err\", err This occurs if state data retrieved from the database could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"EIP activation failed\", \"eip\", eip, \"error\", err This is most likely due to an internal error. Raise an issue ticket \"Unknown metered peer event type\", \"type\", event.Type This occurs if an unknown event message type was received from a peer. This implies an internal error or some incompatibility between nodes. Raise an issue ticket \"Cannot set etherbase in Istanbul consensus\" This occurs if an attempt is made to perform the miner_setEtherbase() API call - this is not allowed if Istanbul consensus is in use Action is not possible \"Cannot start mining without etherbase\", \"err\", err This occurs if the etherbase account is not set. Note that for some consensus mechanisms, this is automatically set to the signing account. Ensure node has an etherbase account set up \"Etherbase account unavailable locally\", \"err\", err This occurs if the clique consensus mechanism is used and the configured signing account (etherbase) could not be found in the wallet. Check the configuration - in particular that the signing account defined in the genesis extradata matches the value in the keystore and is set up as a local account \"Propagating dangling block\", \"number\", block.Number(), \"hash\", hash This occurs when propagating a block to peers, if the block does not have a parent. Raise an issue ticket (this scenario should never occur in normal operation) \"Failed to encode receipt\", \"err\", err The list of receipts for a block could not be RLP encoded. The error detail should give more information and will determine the action to be taken \"Peer removal failed\", \"peer\", id, \"err\", err A request to remove a peer failed. The error detail should give more information and will determine the action to be taken, but it is most likely caused by attempting to remove a peer that was already removed \"Unknown downloader chain/mode combo\", \"light\", d.lightchain != nil, \"full\", d.blockchain != nil, \"mode\", d.mode This occurs if the node was unable to report sync progress due to an invalid combination of downloader type and sync mode. Raise an issue ticket (this scenario should never occur in normal operation) \"Failure in running pprof server\", \"err\", err This occurs if the pprof HTTP server could not be started. The error detail should give more information and will determine the action to be taken \"Database compaction failed\", \"err\", err A database error occurred during DB compaction. The error detail should give more information and will determine the action to be taken. It may be necessary to follow instructions under the section on Resolution of database corruption issues \"Oracle contract binding failed\", \"err\", err This occurs when using a checkpoint oracle contract and means that the node could not bind to the oracle contract. The error detail should give more information and will determine the action to be taken \"Already bound and listening to registrar\" This occurs when using a checkpoint oracle contract and means that the there is already a binding in place for the oracle contract. No action is necessary \"Refusing to mine without etherbase\" This indicates that the node is set up to mint blocks, but the coinbase account is not set. Check the configuration is correct for the consensus mechanism in use \"Failed to prepare header for mining\", \"err\", err This occurs when a node is attempting to create a block, but fails during the preparation stage when creating the header. The error detail should give more information and will determine the action to be taken \"Failed to create mining context\", \"err\", err This means an error has occurred when setting up the state after creation of a new block. Raise an issue ticket \"Failed to fetch pending transactions\", \"err\", err This error should never occur. Raise an issue ticket \"Block found but no relative pending task\", \"number\", block.Number(), \"sealhash\", sealhash, \"hash\", hash This indicates that an internal error has occurred. Raise an issue ticket \"Failed writing block to chain\", \"err\", err This indicates that a failure occurred when committing a block and associated state to the database. The error detail should give more information and will determine the action to be taken \"Failed writing private block bloom\", \"err\", err This indicates that a failure occurred when writing a bloom filter to the database for private transaction receipts. The error detail should give more information and will determine the action to be taken \"Failed to persist node key: %v\", err This occurs if the node is unable to save a newly generated node key into the file specified by the configuration. The error detail should give more information and will determine the action to be taken \"Can't load node list file: %v\", err This occurs if the node is unable to read static node information from the static-nodes.json (or trusted-nodes.json) file. Check that the file exists in the expected location and that it contains valid JSON \"Node URL %s: %v\", url, err This indicates that there is a mis-configured URL in the static-nodes.json (or trusted-nodes.json) file. Check and correct the offending URL in the JSON file \"Read Error for permissioned-nodes.json file. This is because 'permissioned' flag is specified but no permissioned-nodes.json file is present.\", \"err\", err This is self-explanatory Either remove the --permissioned flag or add permissioned-nodes.json file \"parsePermissionedNodes: Failed to access nodes\", \"err\", err This indicates that the file permissioned-nodes.json could not be read. The error detail should give more information and will determine the action to be taken \"parsePermissionedNodes: Failed to load nodes\", \"err\", err This indicates that the node information in permissioned-nodes.json could not be unmarshalled. Check that the contents of the file are well-formed \"parsePermissionedNodes: Node URL blank\" This indicates that an entry in permissioned-nodes.json has an empty node URL. Either remove the node details or specify a valid URL \"parsePermissionedNodes: Node URL\", \"url\", url, \"err\", err This indicates that an entry in permissioned-nodes.json is not valid. Check that the entry with this URL is correctly formatted \"Failed to expire nodedb items: %v\", err This message should never be seen Raise an issue ticket \"error encoding packet:\", err A message could not be RLP encoded prior to sending to a peer node. The error detail should give more information and will determine the action to be taken \"could not sign packet:\", err A message could not be signed prior to sending to a peer node. The error detail should give more information and will determine the action to be taken \"Failed to execute permission action\", \"action\", action, \"err\", err This indicates a problem when invoking the specified action on the permissions contract. The error detail should give more information and will determine the action to be taken \"bootupNetwork SetPolicy failed\", \"err\", err This indicates an issue occurred when invoking setPolicy() on the permissions contract. The error detail should give more information and will determine the action to be taken, but it is most likely due to misconfiguration of the permissions contract(s) \"bootupNetwork init failed\", \"err\", err This indicates an issue occurred when invoking init() on the permissions contract. The error detail should give more information and will determine the action to be taken, but it is most likely due to misconfiguration of the permissions contract(s) \"failed to updated network boot status\", \"error\", err This indicates an issue occurred when invoking updateNetworkBootStatus() on the permissions contract. The error detail should give more information and will determine the action to be taken, but it is most likely due to misconfiguration of the permissions contract(s) \"failed to get raft id\", \"err\", err, \"enodeId\", enodeId This occurs with Raft consensus, if the permission contract generates a NodeDeactivated event, but a Raft id could not be found for the enodeId that is being removed. Check whether the node has already been removed, if not then this may be an internal error and a ticket should be raised \"failed parse node id\", \"err\", err, \"enodeId\", enodeId This occurs with clique/istanbul consensus, if the permission contract generates a NodeDeactivated event, but the enodeId could not be correctly parsed for the node that is being removed. Raise an issue ticket \"Revoke role - cache is missing role\", \"org\", evtRoleRevoked.OrgId, \"role\", evtRoleRevoked.RoleId This occurs if the permission contract generates a RoleRevoked event, but the specified role could not be found in the cache. Raise an issue ticket \"can't open file\", \"file\", fullPath, \"error\", err This indicates that the specified file could not be opened. Check that the file exists at the given path and has read permission \"error reading file\", \"err\", err, \"file\", fullPath This indicates that the specified file could not be read. The error detail should give more information and will determine the action to be taken \"error unmarshalling the file\", \"err\", err, \"file\", fullPath This indicates that the contents of the specified file could not be unmarshalled. Check that the file contains valid JSON \"Read Error for disallowed-nodes.json file\", \"err\", err This indicates that the disallowed-nodes.json file could not be read. This message is normally logged the first time a node is being added to the file, in which case no action is needed \"Failed to create disallowed-nodes.json file\", \"err\", err This indicates that the disallowed-nodes.json file could not be created. Check that the data directory location for this file is writeable \"Failed to access the file\", \"fileName\", fileName, \"err\", err This indicates that the specified file could not be read. Check that the file exists at the given path and has read permission \"Failed to load nodes list from file\", \"fileName\", fileName, \"err\", err This indicates that the contents of the specified file could not be unmarshalled. Check that the file contains valid JSON \"Error writing new node info to file\", \"fileName\", fileName, \"err\", err This indicates that the specified file could not be created. Check that the location for this file is writeable \"unable to delegate RPC API calls to plugin\", \"provider\", interfaceName, \"error\", err This message is generated by the plugin service if it fails to delegate an RPC call to the specified provider. The error detail should give more information and will determine the action to be taken, however it is most likely due to misconfiguration \"error decoding pub key from enodeId\", \"enodeId\", address.NodeId.String(), \"err\", err This occurs when adding a node for Raft consensus, and the enodId could not be decoded into a public key. Ensure the correct enodeId is specified \"failed to extend chain: %s\", err.Error() This occurs if the node was unable to add a new block to the chain when using Raft consensus. The error detail should give more information and will determine the action to be taken. Note that it may occur during node shutdown with error detail abort during blocks processing , in which case it can be ignored. \"error decoding block\", \"err\", err This can occur on a Raft node when restoring a snapshot if a block could not be decoded. Most likely the Raft snapshot is corrupt. Raft may recover, or a restart may be required; if not, the data directory to be deleted and the node resynced. \"error inserting the block into the chain\", \"number\", block.NumberU64(), \"hash\", block.Hash(), \"err\", err This can occur on a Raft node when restoring a snapshot if a block could not be added to the chain. The node may be out of sync or hold a corrupt chain. The error detail should give more information. Raft may recover, or a restart may be required; if not, the data directory to be deleted and the node resynced. \"RPC method \" + method + \" crashed: \" + err) This indicates that an issue occurred when responding to an RPC call. The error detail should give more information, however check that the arguments for the RPC call are correct \"Invalid smartcard socket file type\", \"path\", scpath, \"type\", fi.Mode().String() This message is generated by clef if the socket file specified for the smartcard daemon (pcscd) is not actually a socket file. Ensure that the daemon is running and the correct socket file is specified on the clef command line \"Failed to commit preimage from trie database\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Failed to write flush list to disk\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Failed to commit trie from trie database\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Failed to write trie to disk\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Attempted to dereference the trie cache meta root\" This occurs if an error occurred during garbage collection. The node may need a restart \"Unhandled trie error: %v\", err This indicates that an error occurred when retrieving data from a trie. The error detail should give more information; it may be necessary to follow the instructions under the section on Resolution of database corruption issues Fatal: Error starting protocol stack: can't download from Plugin Central due to: HTTP GET error: code=404, status=404 Not Found, body=The requested path was not found.. Please download the plugin manually and copy it to <dir> The provided plugin config does not match any available plugins in the Central server Check name and version fields in plugin definition config are correct Fatal: Error starting protocol stack: stat <dir>/Central.pgp.pk: no such file or directory A default public key cannot be found to verify the integrity of plugins Create the necessary key at this path or use the --plugins.publickey flag to use an alternative path \"plugins: unable to create reader due to %s\", err An issue occurred when reading the plugin config file specified with --plugin . Ensure the correct config file name is specified on the command line and contents are correct . The logged message will contain further details which may help. \"plugins: unable to resolve plugin base dir due to %s\", err Incorrect value of baseDir in the plugin config file specified with --plugin . Ensure the baseDir value is correct in the config file . The logged message will contain further details which may help. \"Plugin failed to start\", \"error\", err, \"took\", time.Since(startTime) GoQuorum failed to start a configured plugin. Ensure that all vaues in the config file are correct and that any required separate plugin processes are running. The logged message will contain further details which may help. \"Error parsing version components from the tessera version: %s. Unable to extract transaction manager features.\", version GoQuorum is configured to use Tessera as the transaction manager, but failed to parse the API version number returned by the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). \"Error invoking the tessera /version/api API: %v.\", err GoQuorum is configured to use Tessera as the transaction manager, but failed to retrieve the API version number from the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). \"Invalid status code returned by the tessera /version/api API: %d.\", res.StatusCode GoQuorum is configured to use Tessera as the transaction manager, but failed to retrieve the API version number from the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). \"Unable to deserialize the tessera response for /version/api API: %v.\", err GoQuorum is configured to use Tessera as the transaction manager, but failed to parse the API version number returned by the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). More details \u00b6 Impossible reorganisation (reorg) issue \u00b6 Impossible reorganisation issues can occur if there was an issue during sync. Possible causes are: Node was not cleanly shutdown previously, causing database corruption An edge case where two sealers generate blocks at the exact same time (depends on consensus type in use) Insufficient resources (disk or memory) Some (unknown) issue during resync The action to be taken will depend on the cause. Note that more recent versions of GoQuorum may already include fixes to prevent some of these issues. In the event of database corruption, see instructions below for Resolution of database corruption issues . Bad block issue \u00b6 This can occur if there was an issue when inserting a new block into the chain and is logged in the form: ########## BAD BLOCK ######### Chain config: %v Number: %v Hash: 0x%x 'transaction receipt' Error: %v ############################## The error detail gives more information as to the root cause. Here are a few possibilities and suggested actions: \"invalid gas used\" : This occurs if the local node calculates a different gas usage for transactions than the node which created the block. This may be due to a configuration issue. \"insufficient balance to pay for gas\" : This is similar to \"invalid gas used\" , but occurs when there is insufficient gas to complete a transaction. \"invalid merkle root\" : Cause is usually a corrupted database or failed import. See instructions under the section on Resolution of database corruption issues . \"unknown ancestor\" : This is usually due to an issue with fast sync. Restarting the node may resolve it. \"blacklisted hash\" : The cause and resolution of this is like the \"Found bad hash, rewinding chain\" error. Note that more recent versions of GoQuorum may already include fixes to prevent some of these issues. Resolution of database corruption issues \u00b6 Corruption of the database (chain data) can occur due to lack of resources, or after a \u2018forced\u2019 shutdown. Sometimes, GoQuorum will recover automatically or require a restart of the failing node. If the node does not recover then it may require the chaindata to be deleted and resynced. The chain data can be removed by shutting down the node and running geth removedb --datadir /path/to/data/directory . If Raft consensus is in use, then the Raft logs must also be removed before restarting the node, these consist of all directories containing raft under the data directory.","title":"Logging and errors"},{"location":"reference/logging-and-errors/#logs-errors-reference","text":"Although there is sufficient logging in GoQuorum ( geth ), the error messages are not always straightforward to decipher. This is our take on cataloguing of error messages along with possible cause and remediation actions, to serve as first point of reference before reaching out to the support team. Note The log level \u201cERROR\u201d is written out in uppercase as part of the log message and can be used for alert monitoring.","title":"Logs &amp; errors reference"},{"location":"reference/logging-and-errors/#reference","text":"Message & Parameters Cause Action \"Unable to attach to remote geth: %v\", err This issue occurs when attempting to attach to a local geth node which is not running Check if the geth process is running, if not then restart it. Note that if the geth process crashed or was force-killed, the ipc file can exist even though the node is not running. \"unable to connect to private tx manager using %s due to %s\", socketPath, err This issue occurs when geth is unable to connect to the private transaction manager Check that the transaction manager is running, if not then restart it \"Could not search for pattern\", \"pattern\", pattern, \"contract\", contracts[types[i]], \"err\", err Generated by abigen due to an internal error when generating ABI for a contract Raise an issue ticket \"account listing failed\", \"error\", err Call to Clef API method account_list failed Depends on the error detail in the log message \"operation SelfDerive not supported on external signers\" An unsupported operation was performed by an external wallet Contact the third party provider of the wallet \"Failed to enumerate smart card readers\", \"err\", err A failure occurred when scanning for smart card wallets The logged message should contain further error details and determine the action to take \"Failed to enumerate USB devices\", \"hub\", hub.scheme, \"vendor\", hub.vendorID, \"failcount\", failcount, \"err\", err A failure occurred when scanning for USB wallets. The logged message should contain further error details Depends on the error detail in the log message, if not using USB wallets then add --nousb to command line \"Import error\", \"err\", err Message is generated when using geth import and indicates an issue with the import file You need to use a valid import file \"Import error\", \"file\", arg, \"err\", err Message is generated when using geth import and indicates an issue with the named import file You need to use a valid import file \"Failed to retrieve signer address\", \"err\", err Message is generated when using puppeth and indicates an issue with signer JSON key file Ensure you have a valid key file \"Bootstrap URL invalid\", \"enode\", url, \"err\", err One or more enode values specified on the command line for a bootstrap node, is not a valid url. You need to provide a correct url \"Invalid smartcard daemon path\", \"path\", path, \"type\", fi.Mode().String() This message is generated if the socket file specified for the smartcard daemon (pcscd) is not actually a socket file Ensure that the daemon is running and the correct socket file is specified on the command line \"Failed to get signer address\", \"err\", err This indicates that the public address could not be obtained for the signature on a message in an IBFT network. This is potentially an internal error or an issue with the crypto package. Depends on the root cause in the log message - an issue ticket may need to be raised \"Failed to serialize JavaScript exception\", \"exception\", msg, \"err\", err This is an internal error, occurring if the given message could not be serialized into a JavaScript message by the Otto JS parser. Raise an issue ticket \"Non contiguous block insert\", \"number\", block.Number(), \"hash\", block.Hash() Message is generated if an \u2018out of sequence\u2019 block is received for insertion into the chain. This usually occurs if node is out of sync or holds a corrupt chain. See instructions under the section on Resolution of database corruption issues \"Non contiguous receipt insert\", \"number\", blockChain[i].Number(), \"hash\", blockChain[i].Hash(), \"parent\", blockChain[i].ParentHash() Message is generated if an \u2018out of sequence\u2019 receipt is received for insertion. This usually occurs if node is out of sync or holds corrupt data. See instructions under the section on Resolution of database corruption issues \"Found bad hash, rewinding chain\", \"number\", header.Number, \"hash\", header.ParentHash Message is generated on startup if a block is found in the database with one of a set \u2018bad hash\u2019 values predefined in core/blocks.go . The node will rewind the chain to prior to the bad hash and resync from that point No action should be necessary as node will rewind and recover \"Chain rewind was successful, resuming normal operation\" This message is generated after the chain has been rewound following a \u201cFound bad hash, rewinding chain\u201d message No action is necessary \"Impossible reorg, please file an issue\", \"oldnum\", oldBlock.Number(), \"oldhash\", oldBlock.Hash(), \"newnum\", newBlock.Number(), \"newhash\", newBlock.Hash() This can occur if there was an issue during sync See section on Impossible reorg for actions \"########## BAD BLOCK #########\" This can occur if there was an issue inserting a new block into the chain See section on Bad block for actions \"Failed to commit recent state trie\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Dangling trie nodes after full cleanup\" This occurs if the in-memory cache was not fully flushed to the underlying database during shutdown No action is possible \"Failed writing private state root\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Non contiguous header insert\", \"number\", chain[i].Number, \"hash\", chain[i].Hash() This message is generated if blocks are received with non-contiguous block numbers or block hashes This is most likely a coding error - raise an issue ticket \"Pricing query for empty pool\" This message is generated to catch a coding error scenario Raise an issue ticket \"Demoting invalidated transaction\", \"hash\", hash This occurs if a nonce gap appears in the pending queue after housekeeping (which should not happen) No action should be necessary as the transactions are automatically moved to the non-executable queue \"Unrooted old chain seen by tx pool\", \"block\", oldHead.Number, \"hash\", oldHead.Hash() This can happen on a chain reorg and indicates that the block at the head of the \u2018old\u2019 chain did not have a valid parent hash. This may cause issues with the contents of the transaction pool. In order to ensure integrity of the transaction pool, it may be necessary to follow the instructions under the section on Resolution of database corruption issues \"Unrooted new chain seen by tx pool\", \"block\", newHead.Number, \"hash\", newHead.Hash() This can happen on a chain reorg and indicates that the block at the head of the \u2018new\u2019 chain did not have a valid parent hash. This may cause issues with the contents of the transaction pool. In order to ensure integrity of the transaction pool, it may be necessary to follow the instructions under the section on Resolution of database corruption issues \"Failed to reset txpool state\", \"err\", err This indicates that the transaction pool state could not be retrieved after a reorg; the err message will provide more detail This can be down to mis-configuration, or a corrupt database. See instructions under the section on Resolution of database corruption issues \"Impossible fork ID validation\", \"id\", id This indicates that an internal error occurred when validating the fork ID for chain compatibility checks as per EIP-2124 Raise an issue ticket \"Invalid block body RLP\", \"hash\", hash, \"err\", err This occurs if a block retrieved from the database could not be decode. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid block header RLP\", \"hash\", hash, \"err\", err This occurs if a block header retrieved from the database could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid receipt array RLP\", \"hash\", hash, \"err\", err This occurs if the transaction receipts retrieved from the database for a block, could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Missing body but have receipt\", \"hash\", hash, \"number\", number This occurs if the block body relating to a transaction receipt could not be retrieved from the database. This implies there is an issue with the database or an internal error occurred. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Failed to derive block receipts fields\", \"hash\", hash, \"number\", number, \"err\", err This occurs if the transaction information relating to a receipt could not be retrieved from the database. This implies there is an issue with the database or an internal error occurred. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid block total difficulty RLP\", \"hash\", hash, \"err\", err This occurs if the block difficulty was retrieved from the database but could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Receipt not found\", \"number\", blockNumber, \"hash\", blockHash, \"txhash\", hash This occurs if a transaction receipt could not be retrieved from the database for the block which contains it. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Transaction referenced missing\", \"number\", blockNumber, \"hash\", blockHash This occurs if a transaction could not be retrieved from the database for the block which contains it. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Transaction not found\", \"number\", blockNumber, \"hash\", blockHash, \"txhash\", hash This occurs if transaction data could not be retrieved from the database for a known transaction. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid transaction lookup entry RLP\", \"hash\", hash, \"blob\", data, \"err\", err This occurs if a transaction retrieved from the database could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Invalid chain config JSON\", \"hash\", hash, \"err\", err This occurs if the chain configuration JSON read from the database could not be un-marshalled. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Database contains unaccounted data\", \"size\", unaccounted This occurs if unrecognised/unaccounted data is found in the database. This implies there is an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Failed to append ancient hash\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient header\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient body\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient receipts\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Failed to append ancient difficulty\", \"number\", f.frozen, \"hash\", hash, \"err\", err This occurs if \u2018ancient\u2019 data could not be appended to the tables in the freezer database. This implies there is an issue with the database. Raise an issue ticket or try to resolve by removing the freezer database and performing a resync of the node \"Current full block number unavailable\", \"hash\", hash This occurs if the block number for the current head block could not be read from the database when checking whether any blocks can be moved to the freezer. This implies there is an issue with the chain database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Current full block unavailable\", \"number\", *number, \"hash\", hash This occurs if the data for the current head block could not be read from the database when checking whether any blocks can be moved to the freezer. This implies there is an issue with the chain database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"Canonical hash missing, can't freeze\", \"number\", f.frozen This occurs if the hash for a block could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Block header missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if a block header could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Block body missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if a block could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Block receipts missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if the receipts for a block could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Total difficulty missing, can't freeze\", \"number\", f.frozen, \"hash\", hash This occurs if the block difficuly could not be read from either the chain database or the freezer and may cause archiving to halt. This could be an internal error or an issue with either database. Raise an issue ticket or try to resolve by removing chain database and freezer, and resync of the node \"Failed to decode the value returned by iterator\", \"error\", err This is most likely due to an internal error. Raise an issue ticket \"Failed to decode state object\", \"addr\", addr, \"err\", err This occurs if state data retrieved from the database could not be decoded. This implies an internal error or an issue with the database. Raise an issue ticket or follow instructions under the section on Resolution of database corruption issues \"EIP activation failed\", \"eip\", eip, \"error\", err This is most likely due to an internal error. Raise an issue ticket \"Unknown metered peer event type\", \"type\", event.Type This occurs if an unknown event message type was received from a peer. This implies an internal error or some incompatibility between nodes. Raise an issue ticket \"Cannot set etherbase in Istanbul consensus\" This occurs if an attempt is made to perform the miner_setEtherbase() API call - this is not allowed if Istanbul consensus is in use Action is not possible \"Cannot start mining without etherbase\", \"err\", err This occurs if the etherbase account is not set. Note that for some consensus mechanisms, this is automatically set to the signing account. Ensure node has an etherbase account set up \"Etherbase account unavailable locally\", \"err\", err This occurs if the clique consensus mechanism is used and the configured signing account (etherbase) could not be found in the wallet. Check the configuration - in particular that the signing account defined in the genesis extradata matches the value in the keystore and is set up as a local account \"Propagating dangling block\", \"number\", block.Number(), \"hash\", hash This occurs when propagating a block to peers, if the block does not have a parent. Raise an issue ticket (this scenario should never occur in normal operation) \"Failed to encode receipt\", \"err\", err The list of receipts for a block could not be RLP encoded. The error detail should give more information and will determine the action to be taken \"Peer removal failed\", \"peer\", id, \"err\", err A request to remove a peer failed. The error detail should give more information and will determine the action to be taken, but it is most likely caused by attempting to remove a peer that was already removed \"Unknown downloader chain/mode combo\", \"light\", d.lightchain != nil, \"full\", d.blockchain != nil, \"mode\", d.mode This occurs if the node was unable to report sync progress due to an invalid combination of downloader type and sync mode. Raise an issue ticket (this scenario should never occur in normal operation) \"Failure in running pprof server\", \"err\", err This occurs if the pprof HTTP server could not be started. The error detail should give more information and will determine the action to be taken \"Database compaction failed\", \"err\", err A database error occurred during DB compaction. The error detail should give more information and will determine the action to be taken. It may be necessary to follow instructions under the section on Resolution of database corruption issues \"Oracle contract binding failed\", \"err\", err This occurs when using a checkpoint oracle contract and means that the node could not bind to the oracle contract. The error detail should give more information and will determine the action to be taken \"Already bound and listening to registrar\" This occurs when using a checkpoint oracle contract and means that the there is already a binding in place for the oracle contract. No action is necessary \"Refusing to mine without etherbase\" This indicates that the node is set up to mint blocks, but the coinbase account is not set. Check the configuration is correct for the consensus mechanism in use \"Failed to prepare header for mining\", \"err\", err This occurs when a node is attempting to create a block, but fails during the preparation stage when creating the header. The error detail should give more information and will determine the action to be taken \"Failed to create mining context\", \"err\", err This means an error has occurred when setting up the state after creation of a new block. Raise an issue ticket \"Failed to fetch pending transactions\", \"err\", err This error should never occur. Raise an issue ticket \"Block found but no relative pending task\", \"number\", block.Number(), \"sealhash\", sealhash, \"hash\", hash This indicates that an internal error has occurred. Raise an issue ticket \"Failed writing block to chain\", \"err\", err This indicates that a failure occurred when committing a block and associated state to the database. The error detail should give more information and will determine the action to be taken \"Failed writing private block bloom\", \"err\", err This indicates that a failure occurred when writing a bloom filter to the database for private transaction receipts. The error detail should give more information and will determine the action to be taken \"Failed to persist node key: %v\", err This occurs if the node is unable to save a newly generated node key into the file specified by the configuration. The error detail should give more information and will determine the action to be taken \"Can't load node list file: %v\", err This occurs if the node is unable to read static node information from the static-nodes.json (or trusted-nodes.json) file. Check that the file exists in the expected location and that it contains valid JSON \"Node URL %s: %v\", url, err This indicates that there is a mis-configured URL in the static-nodes.json (or trusted-nodes.json) file. Check and correct the offending URL in the JSON file \"Read Error for permissioned-nodes.json file. This is because 'permissioned' flag is specified but no permissioned-nodes.json file is present.\", \"err\", err This is self-explanatory Either remove the --permissioned flag or add permissioned-nodes.json file \"parsePermissionedNodes: Failed to access nodes\", \"err\", err This indicates that the file permissioned-nodes.json could not be read. The error detail should give more information and will determine the action to be taken \"parsePermissionedNodes: Failed to load nodes\", \"err\", err This indicates that the node information in permissioned-nodes.json could not be unmarshalled. Check that the contents of the file are well-formed \"parsePermissionedNodes: Node URL blank\" This indicates that an entry in permissioned-nodes.json has an empty node URL. Either remove the node details or specify a valid URL \"parsePermissionedNodes: Node URL\", \"url\", url, \"err\", err This indicates that an entry in permissioned-nodes.json is not valid. Check that the entry with this URL is correctly formatted \"Failed to expire nodedb items: %v\", err This message should never be seen Raise an issue ticket \"error encoding packet:\", err A message could not be RLP encoded prior to sending to a peer node. The error detail should give more information and will determine the action to be taken \"could not sign packet:\", err A message could not be signed prior to sending to a peer node. The error detail should give more information and will determine the action to be taken \"Failed to execute permission action\", \"action\", action, \"err\", err This indicates a problem when invoking the specified action on the permissions contract. The error detail should give more information and will determine the action to be taken \"bootupNetwork SetPolicy failed\", \"err\", err This indicates an issue occurred when invoking setPolicy() on the permissions contract. The error detail should give more information and will determine the action to be taken, but it is most likely due to misconfiguration of the permissions contract(s) \"bootupNetwork init failed\", \"err\", err This indicates an issue occurred when invoking init() on the permissions contract. The error detail should give more information and will determine the action to be taken, but it is most likely due to misconfiguration of the permissions contract(s) \"failed to updated network boot status\", \"error\", err This indicates an issue occurred when invoking updateNetworkBootStatus() on the permissions contract. The error detail should give more information and will determine the action to be taken, but it is most likely due to misconfiguration of the permissions contract(s) \"failed to get raft id\", \"err\", err, \"enodeId\", enodeId This occurs with Raft consensus, if the permission contract generates a NodeDeactivated event, but a Raft id could not be found for the enodeId that is being removed. Check whether the node has already been removed, if not then this may be an internal error and a ticket should be raised \"failed parse node id\", \"err\", err, \"enodeId\", enodeId This occurs with clique/istanbul consensus, if the permission contract generates a NodeDeactivated event, but the enodeId could not be correctly parsed for the node that is being removed. Raise an issue ticket \"Revoke role - cache is missing role\", \"org\", evtRoleRevoked.OrgId, \"role\", evtRoleRevoked.RoleId This occurs if the permission contract generates a RoleRevoked event, but the specified role could not be found in the cache. Raise an issue ticket \"can't open file\", \"file\", fullPath, \"error\", err This indicates that the specified file could not be opened. Check that the file exists at the given path and has read permission \"error reading file\", \"err\", err, \"file\", fullPath This indicates that the specified file could not be read. The error detail should give more information and will determine the action to be taken \"error unmarshalling the file\", \"err\", err, \"file\", fullPath This indicates that the contents of the specified file could not be unmarshalled. Check that the file contains valid JSON \"Read Error for disallowed-nodes.json file\", \"err\", err This indicates that the disallowed-nodes.json file could not be read. This message is normally logged the first time a node is being added to the file, in which case no action is needed \"Failed to create disallowed-nodes.json file\", \"err\", err This indicates that the disallowed-nodes.json file could not be created. Check that the data directory location for this file is writeable \"Failed to access the file\", \"fileName\", fileName, \"err\", err This indicates that the specified file could not be read. Check that the file exists at the given path and has read permission \"Failed to load nodes list from file\", \"fileName\", fileName, \"err\", err This indicates that the contents of the specified file could not be unmarshalled. Check that the file contains valid JSON \"Error writing new node info to file\", \"fileName\", fileName, \"err\", err This indicates that the specified file could not be created. Check that the location for this file is writeable \"unable to delegate RPC API calls to plugin\", \"provider\", interfaceName, \"error\", err This message is generated by the plugin service if it fails to delegate an RPC call to the specified provider. The error detail should give more information and will determine the action to be taken, however it is most likely due to misconfiguration \"error decoding pub key from enodeId\", \"enodeId\", address.NodeId.String(), \"err\", err This occurs when adding a node for Raft consensus, and the enodId could not be decoded into a public key. Ensure the correct enodeId is specified \"failed to extend chain: %s\", err.Error() This occurs if the node was unable to add a new block to the chain when using Raft consensus. The error detail should give more information and will determine the action to be taken. Note that it may occur during node shutdown with error detail abort during blocks processing , in which case it can be ignored. \"error decoding block\", \"err\", err This can occur on a Raft node when restoring a snapshot if a block could not be decoded. Most likely the Raft snapshot is corrupt. Raft may recover, or a restart may be required; if not, the data directory to be deleted and the node resynced. \"error inserting the block into the chain\", \"number\", block.NumberU64(), \"hash\", block.Hash(), \"err\", err This can occur on a Raft node when restoring a snapshot if a block could not be added to the chain. The node may be out of sync or hold a corrupt chain. The error detail should give more information. Raft may recover, or a restart may be required; if not, the data directory to be deleted and the node resynced. \"RPC method \" + method + \" crashed: \" + err) This indicates that an issue occurred when responding to an RPC call. The error detail should give more information, however check that the arguments for the RPC call are correct \"Invalid smartcard socket file type\", \"path\", scpath, \"type\", fi.Mode().String() This message is generated by clef if the socket file specified for the smartcard daemon (pcscd) is not actually a socket file. Ensure that the daemon is running and the correct socket file is specified on the clef command line \"Failed to commit preimage from trie database\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Failed to write flush list to disk\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Failed to commit trie from trie database\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Failed to write trie to disk\", \"err\", err This occurs if an error occurred when writing to the underlying database. Most likely cause is lack of resources, or corrupt database. See instructions under the section on Resolution of database corruption issues \"Attempted to dereference the trie cache meta root\" This occurs if an error occurred during garbage collection. The node may need a restart \"Unhandled trie error: %v\", err This indicates that an error occurred when retrieving data from a trie. The error detail should give more information; it may be necessary to follow the instructions under the section on Resolution of database corruption issues Fatal: Error starting protocol stack: can't download from Plugin Central due to: HTTP GET error: code=404, status=404 Not Found, body=The requested path was not found.. Please download the plugin manually and copy it to <dir> The provided plugin config does not match any available plugins in the Central server Check name and version fields in plugin definition config are correct Fatal: Error starting protocol stack: stat <dir>/Central.pgp.pk: no such file or directory A default public key cannot be found to verify the integrity of plugins Create the necessary key at this path or use the --plugins.publickey flag to use an alternative path \"plugins: unable to create reader due to %s\", err An issue occurred when reading the plugin config file specified with --plugin . Ensure the correct config file name is specified on the command line and contents are correct . The logged message will contain further details which may help. \"plugins: unable to resolve plugin base dir due to %s\", err Incorrect value of baseDir in the plugin config file specified with --plugin . Ensure the baseDir value is correct in the config file . The logged message will contain further details which may help. \"Plugin failed to start\", \"error\", err, \"took\", time.Since(startTime) GoQuorum failed to start a configured plugin. Ensure that all vaues in the config file are correct and that any required separate plugin processes are running. The logged message will contain further details which may help. \"Error parsing version components from the tessera version: %s. Unable to extract transaction manager features.\", version GoQuorum is configured to use Tessera as the transaction manager, but failed to parse the API version number returned by the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). \"Error invoking the tessera /version/api API: %v.\", err GoQuorum is configured to use Tessera as the transaction manager, but failed to retrieve the API version number from the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). \"Invalid status code returned by the tessera /version/api API: %d.\", res.StatusCode GoQuorum is configured to use Tessera as the transaction manager, but failed to retrieve the API version number from the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available). \"Unable to deserialize the tessera response for /version/api API: %v.\", err GoQuorum is configured to use Tessera as the transaction manager, but failed to parse the API version number returned by the running Tessera process. This is most likely due to using an older version of Tessera, prior to v1.0. You should upgrade your Tessera (note that geth will continue to run, but some privacy features may not be available).","title":"Reference"},{"location":"reference/logging-and-errors/#more-details","text":"","title":"More details"},{"location":"reference/logging-and-errors/#impossible-reorganisation-reorg-issue","text":"Impossible reorganisation issues can occur if there was an issue during sync. Possible causes are: Node was not cleanly shutdown previously, causing database corruption An edge case where two sealers generate blocks at the exact same time (depends on consensus type in use) Insufficient resources (disk or memory) Some (unknown) issue during resync The action to be taken will depend on the cause. Note that more recent versions of GoQuorum may already include fixes to prevent some of these issues. In the event of database corruption, see instructions below for Resolution of database corruption issues .","title":"Impossible reorganisation (reorg) issue"},{"location":"reference/logging-and-errors/#bad-block-issue","text":"This can occur if there was an issue when inserting a new block into the chain and is logged in the form: ########## BAD BLOCK ######### Chain config: %v Number: %v Hash: 0x%x 'transaction receipt' Error: %v ############################## The error detail gives more information as to the root cause. Here are a few possibilities and suggested actions: \"invalid gas used\" : This occurs if the local node calculates a different gas usage for transactions than the node which created the block. This may be due to a configuration issue. \"insufficient balance to pay for gas\" : This is similar to \"invalid gas used\" , but occurs when there is insufficient gas to complete a transaction. \"invalid merkle root\" : Cause is usually a corrupted database or failed import. See instructions under the section on Resolution of database corruption issues . \"unknown ancestor\" : This is usually due to an issue with fast sync. Restarting the node may resolve it. \"blacklisted hash\" : The cause and resolution of this is like the \"Found bad hash, rewinding chain\" error. Note that more recent versions of GoQuorum may already include fixes to prevent some of these issues.","title":"Bad block issue"},{"location":"reference/logging-and-errors/#resolution-of-database-corruption-issues","text":"Corruption of the database (chain data) can occur due to lack of resources, or after a \u2018forced\u2019 shutdown. Sometimes, GoQuorum will recover automatically or require a restart of the failing node. If the node does not recover then it may require the chaindata to be deleted and resynced. The chain data can be removed by shutting down the node and running geth removedb --datadir /path/to/data/directory . If Raft consensus is in use, then the Raft logs must also be removed before restarting the node, these consist of all directories containing raft under the data directory.","title":"Resolution of database corruption issues"},{"location":"reference/permissioning-types/","text":"Permissioning types \u00b6 This reference describes account access and status types for permissioning . Account access types \u00b6 When setting the account access, the system checks if the account setting the access has sufficient privileges to grant account access. The following table indicates the numeric value and granting privileges for each account access type. AccessType Value Granting Privileges ReadOnly 0 none Transact 1 Transact and ReadOnly ContractDeploy 2 ContractDeploy, Transact, and ReadOnly FullAccess 3 any Accounts with FullAccess can grant any access type. Accounts with ContractDeploy can grant only Transact , ContractDeploy or ReadOnly access to other accounts. Accounts with Transact access can grant only Transact or ReadOnly access to other accounts. Accounts with ReadOnly access cannot grant any access. Organization status types \u00b6 The following table indicates the numeric value for each organization status. OrgStatus Value NotInList 0 Proposed 1 Approved 2 PendingSuspension 3 Suspended 4 AwaitingSuspensionRevoke 5 Account status types \u00b6 The following table indicates the numeric value for each account status. AccountStatus Value Not In List 0 Pending Approval 1 Active 2 Suspended 4 Denylisted 5 Revoked 6 Recovery initiated for Denylisted accounts 7 Node status types \u00b6 The following table indicates the numeric value for each node status. NodeStatus Value NotInList 0 PendingApproval 1 Approved 2 Deactivated 3 Denylisted 4 Recovery initiated for Denylisted Node 5","title":"Permissioning types"},{"location":"reference/permissioning-types/#permissioning-types","text":"This reference describes account access and status types for permissioning .","title":"Permissioning types"},{"location":"reference/permissioning-types/#account-access-types","text":"When setting the account access, the system checks if the account setting the access has sufficient privileges to grant account access. The following table indicates the numeric value and granting privileges for each account access type. AccessType Value Granting Privileges ReadOnly 0 none Transact 1 Transact and ReadOnly ContractDeploy 2 ContractDeploy, Transact, and ReadOnly FullAccess 3 any Accounts with FullAccess can grant any access type. Accounts with ContractDeploy can grant only Transact , ContractDeploy or ReadOnly access to other accounts. Accounts with Transact access can grant only Transact or ReadOnly access to other accounts. Accounts with ReadOnly access cannot grant any access.","title":"Account access types"},{"location":"reference/permissioning-types/#organization-status-types","text":"The following table indicates the numeric value for each organization status. OrgStatus Value NotInList 0 Proposed 1 Approved 2 PendingSuspension 3 Suspended 4 AwaitingSuspensionRevoke 5","title":"Organization status types"},{"location":"reference/permissioning-types/#account-status-types","text":"The following table indicates the numeric value for each account status. AccountStatus Value Not In List 0 Pending Approval 1 Active 2 Suspended 4 Denylisted 5 Revoked 6 Recovery initiated for Denylisted accounts 7","title":"Account status types"},{"location":"reference/permissioning-types/#node-status-types","text":"The following table indicates the numeric value for each node status. NodeStatus Value NotInList 0 PendingApproval 1 Approved 2 Deactivated 3 Denylisted 4 Recovery initiated for Denylisted Node 5","title":"Node status types"},{"location":"reference/web3js-quorum/","text":"web3js-quorum library \u00b6 The web3js-quorum Ethereum JavaScript library extends web3.js and adds supports for GoQuorum and Hyperledger Besu specific JSON-RPC APIs and features. Note The web3js-quorum library replaces the deprecated quorum.js and web3js-eea libraries, and includes all the features of both libraries. The web3js-quorum documentation contains information about the available APIs and features.","title":"Web3js-quorum"},{"location":"reference/web3js-quorum/#web3js-quorum-library","text":"The web3js-quorum Ethereum JavaScript library extends web3.js and adds supports for GoQuorum and Hyperledger Besu specific JSON-RPC APIs and features. Note The web3js-quorum library replaces the deprecated quorum.js and web3js-eea libraries, and includes all the features of both libraries. The web3js-quorum documentation contains information about the available APIs and features.","title":"web3js-quorum library"},{"location":"reference/plugins/account/","text":"Account plugins \u00b6 For developers \u00b6 You can develop new account plugins to extend the supported account management options for GoQuorum and clef . account plugins must follow the gRPC API interface requirements . To simplify the development of new account plugins, the following account plugin SDKs are available: Name Language quorum-account-plugin-sdk-go Go For users \u00b6 See how to use account plugins .","title":"Account"},{"location":"reference/plugins/account/#account-plugins","text":"","title":"Account plugins"},{"location":"reference/plugins/account/#for-developers","text":"You can develop new account plugins to extend the supported account management options for GoQuorum and clef . account plugins must follow the gRPC API interface requirements . To simplify the development of new account plugins, the following account plugin SDKs are available: Name Language quorum-account-plugin-sdk-go Go","title":"For developers"},{"location":"reference/plugins/account/#for-users","text":"See how to use account plugins .","title":"For users"},{"location":"reference/plugins/security/","text":"Security plugins \u00b6 For developers \u00b6 You can develop new security plugins to customize protection of the JSON-RPC server. security plugins must follow the gRPC API interface requirements . To simplify the development of new security plugins the following security plugin SDKs are available: Name Language quorum-security-plugin-sdk-go Go For users \u00b6 GoQuorum provides an official plugin implementation that: Provides TLS configuration to HTTP and WS transports. Enables the geth JSON-RPC (HTTP/WS) server to be an OAuth2-compliant resource server. See how to use the security plugin . Configuration \u00b6 One of the following blocks must be configured: { \"tls\" : objec t (TLSCo nf igura t io n ) , \"tokenValidation\" : objec t (Toke n Valida t io n Co nf igura t io n ) } Field Description tls (Optional) The TLS configuration . tokenValidation (Optional) Configuration to verify access token and extract granted authorities from the token . TLSConfiguration \u00b6 { \"auto\" : bool , \"certFile\" : E n viro n me nt AwaredValue , \"keyFile\" : E n viro n me nt AwaredValue , \"advanced\" : objec t (TLSAdva n cedCo nf igura t io n ) } Field Description auto If true, generate a self-signed TLS certificate. Then save the generated certificate and private key in PEM format in certFile and keyFile respectively If false, use values from certFile and keyFile . certFile Location to a file storing certificate in PEM format. The default is cert.pem . keyFile Location to a file storing private key in PEM format. The default is key.pem . advanced Additional TLS configuration. TLSAdvancedConfiguration \u00b6 { \"cipherSuites\" : array } Field Description cipherSuites List of cipher suites to be enforced. The default is: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA View the list of supported cipher suites . TokenValidationConfiguration \u00b6 { \"issuers\" : array , \"cache\" : objec t (CacheCo nf igura t io n ) , \"introspect\" : objec t (I ntr ospec t io n Co nf igura t io n ) , \"jws\" : objec t (JWSCo nf igura t io n ) , \"jwt\" : objec t (JWTCo nf igura t io n ) , } Field Description issuers Array of strings specifying approved entities who issue tokens. cache Configuration of a token cache. introspect Configuration of how to connect to the introspection API. jws Configuration of how to obtain a JSON Web Keyset to validate a JSON Web Signature. jwt Configuration of how to handle a JSON Web Token. CacheConfiguration \u00b6 An LRU cache that checks for expiration before returning the value. If not specified, the default configuration is as follows: { \"limit\" : 80 , \"expirationInSeconds\" : 3600 } Field Description limit Maximum number of items in the cache. expirationInSeconds Expiration time for a cache item. IntrospectionConfiguration \u00b6 { \"endpoint\" : s tr i n g , \"authentication\" : objec t (Au t he nt ica t io n Co nf igura t io n ) , \"tlsConnection\" : objec t (TLSCo nne c t io n Co nf igura t io n ) } Field Description endpoint Introspection API endpoint. authentication Configuration of how to authenticate when invoking endpoint . tlsConnection Configuration of TLS when connecting to endpoint . AuthenticationConfiguration \u00b6 { \"method\" : s tr i n g , \"credentials\" : map(s tr i n g - >E n viro n me nt AwaredValue) } Field Description method Defines an authentication mechanism. Supported values are: client_secret_basic : basic authentication client_secret_form : form authentication private_key : mutual TLS authentication credentials Defines the key value pair used for method . See the following table for the supported keys. Method Keys client_secret_basic clientId , clientSecret client_secret_form clientId , clientSecret private_key certFile , keyFile TLSConnectionConfiguration \u00b6 { \"insecureSkipVerify\" : bool , \"certFile\" : E n viro n me nt AwaredValue , \"caFile\" : E n viro n me nt AwaredValue } Field Description insecureSkipVerify If true, GoQuorum doesn\u2019t verify the server TLS certificate. certFile Location to a file storing the server certificate in PEM format. The default is server.crt . caFile Location to a file storing the server CA certificate in PEM format. The default is server.ca.cert . JWSConfiguration \u00b6 { \"endpoint\" : s tr i n g , \"tlsConnection\" : objec t (TLSCo nne c t io n Co nf igura t io n ) } Field Description endpoint API endpoint to obtain a JSON Web Keyset. tlsConnection Configuration of TLS when connecting to endpoint . JWTConfiguration \u00b6 { \"authorizationField\" : s tr i n g , \"preferIntrospection\" : bool } Field Description authorizationField Claim field name that is used to extract scopes for authorization. The default is scope . preferIntrospection If true, the introspection result (if defined) is used. EnvironmentAwaredValue \u00b6 A regular string that allows values to be read from environment variables by specifying a URI with env scheme. For example, env://MY_VAR returns the value from the MY_VAR environment variable. Supported cipher suites \u00b6 TLS_RSA_WITH_RC4_128_SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA TLS_RSA_WITH_AES_128_CBC_SHA TLS_RSA_WITH_AES_256_CBC_SHA TLS_RSA_WITH_AES_128_CBC_SHA256 TLS_RSA_WITH_AES_128_GCM_SHA256 TLS_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA TLS_ECDHE_RSA_WITH_RC4_128_SHA TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 OAuth2 Authz Server integration \u00b6 You can view examples on how to integrate Quorum Security Plugin with an OAuth2 Authorization Server . OAuth2 Scopes \u00b6 Scope is a mechanism to limit a client\u2019s access to protected resources in a GoQuorum client RPC server. A client can request one or more scopes from a token endpoint of an OAuth2 Provider. The access token issued to the client is limited to the scopes granted. The scope syntax is as follows: scope := \"rpc://\"rpc-string rpc-string := service-name delimiter method-name service-name := string delimiter := \".\" or \"_\" method-name := string Example scopes: Protecting APIs Scope Description rpc://web3.clientVersion Allow access to the web3_clientVersion API. rpc://eth_* or rpc://eth_ Allow access to all APIs under the eth namespace. rpc://*_version or rpc://_version Allow access to the version method of all namespaces. For example, net_version , ssh_version .","title":"Security"},{"location":"reference/plugins/security/#security-plugins","text":"","title":"Security plugins"},{"location":"reference/plugins/security/#for-developers","text":"You can develop new security plugins to customize protection of the JSON-RPC server. security plugins must follow the gRPC API interface requirements . To simplify the development of new security plugins the following security plugin SDKs are available: Name Language quorum-security-plugin-sdk-go Go","title":"For developers"},{"location":"reference/plugins/security/#for-users","text":"GoQuorum provides an official plugin implementation that: Provides TLS configuration to HTTP and WS transports. Enables the geth JSON-RPC (HTTP/WS) server to be an OAuth2-compliant resource server. See how to use the security plugin .","title":"For users"},{"location":"reference/plugins/security/#configuration","text":"One of the following blocks must be configured: { \"tls\" : objec t (TLSCo nf igura t io n ) , \"tokenValidation\" : objec t (Toke n Valida t io n Co nf igura t io n ) } Field Description tls (Optional) The TLS configuration . tokenValidation (Optional) Configuration to verify access token and extract granted authorities from the token .","title":"Configuration"},{"location":"reference/plugins/security/#tlsconfiguration","text":"{ \"auto\" : bool , \"certFile\" : E n viro n me nt AwaredValue , \"keyFile\" : E n viro n me nt AwaredValue , \"advanced\" : objec t (TLSAdva n cedCo nf igura t io n ) } Field Description auto If true, generate a self-signed TLS certificate. Then save the generated certificate and private key in PEM format in certFile and keyFile respectively If false, use values from certFile and keyFile . certFile Location to a file storing certificate in PEM format. The default is cert.pem . keyFile Location to a file storing private key in PEM format. The default is key.pem . advanced Additional TLS configuration.","title":"TLSConfiguration"},{"location":"reference/plugins/security/#tlsadvancedconfiguration","text":"{ \"cipherSuites\" : array } Field Description cipherSuites List of cipher suites to be enforced. The default is: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA View the list of supported cipher suites .","title":"TLSAdvancedConfiguration"},{"location":"reference/plugins/security/#tokenvalidationconfiguration","text":"{ \"issuers\" : array , \"cache\" : objec t (CacheCo nf igura t io n ) , \"introspect\" : objec t (I ntr ospec t io n Co nf igura t io n ) , \"jws\" : objec t (JWSCo nf igura t io n ) , \"jwt\" : objec t (JWTCo nf igura t io n ) , } Field Description issuers Array of strings specifying approved entities who issue tokens. cache Configuration of a token cache. introspect Configuration of how to connect to the introspection API. jws Configuration of how to obtain a JSON Web Keyset to validate a JSON Web Signature. jwt Configuration of how to handle a JSON Web Token.","title":"TokenValidationConfiguration"},{"location":"reference/plugins/security/#cacheconfiguration","text":"An LRU cache that checks for expiration before returning the value. If not specified, the default configuration is as follows: { \"limit\" : 80 , \"expirationInSeconds\" : 3600 } Field Description limit Maximum number of items in the cache. expirationInSeconds Expiration time for a cache item.","title":"CacheConfiguration"},{"location":"reference/plugins/security/#introspectionconfiguration","text":"{ \"endpoint\" : s tr i n g , \"authentication\" : objec t (Au t he nt ica t io n Co nf igura t io n ) , \"tlsConnection\" : objec t (TLSCo nne c t io n Co nf igura t io n ) } Field Description endpoint Introspection API endpoint. authentication Configuration of how to authenticate when invoking endpoint . tlsConnection Configuration of TLS when connecting to endpoint .","title":"IntrospectionConfiguration"},{"location":"reference/plugins/security/#authenticationconfiguration","text":"{ \"method\" : s tr i n g , \"credentials\" : map(s tr i n g - >E n viro n me nt AwaredValue) } Field Description method Defines an authentication mechanism. Supported values are: client_secret_basic : basic authentication client_secret_form : form authentication private_key : mutual TLS authentication credentials Defines the key value pair used for method . See the following table for the supported keys. Method Keys client_secret_basic clientId , clientSecret client_secret_form clientId , clientSecret private_key certFile , keyFile","title":"AuthenticationConfiguration"},{"location":"reference/plugins/security/#tlsconnectionconfiguration","text":"{ \"insecureSkipVerify\" : bool , \"certFile\" : E n viro n me nt AwaredValue , \"caFile\" : E n viro n me nt AwaredValue } Field Description insecureSkipVerify If true, GoQuorum doesn\u2019t verify the server TLS certificate. certFile Location to a file storing the server certificate in PEM format. The default is server.crt . caFile Location to a file storing the server CA certificate in PEM format. The default is server.ca.cert .","title":"TLSConnectionConfiguration"},{"location":"reference/plugins/security/#jwsconfiguration","text":"{ \"endpoint\" : s tr i n g , \"tlsConnection\" : objec t (TLSCo nne c t io n Co nf igura t io n ) } Field Description endpoint API endpoint to obtain a JSON Web Keyset. tlsConnection Configuration of TLS when connecting to endpoint .","title":"JWSConfiguration"},{"location":"reference/plugins/security/#jwtconfiguration","text":"{ \"authorizationField\" : s tr i n g , \"preferIntrospection\" : bool } Field Description authorizationField Claim field name that is used to extract scopes for authorization. The default is scope . preferIntrospection If true, the introspection result (if defined) is used.","title":"JWTConfiguration"},{"location":"reference/plugins/security/#environmentawaredvalue","text":"A regular string that allows values to be read from environment variables by specifying a URI with env scheme. For example, env://MY_VAR returns the value from the MY_VAR environment variable.","title":"EnvironmentAwaredValue"},{"location":"reference/plugins/security/#supported-cipher-suites","text":"TLS_RSA_WITH_RC4_128_SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA TLS_RSA_WITH_AES_128_CBC_SHA TLS_RSA_WITH_AES_256_CBC_SHA TLS_RSA_WITH_AES_128_CBC_SHA256 TLS_RSA_WITH_AES_128_GCM_SHA256 TLS_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA TLS_ECDHE_RSA_WITH_RC4_128_SHA TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305","title":"Supported cipher suites"},{"location":"reference/plugins/security/#oauth2-authz-server-integration","text":"You can view examples on how to integrate Quorum Security Plugin with an OAuth2 Authorization Server .","title":"OAuth2 Authz Server integration"},{"location":"reference/plugins/security/#oauth2-scopes","text":"Scope is a mechanism to limit a client\u2019s access to protected resources in a GoQuorum client RPC server. A client can request one or more scopes from a token endpoint of an OAuth2 Provider. The access token issued to the client is limited to the scopes granted. The scope syntax is as follows: scope := \"rpc://\"rpc-string rpc-string := service-name delimiter method-name service-name := string delimiter := \".\" or \"_\" method-name := string Example scopes: Protecting APIs Scope Description rpc://web3.clientVersion Allow access to the web3_clientVersion API. rpc://eth_* or rpc://eth_ Allow access to all APIs under the eth namespace. rpc://*_version or rpc://_version Allow access to the version method of all namespaces. For example, net_version , ssh_version .","title":"OAuth2 Scopes"},{"location":"tutorials/create-permissioned-network/","text":"Create a permissioned network with basic permissioning \u00b6 This tutorial shows you how to create a permissioned network with basic permissioning . 1. Initialize chain \u00b6 The first step is to generate the genesis block. The 7nodes directory in the quorum-examples repository contains several keys (using an empty password) that are used in the example genesis file: key1 vote key 1 key2 vote key 2 key3 vote key 3 key4 block maker 1 key5 block maker 2 Example genesis file (copy to genesis.json ): \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"isQuorum\" : true }, Initialize geth: geth init genesis.json 2. Setup bootnode \u00b6 Optionally you can set up a bootnode that all the other nodes will first connect to in order to find other peers in the network. You will first need to generate a bootnode key: To generate the key for the first time: bootnode -genkey tmp_file.txt // this will start a bootnode with an enode address and generate a key inside a \u201ctmp_file.txt\u201d file ` To later restart the bootnode using the same key (and hence use the same enode url): bootnode -nodekey tmp_file.txt or bootnode -nodekeyhex 77bd02ffa26e3fb8f324bda24ae588066f1873d95680104de5bc2db9e7b2e510 // Key from tmp_file.txt 3. Start node \u00b6 Starting a node is as simple as geth . This will start the node without any of the roles and makes the node a spectator. If you have setup a bootnode then be sure to add the --bootnodes param to your startup command: geth --bootnodes $BOOTNODE_ENODE Adding new nodes \u00b6 Any additions to the permissioned-nodes.json file are dynamically picked up by the server when subsequent incoming/outgoing requests are made. The node does not need to be restarted in order for the changes to take effect. Removing existing nodes \u00b6 Removing existing connected nodes from the permissioned-nodes.json file does not immediately drop those existing connected nodes. However, if the connection is dropped for any reason, and a subsequent connect request is made from the dropped node ids, it is rejected as part of that new request. Enhanced permissioning \u00b6 Enhanced network permissioning uses a smart contract permissioning model. Enhanced permissioning enables significant flexibility to manage nodes, accounts, and account-level access controls.","title":"Create a permissioned network"},{"location":"tutorials/create-permissioned-network/#create-a-permissioned-network-with-basic-permissioning","text":"This tutorial shows you how to create a permissioned network with basic permissioning .","title":"Create a permissioned network with basic permissioning"},{"location":"tutorials/create-permissioned-network/#1-initialize-chain","text":"The first step is to generate the genesis block. The 7nodes directory in the quorum-examples repository contains several keys (using an empty password) that are used in the example genesis file: key1 vote key 1 key2 vote key 2 key3 vote key 3 key4 block maker 1 key5 block maker 2 Example genesis file (copy to genesis.json ): \"config\" : { \"homesteadBlock\" : 0 , \"byzantiumBlock\" : 0 , \"chainId\" : 10 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip158Block\" : 0 , \"isQuorum\" : true }, Initialize geth: geth init genesis.json","title":"1. Initialize chain"},{"location":"tutorials/create-permissioned-network/#2-setup-bootnode","text":"Optionally you can set up a bootnode that all the other nodes will first connect to in order to find other peers in the network. You will first need to generate a bootnode key: To generate the key for the first time: bootnode -genkey tmp_file.txt // this will start a bootnode with an enode address and generate a key inside a \u201ctmp_file.txt\u201d file ` To later restart the bootnode using the same key (and hence use the same enode url): bootnode -nodekey tmp_file.txt or bootnode -nodekeyhex 77bd02ffa26e3fb8f324bda24ae588066f1873d95680104de5bc2db9e7b2e510 // Key from tmp_file.txt","title":"2. Setup bootnode"},{"location":"tutorials/create-permissioned-network/#3-start-node","text":"Starting a node is as simple as geth . This will start the node without any of the roles and makes the node a spectator. If you have setup a bootnode then be sure to add the --bootnodes param to your startup command: geth --bootnodes $BOOTNODE_ENODE","title":"3. Start node"},{"location":"tutorials/create-permissioned-network/#adding-new-nodes","text":"Any additions to the permissioned-nodes.json file are dynamically picked up by the server when subsequent incoming/outgoing requests are made. The node does not need to be restarted in order for the changes to take effect.","title":"Adding new nodes"},{"location":"tutorials/create-permissioned-network/#removing-existing-nodes","text":"Removing existing connected nodes from the permissioned-nodes.json file does not immediately drop those existing connected nodes. However, if the connection is dropped for any reason, and a subsequent connect request is made from the dropped node ids, it is rejected as part of that new request.","title":"Removing existing nodes"},{"location":"tutorials/create-permissioned-network/#enhanced-permissioning","text":"Enhanced network permissioning uses a smart contract permissioning model. Enhanced permissioning enables significant flexibility to manage nodes, accounts, and account-level access controls.","title":"Enhanced permissioning"},{"location":"tutorials/create-privacy-enabled-network/","text":"Create a privacy-enabled network \u00b6 This tutorial shows you how to create a privacy-enabled network. The network uses Tessera , a private transaction manager, to encrypt and distribute private transactions . Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall. Prerequisites \u00b6 Tessera . IBFT network as configured in IBFT tutorial . The nodes must not be running. Steps \u00b6 Listed on the right-hand side of the page are the steps to create a private network using IBFT with 5 GoQuorum nodes and 2 Tessera nodes. 1. Create directories \u00b6 Create directories for the 2 Tessera nodes in the IBFT-Network directory previously created. IBFT-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-1 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-2 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-3 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-4 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Tessera-0 \u251c\u2500\u2500 Tessera-1 2. Generate Tessera keys \u00b6 In the Tessera-0 directory, generate keys. Replace <path-to-tessera> with the path to Tessera. java -jar /<path-to-tessera>/tessera.jar -keygen -filename tessera0 Press enter both times you are prompted for a password. The private and public key are created in files called tessera0.key and tessera0.pub . Caution In a production environment, ensure keys are secured appropriately. 3. Create configuration file \u00b6 In the Tessera-0 directory, create a configuration file called config.json . Copy and paste the the configuration below into the file. On the highlighted lines, replace <path to IBFT-network> with the path to your network. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \"useWhiteList\" : false , \"jdbc\" : { \"username\" : \"sa\" , \"password\" : \"\" , \"url\" : \"jdbc:h2:/<path to IBFT-network>/IBFT-network/Tessera-0/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0\" , \"autoCreateTables\" : true }, \"serverConfigs\" :[ { \"app\" : \"ThirdParty\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9081\" , \"communicationType\" : \"REST\" }, { \"app\" : \"Q2T\" , \"enabled\" : true , \"serverAddress\" : \"unix:/<path to IBFT-network>/IBFT-network/Tessera-0/tm.ipc\" , \"communicationType\" : \"REST\" }, { \"app\" : \"P2P\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9001\" , \"sslConfig\" : { \"tls\" : \"OFF\" }, \"communicationType\" : \"REST\" } ], \"peer\" : [ { \"url\" : \"http://localhost:9001\" }, { \"url\" : \"http://localhost:9003\" } ], \"keys\" : { \"passwords\" : [], \"keyData\" : [ { \"privateKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-0/tessera0.key\" , \"publicKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-0/tessera0.pub\" } ] }, \"alwaysSendTo\" : [] } 4. Create Tessera-1 keys \u00b6 In Tessera-1 , generate keys in the same way as for Tessera-0 . Replace <path-to-tessera> with the path to Tessera. java -jar /<path-to-tessera>/tessera.jar -keygen -filename tessera1 5. Create Tessera-1 configuration file \u00b6 In the Tessera-1 directory, create a configuration file called config.json . Copy and paste the the configuration below into the file. Different ports are specified for Tessera 1. On the highlighted lines, replace <path to IBFT-network> with the path to your network. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \"useWhiteList\" : false , \"jdbc\" : { \"username\" : \"sa\" , \"password\" : \"\" , \"url\" : \"jdbc:h2:/<path to IBFT-network>/IBFT-network/Tessera-1/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0\" , \"autoCreateTables\" : true }, \"serverConfigs\" :[ { \"app\" : \"ThirdParty\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9083\" , \"communicationType\" : \"REST\" }, { \"app\" : \"Q2T\" , \"enabled\" : true , \"serverAddress\" : \"unix:/<path to IBFT-network>/IBFT-network/Tessera-1/tm.ipc\" , \"communicationType\" : \"REST\" }, { \"app\" : \"P2P\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9003\" , \"sslConfig\" : { \"tls\" : \"OFF\" }, \"communicationType\" : \"REST\" } ], \"peer\" : [ { \"url\" : \"http://localhost:9001\" }, { \"url\" : \"http://localhost:9003\" } ], \"keys\" : { \"passwords\" : [], \"keyData\" : [ { \"privateKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-1/tessera1.key\" , \"publicKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-1/tessera1.pub\" } ] }, \"alwaysSendTo\" : [] } 6. Start Tessera 0 \u00b6 In the Tessera-0 directory, start Tessera 0. Replace <path to tessera> with the path to Tessera. java -jar <path to Tessera>/tessera.jar -configfile config.json 7. Start Tessera 1 \u00b6 In the Tessera-1 directory, start Tessera 1. Replace <path to tessera> with the path to Tessera. java -jar <path to Tessera>/tessera.jar -configfile config.json 8. Start GoQuorum node 0 \u00b6 In the Node-0 directory, start GoQuorum node 0 specifying the Tessera 0 node to attach to. Replace <path to IBFT network> with the path to your network. PRIVATE_CONFIG = /<path to IBFT network>/IBFT-network/Tessera-0/tm.ipc geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22000 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30300 --allow-insecure-unlock Caution The --allow-insecure-unlock option enables insecure account unlocking for educational purposes only. In production environments, ensure account keys are secured appropriately. 9. Start GoQuorum node 1 \u00b6 In the Node-1 directory, start GoQuorum node 1 specifying the Tessera 1 node to attach to. Replace <path to IBFT network> with the path to your network. PRIVATE_CONFIG = /<path to IBFT network>/IBFT-network/Tessera-1/tm.ipc geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22001 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30301 10. Start nodes 2, 3, and 4 \u00b6 In new terminal for each node in each node directory, start the remaining nodes using the same command as in the IBFT tutorial. Nodes 2, 3, and 4 do not have an attached Tessera node. Node 2 PRIVATE_CONFIG = ignore geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22002 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30302 Node 3 PRIVATE_CONFIG = ignore geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22003 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30303 Node 4 PRIVATE_CONFIG = ignore geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22004 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30304 Your node can now send and receive private transactions .","title":"Create a privacy-enabled network"},{"location":"tutorials/create-privacy-enabled-network/#create-a-privacy-enabled-network","text":"This tutorial shows you how to create a privacy-enabled network. The network uses Tessera , a private transaction manager, to encrypt and distribute private transactions . Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall.","title":"Create a privacy-enabled network"},{"location":"tutorials/create-privacy-enabled-network/#prerequisites","text":"Tessera . IBFT network as configured in IBFT tutorial . The nodes must not be running.","title":"Prerequisites"},{"location":"tutorials/create-privacy-enabled-network/#steps","text":"Listed on the right-hand side of the page are the steps to create a private network using IBFT with 5 GoQuorum nodes and 2 Tessera nodes.","title":"Steps"},{"location":"tutorials/create-privacy-enabled-network/#1-create-directories","text":"Create directories for the 2 Tessera nodes in the IBFT-Network directory previously created. IBFT-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-1 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-2 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-3 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Node-4 \u2502 \u251c\u2500\u2500 data \u251c\u2500\u2500 Tessera-0 \u251c\u2500\u2500 Tessera-1","title":"1. Create directories"},{"location":"tutorials/create-privacy-enabled-network/#2-generate-tessera-keys","text":"In the Tessera-0 directory, generate keys. Replace <path-to-tessera> with the path to Tessera. java -jar /<path-to-tessera>/tessera.jar -keygen -filename tessera0 Press enter both times you are prompted for a password. The private and public key are created in files called tessera0.key and tessera0.pub . Caution In a production environment, ensure keys are secured appropriately.","title":"2. Generate Tessera keys"},{"location":"tutorials/create-privacy-enabled-network/#3-create-configuration-file","text":"In the Tessera-0 directory, create a configuration file called config.json . Copy and paste the the configuration below into the file. On the highlighted lines, replace <path to IBFT-network> with the path to your network. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \"useWhiteList\" : false , \"jdbc\" : { \"username\" : \"sa\" , \"password\" : \"\" , \"url\" : \"jdbc:h2:/<path to IBFT-network>/IBFT-network/Tessera-0/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0\" , \"autoCreateTables\" : true }, \"serverConfigs\" :[ { \"app\" : \"ThirdParty\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9081\" , \"communicationType\" : \"REST\" }, { \"app\" : \"Q2T\" , \"enabled\" : true , \"serverAddress\" : \"unix:/<path to IBFT-network>/IBFT-network/Tessera-0/tm.ipc\" , \"communicationType\" : \"REST\" }, { \"app\" : \"P2P\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9001\" , \"sslConfig\" : { \"tls\" : \"OFF\" }, \"communicationType\" : \"REST\" } ], \"peer\" : [ { \"url\" : \"http://localhost:9001\" }, { \"url\" : \"http://localhost:9003\" } ], \"keys\" : { \"passwords\" : [], \"keyData\" : [ { \"privateKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-0/tessera0.key\" , \"publicKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-0/tessera0.pub\" } ] }, \"alwaysSendTo\" : [] }","title":"3. Create configuration file"},{"location":"tutorials/create-privacy-enabled-network/#4-create-tessera-1-keys","text":"In Tessera-1 , generate keys in the same way as for Tessera-0 . Replace <path-to-tessera> with the path to Tessera. java -jar /<path-to-tessera>/tessera.jar -keygen -filename tessera1","title":"4. Create Tessera-1 keys"},{"location":"tutorials/create-privacy-enabled-network/#5-create-tessera-1-configuration-file","text":"In the Tessera-1 directory, create a configuration file called config.json . Copy and paste the the configuration below into the file. Different ports are specified for Tessera 1. On the highlighted lines, replace <path to IBFT-network> with the path to your network. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \"useWhiteList\" : false , \"jdbc\" : { \"username\" : \"sa\" , \"password\" : \"\" , \"url\" : \"jdbc:h2:/<path to IBFT-network>/IBFT-network/Tessera-1/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0\" , \"autoCreateTables\" : true }, \"serverConfigs\" :[ { \"app\" : \"ThirdParty\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9083\" , \"communicationType\" : \"REST\" }, { \"app\" : \"Q2T\" , \"enabled\" : true , \"serverAddress\" : \"unix:/<path to IBFT-network>/IBFT-network/Tessera-1/tm.ipc\" , \"communicationType\" : \"REST\" }, { \"app\" : \"P2P\" , \"enabled\" : true , \"serverAddress\" : \"http://localhost:9003\" , \"sslConfig\" : { \"tls\" : \"OFF\" }, \"communicationType\" : \"REST\" } ], \"peer\" : [ { \"url\" : \"http://localhost:9001\" }, { \"url\" : \"http://localhost:9003\" } ], \"keys\" : { \"passwords\" : [], \"keyData\" : [ { \"privateKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-1/tessera1.key\" , \"publicKeyPath\" : \"<path to IBFT-network>/IBFT-network/Tessera-1/tessera1.pub\" } ] }, \"alwaysSendTo\" : [] }","title":"5. Create Tessera-1 configuration file"},{"location":"tutorials/create-privacy-enabled-network/#6-start-tessera-0","text":"In the Tessera-0 directory, start Tessera 0. Replace <path to tessera> with the path to Tessera. java -jar <path to Tessera>/tessera.jar -configfile config.json","title":"6. Start Tessera 0"},{"location":"tutorials/create-privacy-enabled-network/#7-start-tessera-1","text":"In the Tessera-1 directory, start Tessera 1. Replace <path to tessera> with the path to Tessera. java -jar <path to Tessera>/tessera.jar -configfile config.json","title":"7. Start Tessera 1"},{"location":"tutorials/create-privacy-enabled-network/#8-start-goquorum-node-0","text":"In the Node-0 directory, start GoQuorum node 0 specifying the Tessera 0 node to attach to. Replace <path to IBFT network> with the path to your network. PRIVATE_CONFIG = /<path to IBFT network>/IBFT-network/Tessera-0/tm.ipc geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22000 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30300 --allow-insecure-unlock Caution The --allow-insecure-unlock option enables insecure account unlocking for educational purposes only. In production environments, ensure account keys are secured appropriately.","title":"8. Start GoQuorum node 0"},{"location":"tutorials/create-privacy-enabled-network/#9-start-goquorum-node-1","text":"In the Node-1 directory, start GoQuorum node 1 specifying the Tessera 1 node to attach to. Replace <path to IBFT network> with the path to your network. PRIVATE_CONFIG = /<path to IBFT network>/IBFT-network/Tessera-1/tm.ipc geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22001 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30301","title":"9. Start GoQuorum node 1"},{"location":"tutorials/create-privacy-enabled-network/#10-start-nodes-2-3-and-4","text":"In new terminal for each node in each node directory, start the remaining nodes using the same command as in the IBFT tutorial. Nodes 2, 3, and 4 do not have an attached Tessera node. Node 2 PRIVATE_CONFIG = ignore geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22002 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30302 Node 3 PRIVATE_CONFIG = ignore geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22003 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30303 Node 4 PRIVATE_CONFIG = ignore geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 127 .0.0.1 --http.port 22004 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30304 Your node can now send and receive private transactions .","title":"10. Start nodes 2, 3, and 4"},{"location":"tutorials/permissioned-nodes/","text":"Permissioned nodes example \u00b6 [ \"enode://ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef@127.0.0.1:21000?discport=0&raftport=50401\" , \"enode://0ba6b9f606a43a95edc6247cdb1c1e105145817be7bcafd6b2c0ba15d58145f0dc1a194f70ba73cd6f4cdd6864edc7687f311254c7555cc32e4d45aeb1b80416@127.0.0.1:21001?discport=0&raftport=50402\" , \"enode://579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778@127.0.0.1:21002?discport=0&raftport=50403\" , \"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\" , \"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\" , \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0&raftport=50406\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ]","title":"Permissioned nodes example"},{"location":"tutorials/permissioned-nodes/#permissioned-nodes-example","text":"[ \"enode://ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef@127.0.0.1:21000?discport=0&raftport=50401\" , \"enode://0ba6b9f606a43a95edc6247cdb1c1e105145817be7bcafd6b2c0ba15d58145f0dc1a194f70ba73cd6f4cdd6864edc7687f311254c7555cc32e4d45aeb1b80416@127.0.0.1:21001?discport=0&raftport=50402\" , \"enode://579f786d4e2830bbcc02815a27e8a9bacccc9605df4dc6f20bcc1a6eb391e7225fff7cb83e5b4ecd1f3a94d8b733803f2f66b7e871961e7b029e22c155c3a778@127.0.0.1:21002?discport=0&raftport=50403\" , \"enode://3d9ca5956b38557aba991e31cf510d4df641dce9cc26bfeb7de082f0c07abb6ede3a58410c8f249dabeecee4ad3979929ac4c7c496ad20b8cfdd061b7401b4f5@127.0.0.1:21003?discport=0&raftport=50404\" , \"enode://3701f007bfa4cb26512d7df18e6bbd202e8484a6e11d387af6e482b525fa25542d46ff9c99db87bd419b980c24a086117a397f6d8f88e74351b41693880ea0cb@127.0.0.1:21004?discport=0&raftport=50405\" , \"enode://eacaa74c4b0e7a9e12d2fe5fee6595eda841d6d992c35dbbcc50fcee4aa86dfbbdeff7dc7e72c2305d5a62257f82737a8cffc80474c15c611c037f52db1a3a7b@127.0.0.1:21005?discport=0&raftport=50406\" , \"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407\" ]","title":"Permissioned nodes example"},{"location":"tutorials/send-private-transaction/","text":"Send private transactions \u00b6 This tutorial shows you how to send private transactions . Prerequisites \u00b6 Privacy-enabled network running as configured in tutorial . The nodes must be running. Steps \u00b6 1. Create private contract \u00b6 In the Node-0 directory, copy and paste the following to a file called private-contract.js . On the highlighted line, replace the placeholder for privateFor with the base64 content of the tessera1.pub key file. For example, 1oRj9qpgnNhr/ZUggeMXnXsWMuVgedS6gfimpEVt+EQ= . Important Don\u2019t include the sender\u2019s node in privateFor . To create a private contract visible to the sender\u2019s node only, use this format: privateFor: [] . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 a = eth . accounts [ 0 ] web3 . eth . defaultAccount = a ; // abi and bytecode generated from simplestorage.sol: // > solcjs --bin --abi simplestorage.sol var abi = [{ \"constant\" : true , \"inputs\" : [], \"name\" : \"storedData\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"x\" , \"type\" : \"uint256\" }], \"name\" : \"set\" , \"outputs\" : [], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"get\" , \"outputs\" : [{ \"name\" : \"retVal\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"initVal\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"constructor\" }]; var bytecode = \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029\" ; var simpleContract = web3 . eth . contract ( abi ); var simple = simpleContract . new ( 42 , { from : web3 . eth . accounts [ 0 ], data : bytecode , gas : 0x47b760 , privateFor : [ \"<Tessera 1 public key>\" ]}, function ( e , contract ) { if ( e ) { console . log ( \"err creating contract\" , e ); } else { if ( ! contract . address ) { console . log ( \"Contract transaction send: TransactionHash: \" + contract . transactionHash + \" waiting to be mined...\" ); } else { console . log ( \"Contract mined! Address: \" + contract . address ); console . log ( contract ); } } }); 2. Create account \u00b6 In the Node-0 directory, create an account. geth --datadir data account new 3. Unlock account \u00b6 Accounts are locked by default and must be unlocked before sending the transaction. Use the geth console to display and unlock the account. geth attach geth.ipc Display the accounts. eth . accounts Unlock the account using the account key displayed by eth.accounts . Unlock personal . unlockAccount ( \"<account key>\" ) Example personal . unlockAccount ( \"0x0bc37b7dc68c24aee9d49fab70bb20cb8c6154c2\" ) Type in the account password when prompted. Tip By default, accounts remain unlocked for 5 minutes. After 5 minutes, the account is relocked. 4. Send private transaction \u00b6 Important All participants listed in privateFor must have their private transaction managers running when the private transaction is sent. Otherwise, the transaction doesn\u2019t propagate and an error is returned. In the geth console, run loadScript to deploy the contract and send a private transaction from node 0 to node 1. loadScript ( \"private-contract.js\" ) The GoQuorum logs for node 0 indicate the private transaction was sent. Node 0 DEBUG [ 12 -08 | 13 :53:09.380 ] sending private tx txnType = 3 data = 606060 \u202600002a privatefrom = privatefor = \"[yrrHrbeaXzZCYJ4DPXrunvms1/jy5zDvoH5KnNyW4VE=]\" privacyFlag = 0 DEBUG [ 12 -08 | 13 :53:09.381 ] Simulated Execution EVM call finished runtime = 594ns TRACE [ 12 -08 | 13 :53:09.381 ] after simulation affectedCATxHashes = map [] merkleRoot = 000000 \u2026000000 privacyFlag = 0 error = nil INFO [ 12 -08 | 13 :53:09.629 ] sent private signed tx data = 606060 \u202600002a hash = f93744\u2026407111 privatefrom = privatefor = \"[yrrHrbeaXzZCYJ4DPXrunvms1/jy5zDvoH5KnNyW4VE=]\" affectedCATxHashes = map [] merkleroot = 000000 \u2026000000 privacyflag = 0 DEBUG [ 12 -08 | 13 :53:09.629 ] Handle Private Transaction finished took = 249 .112348ms INFO [ 12 -08 | 13 :53:09.630 ] Private transaction signing with QuorumPrivateTxSigner The Tessera logs indicate the transaction payload was distributed and received. Node 0 2020 -12-08 13 :53:09.390 [ qtp1487391298-33 ] INFO c.q.tessera.q2t.TransactionResource - Enter Request : POST : /send 2020 -12-08 13 :53:09.525 [ pool-5-thread-1 ] INFO c.q.tessera.q2t.RestPayloadPublisher - Publishing message to http://localhost:9003/ 2020 -12-08 13 :53:09.616 [ pool-5-thread-1 ] INFO c.q.tessera.q2t.RestPayloadPublisher - Published to http://localhost:9003/ 2020 -12-08 13 :53:09.622 [ qtp1487391298-33 ] INFO c.q.tessera.q2t.TransactionResource - Exit Request : POST : /send 2020 -12-08 13 :53:09.622 [ qtp1487391298-33 ] INFO c.q.tessera.q2t.TransactionResource - Response for send : 201 Created Node 1 2020 -12-08 13 :53:09.548 [ qtp1564775175-89 ] INFO c.q.tessera.p2p.TransactionResource - Enter Request : POST : /push 2020 -12-08 13 :53:09.614 [ qtp1564775175-89 ] INFO c.q.t.t.TransactionManagerImpl - Stored payload with hash +TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:09.615 [ qtp1564775175-89 ] INFO c.q.tessera.p2p.TransactionResource - Exit Request : POST : /push 2020 -12-08 13 :53:09.615 [ qtp1564775175-89 ] INFO c.q.tessera.p2p.TransactionResource - Response for push : 201 Created 2020 -12-08 13 :53:12.024 [ qtp1527084496-36 ] INFO c.q.tessera.q2t.TransactionResource - Enter Request : GET : /transaction/+TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:12.047 [ qtp1527084496-36 ] INFO c.q.t.t.TransactionManagerImpl - Lookup transaction +TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:12.088 [ qtp1527084496-36 ] INFO c.q.tessera.q2t.TransactionResource - Exit Request : GET : /transaction/+TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:12.088 [ qtp1527084496-36 ] INFO c.q.tessera.q2t.TransactionResource - Response for transaction/+TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == : 200 OK","title":"Send private transactions"},{"location":"tutorials/send-private-transaction/#send-private-transactions","text":"This tutorial shows you how to send private transactions .","title":"Send private transactions"},{"location":"tutorials/send-private-transaction/#prerequisites","text":"Privacy-enabled network running as configured in tutorial . The nodes must be running.","title":"Prerequisites"},{"location":"tutorials/send-private-transaction/#steps","text":"","title":"Steps"},{"location":"tutorials/send-private-transaction/#1-create-private-contract","text":"In the Node-0 directory, copy and paste the following to a file called private-contract.js . On the highlighted line, replace the placeholder for privateFor with the base64 content of the tessera1.pub key file. For example, 1oRj9qpgnNhr/ZUggeMXnXsWMuVgedS6gfimpEVt+EQ= . Important Don\u2019t include the sender\u2019s node in privateFor . To create a private contract visible to the sender\u2019s node only, use this format: privateFor: [] . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 a = eth . accounts [ 0 ] web3 . eth . defaultAccount = a ; // abi and bytecode generated from simplestorage.sol: // > solcjs --bin --abi simplestorage.sol var abi = [{ \"constant\" : true , \"inputs\" : [], \"name\" : \"storedData\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"x\" , \"type\" : \"uint256\" }], \"name\" : \"set\" , \"outputs\" : [], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"get\" , \"outputs\" : [{ \"name\" : \"retVal\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"initVal\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"constructor\" }]; var bytecode = \"0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029\" ; var simpleContract = web3 . eth . contract ( abi ); var simple = simpleContract . new ( 42 , { from : web3 . eth . accounts [ 0 ], data : bytecode , gas : 0x47b760 , privateFor : [ \"<Tessera 1 public key>\" ]}, function ( e , contract ) { if ( e ) { console . log ( \"err creating contract\" , e ); } else { if ( ! contract . address ) { console . log ( \"Contract transaction send: TransactionHash: \" + contract . transactionHash + \" waiting to be mined...\" ); } else { console . log ( \"Contract mined! Address: \" + contract . address ); console . log ( contract ); } } });","title":"1. Create private contract"},{"location":"tutorials/send-private-transaction/#2-create-account","text":"In the Node-0 directory, create an account. geth --datadir data account new","title":"2. Create account"},{"location":"tutorials/send-private-transaction/#3-unlock-account","text":"Accounts are locked by default and must be unlocked before sending the transaction. Use the geth console to display and unlock the account. geth attach geth.ipc Display the accounts. eth . accounts Unlock the account using the account key displayed by eth.accounts . Unlock personal . unlockAccount ( \"<account key>\" ) Example personal . unlockAccount ( \"0x0bc37b7dc68c24aee9d49fab70bb20cb8c6154c2\" ) Type in the account password when prompted. Tip By default, accounts remain unlocked for 5 minutes. After 5 minutes, the account is relocked.","title":"3. Unlock account"},{"location":"tutorials/send-private-transaction/#4-send-private-transaction","text":"Important All participants listed in privateFor must have their private transaction managers running when the private transaction is sent. Otherwise, the transaction doesn\u2019t propagate and an error is returned. In the geth console, run loadScript to deploy the contract and send a private transaction from node 0 to node 1. loadScript ( \"private-contract.js\" ) The GoQuorum logs for node 0 indicate the private transaction was sent. Node 0 DEBUG [ 12 -08 | 13 :53:09.380 ] sending private tx txnType = 3 data = 606060 \u202600002a privatefrom = privatefor = \"[yrrHrbeaXzZCYJ4DPXrunvms1/jy5zDvoH5KnNyW4VE=]\" privacyFlag = 0 DEBUG [ 12 -08 | 13 :53:09.381 ] Simulated Execution EVM call finished runtime = 594ns TRACE [ 12 -08 | 13 :53:09.381 ] after simulation affectedCATxHashes = map [] merkleRoot = 000000 \u2026000000 privacyFlag = 0 error = nil INFO [ 12 -08 | 13 :53:09.629 ] sent private signed tx data = 606060 \u202600002a hash = f93744\u2026407111 privatefrom = privatefor = \"[yrrHrbeaXzZCYJ4DPXrunvms1/jy5zDvoH5KnNyW4VE=]\" affectedCATxHashes = map [] merkleroot = 000000 \u2026000000 privacyflag = 0 DEBUG [ 12 -08 | 13 :53:09.629 ] Handle Private Transaction finished took = 249 .112348ms INFO [ 12 -08 | 13 :53:09.630 ] Private transaction signing with QuorumPrivateTxSigner The Tessera logs indicate the transaction payload was distributed and received. Node 0 2020 -12-08 13 :53:09.390 [ qtp1487391298-33 ] INFO c.q.tessera.q2t.TransactionResource - Enter Request : POST : /send 2020 -12-08 13 :53:09.525 [ pool-5-thread-1 ] INFO c.q.tessera.q2t.RestPayloadPublisher - Publishing message to http://localhost:9003/ 2020 -12-08 13 :53:09.616 [ pool-5-thread-1 ] INFO c.q.tessera.q2t.RestPayloadPublisher - Published to http://localhost:9003/ 2020 -12-08 13 :53:09.622 [ qtp1487391298-33 ] INFO c.q.tessera.q2t.TransactionResource - Exit Request : POST : /send 2020 -12-08 13 :53:09.622 [ qtp1487391298-33 ] INFO c.q.tessera.q2t.TransactionResource - Response for send : 201 Created Node 1 2020 -12-08 13 :53:09.548 [ qtp1564775175-89 ] INFO c.q.tessera.p2p.TransactionResource - Enter Request : POST : /push 2020 -12-08 13 :53:09.614 [ qtp1564775175-89 ] INFO c.q.t.t.TransactionManagerImpl - Stored payload with hash +TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:09.615 [ qtp1564775175-89 ] INFO c.q.tessera.p2p.TransactionResource - Exit Request : POST : /push 2020 -12-08 13 :53:09.615 [ qtp1564775175-89 ] INFO c.q.tessera.p2p.TransactionResource - Response for push : 201 Created 2020 -12-08 13 :53:12.024 [ qtp1527084496-36 ] INFO c.q.tessera.q2t.TransactionResource - Enter Request : GET : /transaction/+TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:12.047 [ qtp1527084496-36 ] INFO c.q.t.t.TransactionManagerImpl - Lookup transaction +TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:12.088 [ qtp1527084496-36 ] INFO c.q.tessera.q2t.TransactionResource - Exit Request : GET : /transaction/+TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == 2020 -12-08 13 :53:12.088 [ qtp1527084496-36 ] INFO c.q.tessera.q2t.TransactionResource - Response for transaction/+TdE/ZNMX0IrqLSwLh6szKS4rxCuDB9NbpdLf7yXjfwS0ATYsnpSkCCJ+SSzh0D19CT4RZGzAiiFldF9pkBxEQ == : 200 OK","title":"4. Send private transaction"},{"location":"tutorials/use-plugin/","text":"Use the HelloWorld plugin \u00b6 This tutorial shows you how to use the HelloWorld plugin , which exposes a JSON-RPC endpoint to return a greeting message in Spanish. The plugin interface is implemented in Go and Java. The plugin can reload changes from its JSON configuration. Prerequisites \u00b6 GoQuorum built from source Gox installed Build the plugin distribution file \u00b6 Clone the plugin repository: git clone --recursive https://github.com/ConsenSys/quorum-plugin-hello-world.git cd quorum-plugin-hello-world Use the Go implementation of the plugin: cd go make quorum-plugin-hello-world-1.0.0.zip is now created in the build directory. The file hello-world-plugin-config.json is the JSON configuration file for the plugin. Rename quorum-plugin-hello-world-1.0.0.zip according to your operating system: Linux quorum-plugin-hello-world-1.0.0-linux-amd64.zip Intel MacOS quorum-plugin-hello-world-1.0.0-darwin-amd64.zip Start GoQuorum with plugin support \u00b6 Navigate to your GoQuorum installation directory. Copy the HelloWorld plugin distribution file and its JSON configuration hello-world-plugin-config.json to build/bin . Create geth-plugin-settings.json : cat > build/bin/geth-plugin-settings.json <<EOF { \"baseDir\": \"./build/bin\", \"providers\": { \"helloworld\": { \"name\":\"quorum-plugin-hello-world\", \"version\":\"1.0.0\", \"config\": \"file://./build/bin/hello-world-plugin-config.json\" } } } EOF Note For the configured locations, ./ means that you start from the working directory, from where the program is launched. Run geth with the plugin: PRIVATE_CONFIG = ignore \\ geth \\ --nodiscover \\ --verbosity 5 \\ --networkid 10 \\ --raft \\ --raftjoinexisting 1 \\ --datadir ./build/_workspace/test \\ --http \\ --http.api eth,debug,admin,net,web3,plugin@helloworld \\ --plugins file://./build/bin/geth-plugin-settings.json \\ --plugins.skipverify Run ps -ef | grep helloworld to reveal the HelloWorld plugin process. Test the plugin \u00b6 Test the HelloWorld plugin using the following command: curl HTTP request curl -X POST http://localhost:8545 \\ -H \"Content-type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"plugin@helloworld_greeting\",\"params\":[\"Quorum Plugin\"],\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"Hello Quorum Plugin!\" } Update the plugin configuration build/bin/hello-world-plugin-config.json to support the es language (Spanish). Reload the plugin using the following command: curl HTTP request curl -X POST http://localhost:8545 \\ -H \"Content-type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"admin_reloadPlugin\",\"params\":[\"helloworld\"],\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : true } Re-run the HelloWorld plugin: curl HTTP request curl -X POST http://localhost:8545 \\ -H \"Content-type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"plugin@helloworld_greeting\",\"params\":[\"Quorum Plugin\"],\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"Hola Quorum Plugin!\" }","title":"Use a plugin"},{"location":"tutorials/use-plugin/#use-the-helloworld-plugin","text":"This tutorial shows you how to use the HelloWorld plugin , which exposes a JSON-RPC endpoint to return a greeting message in Spanish. The plugin interface is implemented in Go and Java. The plugin can reload changes from its JSON configuration.","title":"Use the HelloWorld plugin"},{"location":"tutorials/use-plugin/#prerequisites","text":"GoQuorum built from source Gox installed","title":"Prerequisites"},{"location":"tutorials/use-plugin/#build-the-plugin-distribution-file","text":"Clone the plugin repository: git clone --recursive https://github.com/ConsenSys/quorum-plugin-hello-world.git cd quorum-plugin-hello-world Use the Go implementation of the plugin: cd go make quorum-plugin-hello-world-1.0.0.zip is now created in the build directory. The file hello-world-plugin-config.json is the JSON configuration file for the plugin. Rename quorum-plugin-hello-world-1.0.0.zip according to your operating system: Linux quorum-plugin-hello-world-1.0.0-linux-amd64.zip Intel MacOS quorum-plugin-hello-world-1.0.0-darwin-amd64.zip","title":"Build the plugin distribution file"},{"location":"tutorials/use-plugin/#start-goquorum-with-plugin-support","text":"Navigate to your GoQuorum installation directory. Copy the HelloWorld plugin distribution file and its JSON configuration hello-world-plugin-config.json to build/bin . Create geth-plugin-settings.json : cat > build/bin/geth-plugin-settings.json <<EOF { \"baseDir\": \"./build/bin\", \"providers\": { \"helloworld\": { \"name\":\"quorum-plugin-hello-world\", \"version\":\"1.0.0\", \"config\": \"file://./build/bin/hello-world-plugin-config.json\" } } } EOF Note For the configured locations, ./ means that you start from the working directory, from where the program is launched. Run geth with the plugin: PRIVATE_CONFIG = ignore \\ geth \\ --nodiscover \\ --verbosity 5 \\ --networkid 10 \\ --raft \\ --raftjoinexisting 1 \\ --datadir ./build/_workspace/test \\ --http \\ --http.api eth,debug,admin,net,web3,plugin@helloworld \\ --plugins file://./build/bin/geth-plugin-settings.json \\ --plugins.skipverify Run ps -ef | grep helloworld to reveal the HelloWorld plugin process.","title":"Start GoQuorum with plugin support"},{"location":"tutorials/use-plugin/#test-the-plugin","text":"Test the HelloWorld plugin using the following command: curl HTTP request curl -X POST http://localhost:8545 \\ -H \"Content-type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"plugin@helloworld_greeting\",\"params\":[\"Quorum Plugin\"],\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"Hello Quorum Plugin!\" } Update the plugin configuration build/bin/hello-world-plugin-config.json to support the es language (Spanish). Reload the plugin using the following command: curl HTTP request curl -X POST http://localhost:8545 \\ -H \"Content-type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"admin_reloadPlugin\",\"params\":[\"helloworld\"],\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : true } Re-run the HelloWorld plugin: curl HTTP request curl -X POST http://localhost:8545 \\ -H \"Content-type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"plugin@helloworld_greeting\",\"params\":[\"Quorum Plugin\"],\"id\":1}' JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"Hola Quorum Plugin!\" }","title":"Test the plugin"},{"location":"tutorials/contracts/account-funds-transfers/","text":"Transfer funds between accounts \u00b6 This tutorial shows you how to transfer funds (ETH) between accounts in a transaction on a running network. Use the Quorum Developer Quickstart to rapidly generate a local blockchain network. Prerequisites \u00b6 A private network. You can use a private network tutorial or the Quorum Developer Quickstart . Using eth_sendSignedTransaction \u00b6 The simplest way to transfer funds between externally-owned accounts is using eth_sendSignedTransaction . This example uses eth_sendSignedTransaction and one of the test accounts to transfer funds to a newly created account. Security warning Do not use the test accounts on Ethereum Mainnet or any production network. The private key is publicly displayed, which means the account is not secure. Create a new file eth_tx.js (or run the following commands in a JavaScript console) to send the transaction. Before making the transaction, the script checks the balances of both accounts to verify the funds transfer after the transaction. eth_tx.js using eth_sendSignedTransaction const web3 = new Web3 ( host ); // Pre-seeded account with 90000 ETH const privateKeyA = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ; const accountA = web3 . eth . accounts . privateKeyToAccount ( privateKeyA ); var accountABalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountA . address )); console . log ( \"Account A has balance of: \" + accountABalance ); // Create a new account to transfer ETH to var accountB = web3 . eth . accounts . create (); var accountBBalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountB . address )); console . log ( \"Account B has balance of: \" + accountBBalance ); // Send 0x100 ETH from AccountA to AccountB and sign the transaction with // Account A's private key const rawTxOptions = { nonce : web3 . utils . numberToHex ( await web3 . eth . getTransactionCount ( accountA . address )), from : accountA . address , to : accountB . address , value : \"0x100\" , // Amount of ETH to transfer gasPrice : \"0x0\" , // Set to 0 in GoQuorum networks gasLimit : \"0x24A22\" // Max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const tx = new Tx ( rawTxOptions ); console . log ( \"Signing transaction...\" ); tx . sign ( Buffer . from ( accountA . privateKey . substring ( 2 ), \"hex\" )); console . log ( \"Sending transaction...\" ); var serializedTx = tx . serialize (); const pTx = await web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' ). toString ( \"hex\" )); console . log ( \"tx transactionHash: \" + pTx . transactionHash ); // After the transaction, check the updated balances and there should be some ETH transferred var accountABalance = await getAccountBalance ( host , accountA ); console . log ( \"Account A has an updated balance of: \" + accountABalance ); var accountBBalance = await getAccountBalance ( host , accountB ); console . log ( \"Account B has an updatedbalance of: \" + accountBBalance ); } For reference, the Quorum Developer Quickstart provides an example of a funds transfer script . Using eth_sendTransaction \u00b6 An alternative to using eth_sendSignedTransaction is using eth_sendTransaction . Create a new file eth_tx.js (or run the following commands in a JavaScript console) to send the transaction. eth_tx.js using eth_sendTransaction const web3 = new Web3 ( host ); // Pre-seeded account with 90000 ETH const privateKeyA = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ; const accountA = web3 . eth . accounts . privateKeyToAccount ( privateKeyA ); var accountABalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountA . address )); console . log ( \"Account A has balance of: \" + accountABalance ); // Create a new account to transfer ETH to var accountB = web3 . eth . accounts . create (); var accountBBalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountB . address )); console . log ( \"Account B has balance of: \" + accountBBalance ); // Send some ETH from A to B const txOptions = { from : accountA . address , to : accountB . address , value : \"0x100\" , // Amount of ETH to transfer gasPrice : \"0x0\" , // Set to 0 in GoQuorum networks gasLimit : \"0x24A22\" // Max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const pTx = await web3 . eth . sendTransaction ( txOptions ); console . log ( \"tx transactionHash: \" + pTx . transactionHash ); // After the transaction, there should be some ETH transferred var accountABalance = await getAccountBalance ( host , accountA ); console . log ( \"Account A has an updated balance of: \" + accountABalance ); var accountBBalance = await getAccountBalance ( host , accountB ); console . log ( \"Account B has an updatedbalance of: \" + accountBBalance ); }","title":"Transfer account funds"},{"location":"tutorials/contracts/account-funds-transfers/#transfer-funds-between-accounts","text":"This tutorial shows you how to transfer funds (ETH) between accounts in a transaction on a running network. Use the Quorum Developer Quickstart to rapidly generate a local blockchain network.","title":"Transfer funds between accounts"},{"location":"tutorials/contracts/account-funds-transfers/#prerequisites","text":"A private network. You can use a private network tutorial or the Quorum Developer Quickstart .","title":"Prerequisites"},{"location":"tutorials/contracts/account-funds-transfers/#using-eth_sendsignedtransaction","text":"The simplest way to transfer funds between externally-owned accounts is using eth_sendSignedTransaction . This example uses eth_sendSignedTransaction and one of the test accounts to transfer funds to a newly created account. Security warning Do not use the test accounts on Ethereum Mainnet or any production network. The private key is publicly displayed, which means the account is not secure. Create a new file eth_tx.js (or run the following commands in a JavaScript console) to send the transaction. Before making the transaction, the script checks the balances of both accounts to verify the funds transfer after the transaction. eth_tx.js using eth_sendSignedTransaction const web3 = new Web3 ( host ); // Pre-seeded account with 90000 ETH const privateKeyA = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ; const accountA = web3 . eth . accounts . privateKeyToAccount ( privateKeyA ); var accountABalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountA . address )); console . log ( \"Account A has balance of: \" + accountABalance ); // Create a new account to transfer ETH to var accountB = web3 . eth . accounts . create (); var accountBBalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountB . address )); console . log ( \"Account B has balance of: \" + accountBBalance ); // Send 0x100 ETH from AccountA to AccountB and sign the transaction with // Account A's private key const rawTxOptions = { nonce : web3 . utils . numberToHex ( await web3 . eth . getTransactionCount ( accountA . address )), from : accountA . address , to : accountB . address , value : \"0x100\" , // Amount of ETH to transfer gasPrice : \"0x0\" , // Set to 0 in GoQuorum networks gasLimit : \"0x24A22\" // Max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const tx = new Tx ( rawTxOptions ); console . log ( \"Signing transaction...\" ); tx . sign ( Buffer . from ( accountA . privateKey . substring ( 2 ), \"hex\" )); console . log ( \"Sending transaction...\" ); var serializedTx = tx . serialize (); const pTx = await web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' ). toString ( \"hex\" )); console . log ( \"tx transactionHash: \" + pTx . transactionHash ); // After the transaction, check the updated balances and there should be some ETH transferred var accountABalance = await getAccountBalance ( host , accountA ); console . log ( \"Account A has an updated balance of: \" + accountABalance ); var accountBBalance = await getAccountBalance ( host , accountB ); console . log ( \"Account B has an updatedbalance of: \" + accountBBalance ); } For reference, the Quorum Developer Quickstart provides an example of a funds transfer script .","title":"Using eth_sendSignedTransaction"},{"location":"tutorials/contracts/account-funds-transfers/#using-eth_sendtransaction","text":"An alternative to using eth_sendSignedTransaction is using eth_sendTransaction . Create a new file eth_tx.js (or run the following commands in a JavaScript console) to send the transaction. eth_tx.js using eth_sendTransaction const web3 = new Web3 ( host ); // Pre-seeded account with 90000 ETH const privateKeyA = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ; const accountA = web3 . eth . accounts . privateKeyToAccount ( privateKeyA ); var accountABalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountA . address )); console . log ( \"Account A has balance of: \" + accountABalance ); // Create a new account to transfer ETH to var accountB = web3 . eth . accounts . create (); var accountBBalance = web3 . utils . fromWei ( await web3 . eth . getBalance ( accountB . address )); console . log ( \"Account B has balance of: \" + accountBBalance ); // Send some ETH from A to B const txOptions = { from : accountA . address , to : accountB . address , value : \"0x100\" , // Amount of ETH to transfer gasPrice : \"0x0\" , // Set to 0 in GoQuorum networks gasLimit : \"0x24A22\" // Max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const pTx = await web3 . eth . sendTransaction ( txOptions ); console . log ( \"tx transactionHash: \" + pTx . transactionHash ); // After the transaction, there should be some ETH transferred var accountABalance = await getAccountBalance ( host , accountA ); console . log ( \"Account A has an updated balance of: \" + accountABalance ); var accountBBalance = await getAccountBalance ( host , accountB ); console . log ( \"Account B has an updatedbalance of: \" + accountBBalance ); }","title":"Using eth_sendTransaction"},{"location":"tutorials/contracts/calling-contract-functions/","text":"Interact with a deployed smart contract \u00b6 This tutorial shows you how to interact with smart contracts that have been deployed to a network. Use the Quorum Developer Quickstart to rapidly generate a local blockchain network. Prerequisites \u00b6 A network with a deployed smart contract as in the deploying smart contracts tutorial . Interact with public contracts \u00b6 This tutorial uses the SimpleStorage.sol contract: pragma solidity ^ 0.7.0 ; contract SimpleStorage { uint public storedData ; constructor ( uint initVal ) public { storedData = initVal ; } function set ( uint x ) public { storedData = x ; } function get () view public returns ( uint retVal ) { return storedData ; } } Once the contract is deployed, you can perform a read operation using the get function call and a write operation using the set function call. This tutorial uses the web3js library to interact with the contract. The Quorum Developer Quickstart provides a full example of a public contract script . 1. Perform a read operation \u00b6 To perform a read operation, you need the address that the contract was deployed to and the contract\u2019s ABI. The contract\u2019s ABI can be obtained from compiling the contract; see the deploying smart contracts tutorial for an example. Use the web3.eth.Contract object to create a new instance of the smart contract, then make the get function call from the contract\u2019s list of methods, which will return the value stored: async function getValueAtAddress ( host , deployedContractAbi , deployedContractAddress ){ const web3 = new Web3 ( host ); const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . get (). call (); console . log ( \"Obtained value at deployed contract is: \" + res ); return res } 2. Perform a write operation \u00b6 To perform a write operation, send a transaction to update the stored value. As with the get call , you need to use the address that the contract was deployed to and the contract\u2019s ABI. The account address must correspond to an actual account with some ETH in it to perform the transaction. Make the set call passing in your account address, value as the updated value of the contract, and the amount of gas you are willing to spend for the transaction: // You need to use the accountAddress details provided to GoQuorum to send/interact with contracts async function setValueAtAddress ( host , accountAddress , value , deployedContractAbi , deployedContractAddress ){ const web3 = new Web3 ( host ); const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . set ( value ). send ({ from : accountAddress , gasPrice : \"0x0\" , gasLimit : \"0x24A22\" }); return res } 3. Verify an updated value \u00b6 To verify that a value has been updated, perform a get call after a set update call. Interact with private contracts \u00b6 This private contracts example uses the same SimpleStorage.sol contract as in the public contracts example , but it uses the eth_sendRawPrivateTransaction method to interact with the contract. Both read and write operations are performed using the eea_sendRawTransaction API call. The Quorum Developer quickstart provides a full example of a private contract script . 1. Perform a read operation \u00b6 Performing a read operation on a contract is identical to the public contract example , and you need the address that the contract was deployed to and the contract\u2019s ABI. Use the web3.eth.Contract object to create a new instance of the smart contract, then make the get function call from the contract\u2019s list of methods, which will return the value stored: async function getValueAtAddress ( host , deployedContractAbi , deployedContractAddress ){ const web3 = new Web3 ( host ); const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . get (). call (); console . log ( \"Obtained value at deployed contract is: \" + res ); return res } 2. Perform a write operation \u00b6 Performing a write operation is almost the same process as the read operation, except that you encode the new value to the set function\u2019s ABI, and then append these arguments to the set function\u2019s ABI and use this as the data field. Additionally provide the public key of the Transaction Manager of the respective node. async function setValueAtAddress ( host , value , deployedContractAbi , deployedContractAddress , fromAddress , toPublicKey ) { const web3 = new Web3 ( host ) const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . set ( value ). send ({ from : fromAddress , privateFor : [ toPublicKey ], gasLimit : \"0x24A22\" }); return res } 3. Verify an updated value \u00b6 To verify that a value has been updated, perform a get call after a set update call.","title":"Interact with a deployed contract"},{"location":"tutorials/contracts/calling-contract-functions/#interact-with-a-deployed-smart-contract","text":"This tutorial shows you how to interact with smart contracts that have been deployed to a network. Use the Quorum Developer Quickstart to rapidly generate a local blockchain network.","title":"Interact with a deployed smart contract"},{"location":"tutorials/contracts/calling-contract-functions/#prerequisites","text":"A network with a deployed smart contract as in the deploying smart contracts tutorial .","title":"Prerequisites"},{"location":"tutorials/contracts/calling-contract-functions/#interact-with-public-contracts","text":"This tutorial uses the SimpleStorage.sol contract: pragma solidity ^ 0.7.0 ; contract SimpleStorage { uint public storedData ; constructor ( uint initVal ) public { storedData = initVal ; } function set ( uint x ) public { storedData = x ; } function get () view public returns ( uint retVal ) { return storedData ; } } Once the contract is deployed, you can perform a read operation using the get function call and a write operation using the set function call. This tutorial uses the web3js library to interact with the contract. The Quorum Developer Quickstart provides a full example of a public contract script .","title":"Interact with public contracts"},{"location":"tutorials/contracts/calling-contract-functions/#1-perform-a-read-operation","text":"To perform a read operation, you need the address that the contract was deployed to and the contract\u2019s ABI. The contract\u2019s ABI can be obtained from compiling the contract; see the deploying smart contracts tutorial for an example. Use the web3.eth.Contract object to create a new instance of the smart contract, then make the get function call from the contract\u2019s list of methods, which will return the value stored: async function getValueAtAddress ( host , deployedContractAbi , deployedContractAddress ){ const web3 = new Web3 ( host ); const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . get (). call (); console . log ( \"Obtained value at deployed contract is: \" + res ); return res }","title":"1. Perform a read operation"},{"location":"tutorials/contracts/calling-contract-functions/#2-perform-a-write-operation","text":"To perform a write operation, send a transaction to update the stored value. As with the get call , you need to use the address that the contract was deployed to and the contract\u2019s ABI. The account address must correspond to an actual account with some ETH in it to perform the transaction. Make the set call passing in your account address, value as the updated value of the contract, and the amount of gas you are willing to spend for the transaction: // You need to use the accountAddress details provided to GoQuorum to send/interact with contracts async function setValueAtAddress ( host , accountAddress , value , deployedContractAbi , deployedContractAddress ){ const web3 = new Web3 ( host ); const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . set ( value ). send ({ from : accountAddress , gasPrice : \"0x0\" , gasLimit : \"0x24A22\" }); return res }","title":"2. Perform a write operation"},{"location":"tutorials/contracts/calling-contract-functions/#3-verify-an-updated-value","text":"To verify that a value has been updated, perform a get call after a set update call.","title":"3. Verify an updated value"},{"location":"tutorials/contracts/calling-contract-functions/#interact-with-private-contracts","text":"This private contracts example uses the same SimpleStorage.sol contract as in the public contracts example , but it uses the eth_sendRawPrivateTransaction method to interact with the contract. Both read and write operations are performed using the eea_sendRawTransaction API call. The Quorum Developer quickstart provides a full example of a private contract script .","title":"Interact with private contracts"},{"location":"tutorials/contracts/calling-contract-functions/#1-perform-a-read-operation_1","text":"Performing a read operation on a contract is identical to the public contract example , and you need the address that the contract was deployed to and the contract\u2019s ABI. Use the web3.eth.Contract object to create a new instance of the smart contract, then make the get function call from the contract\u2019s list of methods, which will return the value stored: async function getValueAtAddress ( host , deployedContractAbi , deployedContractAddress ){ const web3 = new Web3 ( host ); const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . get (). call (); console . log ( \"Obtained value at deployed contract is: \" + res ); return res }","title":"1. Perform a read operation"},{"location":"tutorials/contracts/calling-contract-functions/#2-perform-a-write-operation_1","text":"Performing a write operation is almost the same process as the read operation, except that you encode the new value to the set function\u2019s ABI, and then append these arguments to the set function\u2019s ABI and use this as the data field. Additionally provide the public key of the Transaction Manager of the respective node. async function setValueAtAddress ( host , value , deployedContractAbi , deployedContractAddress , fromAddress , toPublicKey ) { const web3 = new Web3 ( host ) const contractInstance = new web3 . eth . Contract ( deployedContractAbi , deployedContractAddress ); const res = await contractInstance . methods . set ( value ). send ({ from : fromAddress , privateFor : [ toPublicKey ], gasLimit : \"0x24A22\" }); return res }","title":"2. Perform a write operation"},{"location":"tutorials/contracts/calling-contract-functions/#3-verify-an-updated-value_1","text":"To verify that a value has been updated, perform a get call after a set update call.","title":"3. Verify an updated value"},{"location":"tutorials/contracts/deploying-contracts/","text":"Deploy a smart contract \u00b6 This tutorial shows you how to deploy smart contracts as transactions onto a running network. Use the Quorum Developer Quickstart to rapidly generate a local blockchain network. Prerequisites \u00b6 A private network if deploying a public contract. A privacy-enabled network if deploying a private contract (public contracts can also be deployed on privacy-enabled networks). Note You can use the Quorum Developer Quickstart to deploy either public contracts or private contracts. To enable privacy, enter Y at the prompt for private transactions. Compile the contract \u00b6 You first need to create a smart contract. The following examples use the SimpleStorage.sol smart contract. Create a new file called compile.js with the following content: compile.js const fs = require ( 'fs' ). promises ; const solc = require ( 'solc' ); async function main () { // Load the contract source code const sourceCode = await fs . readFile ( 'SimpleStorage.sol' , 'utf8' ); // Compile the source code and retrieve the ABI and bytecode const { abi , bytecode } = compile ( sourceCode , 'SimpleStorage' ); // Store the ABI and bytecode into a JSON file const artifact = JSON . stringify ({ abi , bytecode }, null , 2 ); await fs . writeFile ( 'SimpleStorage.json' , artifact ); } function compile ( sourceCode , contractName ) { // Create the Solidity Compiler Standard Input and Output JSON const input = { language : 'Solidity' , sources : { main : { content : sourceCode } }, settings : { outputSelection : { '*' : { '*' : [ 'abi' , 'evm.bytecode' ] } } }, }; // Parse the compiler output to retrieve the ABI and bytecode const output = solc . compile ( JSON . stringify ( input )); const artifact = JSON . parse ( output ). contracts . main [ contractName ]; return { abi : artifact . abi , bytecode : artifact . evm . bytecode . object , }; } main (). then (() => process . exit ( 0 )); Run the compile code to get the smart contract\u2019s output JSON: node compile.js Run solc to get the contract\u2019s bytecode and ABI: solc SimpleStorage.sol --bin --abi Once you have the bytecode and ABI, you can rename the output files to make them easier to use. This tutorial refers to them as SimpleStorage.bin and SimpleStorage.abi . You can now deploy this contract to a network as a public or private transaction. Public contracts \u00b6 1. Using eth_sendTransaction \u00b6 Call eth_sendTransaction with the following parameters: from - Address of the sender\u2019s account. to - Address of the receiver. To deploy a contract, set to null . gas - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas the sender is willing to pay. Set to zero in GoQuorum networks. data - One of the following: For contract deployments (this use case), the compiled binary of the contract . For contract interactions, the hash of the invoked method signature and encoded parameters (see Ethereum Contract ABI ). For simple ether transfers, empty. Example eth_sendTransaction curl HTTP request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"0xf0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\", \"to\":null, \"gas\":\"0x24A22\",\"gasPrice\":\"0x0\", \"data\":\"0x608060405234801561001057600080fd5b5060405161014d38038061014d8339818101604052602081101561003357600080fd5b8101908080519060200190929190505050806000819055505060f38061005a6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80632a1afcd914604157806360fe47b114605d5780636d4ce63c146088575b600080fd5b604760a4565b6040518082815260200191505060405180910390f35b608660048036036020811015607157600080fd5b810190808035906020019092919050505060aa565b005b608e60b4565b6040518082815260200191505060405180910390f35b60005481565b8060008190555050565b6000805490509056fea2646970667358221220e6966e446bd0af8e6af40eb0d8f323dd02f771ba1f11ae05c65d1624ffb3c58264736f6c63430007060033\"}], \"id\":1}' -H 'Content-Type: application/json' http://localhost:20000 If using the Quorum Developer Quickstart , use the from address and RPC endoint of Member1. 2. Using web3.eth.Contract \u00b6 Using the outputs from compiling the contract , create a new file public_tx_web3.js (or run the following commands in a JavaScript console) to send the transaction. The example code uses the Developer Quickstart and sends the transaction from Member1. public_tx_web3.js const path = require ( 'path' ); const fs = require ( 'fs-extra' ); const web3 = new Web3 ( host ); // use the existing Member1 account address or make a new account const address = \"f0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\" ; // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractByteCode = contractJson . evm . bytecode . object async function createContract ( host , contractAbi , contractByteCode , contractInit , fromAddress ) { const web3 = new Web3 ( host ) const contractInstance = new web3 . eth . Contract ( contractAbi ); const ci = await contractInstance . deploy ({ data : '0x' + contractByteCode , arguments : [ contractInit ] }) . send ({ from : fromAddress , gasLimit : \"0x24A22\" }) . on ( 'transactionHash' , function ( hash ){ console . log ( \"The transaction hash is: \" + hash ); }); return ci ; }; // create the contract async function main (){ // using Member1 to send the transaction from createContract ( \"http://localhost:20000\" , contractAbi , contractByteCode , 47 , address ) . then ( async function ( ci ){ console . log ( \"Address of transaction: \" , ci . options . address ); }) . catch ( console . error ); } Info This example uses the web3js library and the web3.eth.Contract object to interact with smart contracts on the chain. Once the contract object is created, you give it the JSON interface of the smart contract and the library converts the calls into low level ABI calls over RPC for you. This benefits you as a developer as it allows you to interact with smart contracts as if they were JavaScript objects. 3. Using eth_sendSignedTransaction \u00b6 To deploy a smart contract using eth_sendSignedTransaction , use an account\u2019s private key to sign and serialize the transaction, and send the API request. This example uses the web3js library to make the API calls and the outputs from compiling the contract . Create a new file public_tx.js (or run the following commands in a JavaScript console) to send the transaction. public_tx.js const web3 = new Web3 ( \"http://localhost:20000\" ); // use an existing account or make a new account const privateKey = \"b9a4bd1539c15bcc83fa9078fe89200b6e9e802ae992f13cd83c853f16e8bed4\" ; const account = web3 . eth . accounts . privateKeyToAccount ( privateKey ); // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractBinPath = path . resolve ( __dirname , 'SimpleStorage.bin' ); const contractBin = fs . readFileSync ( contractBinPath ); // initialize the default constructor with a value `47 = 0x2F`; this value is appended to the bytecode const contractConstructorInit = \"000000000000000000000000000000000000000000000000000000000000002F\" ; // get txnCount for the nonce value const txnCount = await web3 . eth . getTransactionCount ( account . address ); const rawTxOptions = { nonce : web3 . utils . numberToHex ( txnCount ), from : account . address , to : null , // public tx value : \"0x00\" , data : '0x' + contractBin + contractInit , // contract binary appended with initialization value gasPrice : \"0x0\" , // Set to 0 in GoQuorum networks gasLimit : \"0x24A22\" // max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const tx = new Tx ( rawTxOptions ); console . log ( \"Signing transaction...\" ); tx . sign ( privateKey ); console . log ( \"Sending transaction...\" ); var serializedTx = tx . serialize (); const txr = await web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' ). toString ( \"hex\" )); console . log ( \"tx transactionHash: \" + txr . transactionHash ); console . log ( \"tx contractAddress: \" + txr . contractAddress ); rawTxOptions contains the following fields: nonce - Number of transactions sent from this address. from - Address of the EthSigner account. to - Address of the receiver. To deploy a contract, set to null . gas - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas. Set to zero in GoQuorum networks. data - Binary of the contract (in this example there\u2019s also a constructor initialization value appended to the binary value). value - Amount of ETH in Wei transferred from the sender to the recipient. As the example demonstrates, once the transaction tx is created, you can sign it with the private key of the account. You can then serialize it and call eth_sendSignedTransaction to deploy the contract. For reference, the Developer Quickstart provides an example of a public transaction script . Private contracts \u00b6 1. Using eth_sendTransaction \u00b6 Call eth_sendTransaction with the following parameters: from - Address of the sender\u2019s account. to - Address of the receiver. To deploy a contract, set to null . gas - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas. Set to zero in GoQuorum networks. privateFrom - The sender\u2019s base-64-encoded public key. privateFor - Array of the recipient\u2019s base-64-encoded public keys. privacyFlag - 0 for standard private, 1 for counter party protection . and 3 for private state validation . data - One of the following: For contract deployments (this use case), the compiled binary of the contract . For contract interactions, the hash of the invoked method signature and encoded parameters (see Ethereum Contract ABI ). For simple ether transfers, empty. Example eth_sendTransaction curl HTTP request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"0xf0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\", \"to\":null, \"gas\":\"0x24A22\",\"gasPrice\":\"0x0\", \"privateFrom\": \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\", \"privateFor\": [\"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\"], \"privacyFlag\": 0,\"data\":\"0x608060405234801561001057600080fd5b5060405161014d38038061014d8339818101604052602081101561003357600080fd5b8101908080519060200190929190505050806000819055505060f38061005a6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80632a1afcd914604157806360fe47b114605d5780636d4ce63c146088575b600080fd5b604760a4565b6040518082815260200191505060405180910390f35b608660048036036020811015607157600080fd5b810190808035906020019092919050505060aa565b005b608e60b4565b6040518082815260200191505060405180910390f35b60005481565b8060008190555050565b6000805490509056fea2646970667358221220e6966e446bd0af8e6af40eb0d8f323dd02f771ba1f11ae05c65d1624ffb3c58264736f6c63430007060033\"}], \"id\":1}' -H 'Content-Type: application/json' http://localhost:20000 If using the Quorum Developer Quickstart , use the from address and RPC endoint of Member1. 2. Using web3.eth.Contract \u00b6 Using the outputs from compiling the contract , create a new file private_tx_web3.js (or run the following commands in a JavaScript console) to send the transaction. The example code uses the Developer Quickstart and sends the transaction from Member1. private_tx_web3.js const path = require ( 'path' ); const fs = require ( 'fs-extra' ); const web3 = new Web3 ( host ); // use the existing Member1 account or make a new account const privateKey = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ; // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractByteCode = contractJson . evm . bytecode . object async function createContract ( host , contractAbi , contractByteCode , contractInit , fromAddress , toPublicKey ) { const web3 = new Web3 ( host ) const contractInstance = new web3 . eth . Contract ( contractAbi ); const ci = await contractInstance . deploy ({ data : '0x' + contractByteCode , arguments : [ contractInit ] }) . send ({ from : fromAddress , privateFor : [ toPublicKey ], gasLimit : \"0x24A22\" }) . on ( 'transactionHash' , function ( hash ){ console . log ( \"The transaction hash is: \" + hash ); }); return ci ; }; // create the contract async function main (){ // sending the transaction from Member1 to Member3 createContract ( \"http://localhost:20000\" , contractAbi , contractByteCode , 47 , \"f0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\" , \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" ) . then ( async function ( ci ){ console . log ( \"Address of transaction: \" , ci . options . address ); }) . catch ( console . error ); } For reference, the Developer Quickstart provides an example of a private transaction script using web3 . 3. Using priv.generateAndSendRawTransaction \u00b6 This example uses the web3js-quorum library to make the priv.generateAndSendRawTransaction API call. Create a new file private_tx_web3js_quorum.js (or run the following commands in a JavaScript console) to send the transaction. private_tx_web3js_quorum.js const Web3 = require ( 'web3' ); const Web3Quorum = require ( 'web3js-quorum' ); // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractBinPath = path . resolve ( __dirname , 'SimpleStorage.bin' ); const contractBin = fs . readFileSync ( contractBinPath ); // initialize the default constructor with a value `47 = 0x2F`; this value is appended to the bytecode const contractConstructorInit = \"000000000000000000000000000000000000000000000000000000000000002F\" ; // account details // unlock the account so you can sign the tx const accountKeyPath = path . resolve ( __dirname , '../../' , 'config/quorum/networkFiles/member1/accountkey' ); const accountKey = JSON . parse ( fs . readFileSync ( accountKeyPath )); const signingAccount = web3 . eth . accounts . decrypt ( accountKey , \"\" ); const web3 = new Web3 ( \"http://localhost:20000\" ); const web3quorum = new Web3Quorum ( web3 , { privateUrl : client . privateUrl }, true ); // get the nonce for the accountAddress const accountAddress = client . accountAddress ; const txCount = await web3 . eth . getTransactionCount ( `0x ${ accountAddress } ` ); const txOptions = { nonce : txCount , gasPrice : 0 , //Set to 0 in GoQuorum networks gasLimit : 0x24A22 , //max number of gas units the tx is allowed to use value : 0 , data : '0x' + contractBin + contractConstructorInit , from : signingAccount , isPrivate : true , privateKey : fromPrivateKey , privateFrom : fromPublicKey , privateFor : [ toPublicKey ] }; console . log ( \"Creating contract...\" ); const txHash = await web3quorum . priv . generateAndSendRawTransaction ( txOptions ); console . log ( \"Getting contractAddress from txHash: \" , txHash ); console . log ( \"Private Transaction Receipt: \" , txHash . contractAddress ); txOptions contains the following fields: nonce - Number of transactions sent from this address. from - Address of the EthSigner account. gasLimit - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas. Set to zero in GoQuorum networks. isPrivate - Indicates that this is a private transaction. privateKey - The sender\u2019s GoQuorum node private key. privateFrom - The sender\u2019s base-64-encoded public key. privateFor - Array of the recipient\u2019s base-64-encoded public keys. data - Binary of the contract (in this example there\u2019s also a constructor initialization value appended to the binary value). For reference, the Developer Quickstart provides an example of a private transaction script .","title":"Deploy a contract"},{"location":"tutorials/contracts/deploying-contracts/#deploy-a-smart-contract","text":"This tutorial shows you how to deploy smart contracts as transactions onto a running network. Use the Quorum Developer Quickstart to rapidly generate a local blockchain network.","title":"Deploy a smart contract"},{"location":"tutorials/contracts/deploying-contracts/#prerequisites","text":"A private network if deploying a public contract. A privacy-enabled network if deploying a private contract (public contracts can also be deployed on privacy-enabled networks). Note You can use the Quorum Developer Quickstart to deploy either public contracts or private contracts. To enable privacy, enter Y at the prompt for private transactions.","title":"Prerequisites"},{"location":"tutorials/contracts/deploying-contracts/#compile-the-contract","text":"You first need to create a smart contract. The following examples use the SimpleStorage.sol smart contract. Create a new file called compile.js with the following content: compile.js const fs = require ( 'fs' ). promises ; const solc = require ( 'solc' ); async function main () { // Load the contract source code const sourceCode = await fs . readFile ( 'SimpleStorage.sol' , 'utf8' ); // Compile the source code and retrieve the ABI and bytecode const { abi , bytecode } = compile ( sourceCode , 'SimpleStorage' ); // Store the ABI and bytecode into a JSON file const artifact = JSON . stringify ({ abi , bytecode }, null , 2 ); await fs . writeFile ( 'SimpleStorage.json' , artifact ); } function compile ( sourceCode , contractName ) { // Create the Solidity Compiler Standard Input and Output JSON const input = { language : 'Solidity' , sources : { main : { content : sourceCode } }, settings : { outputSelection : { '*' : { '*' : [ 'abi' , 'evm.bytecode' ] } } }, }; // Parse the compiler output to retrieve the ABI and bytecode const output = solc . compile ( JSON . stringify ( input )); const artifact = JSON . parse ( output ). contracts . main [ contractName ]; return { abi : artifact . abi , bytecode : artifact . evm . bytecode . object , }; } main (). then (() => process . exit ( 0 )); Run the compile code to get the smart contract\u2019s output JSON: node compile.js Run solc to get the contract\u2019s bytecode and ABI: solc SimpleStorage.sol --bin --abi Once you have the bytecode and ABI, you can rename the output files to make them easier to use. This tutorial refers to them as SimpleStorage.bin and SimpleStorage.abi . You can now deploy this contract to a network as a public or private transaction.","title":"Compile the contract"},{"location":"tutorials/contracts/deploying-contracts/#public-contracts","text":"","title":"Public contracts"},{"location":"tutorials/contracts/deploying-contracts/#1-using-eth_sendtransaction","text":"Call eth_sendTransaction with the following parameters: from - Address of the sender\u2019s account. to - Address of the receiver. To deploy a contract, set to null . gas - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas the sender is willing to pay. Set to zero in GoQuorum networks. data - One of the following: For contract deployments (this use case), the compiled binary of the contract . For contract interactions, the hash of the invoked method signature and encoded parameters (see Ethereum Contract ABI ). For simple ether transfers, empty. Example eth_sendTransaction curl HTTP request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"0xf0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\", \"to\":null, \"gas\":\"0x24A22\",\"gasPrice\":\"0x0\", \"data\":\"0x608060405234801561001057600080fd5b5060405161014d38038061014d8339818101604052602081101561003357600080fd5b8101908080519060200190929190505050806000819055505060f38061005a6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80632a1afcd914604157806360fe47b114605d5780636d4ce63c146088575b600080fd5b604760a4565b6040518082815260200191505060405180910390f35b608660048036036020811015607157600080fd5b810190808035906020019092919050505060aa565b005b608e60b4565b6040518082815260200191505060405180910390f35b60005481565b8060008190555050565b6000805490509056fea2646970667358221220e6966e446bd0af8e6af40eb0d8f323dd02f771ba1f11ae05c65d1624ffb3c58264736f6c63430007060033\"}], \"id\":1}' -H 'Content-Type: application/json' http://localhost:20000 If using the Quorum Developer Quickstart , use the from address and RPC endoint of Member1.","title":"1. Using eth_sendTransaction"},{"location":"tutorials/contracts/deploying-contracts/#2-using-web3ethcontract","text":"Using the outputs from compiling the contract , create a new file public_tx_web3.js (or run the following commands in a JavaScript console) to send the transaction. The example code uses the Developer Quickstart and sends the transaction from Member1. public_tx_web3.js const path = require ( 'path' ); const fs = require ( 'fs-extra' ); const web3 = new Web3 ( host ); // use the existing Member1 account address or make a new account const address = \"f0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\" ; // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractByteCode = contractJson . evm . bytecode . object async function createContract ( host , contractAbi , contractByteCode , contractInit , fromAddress ) { const web3 = new Web3 ( host ) const contractInstance = new web3 . eth . Contract ( contractAbi ); const ci = await contractInstance . deploy ({ data : '0x' + contractByteCode , arguments : [ contractInit ] }) . send ({ from : fromAddress , gasLimit : \"0x24A22\" }) . on ( 'transactionHash' , function ( hash ){ console . log ( \"The transaction hash is: \" + hash ); }); return ci ; }; // create the contract async function main (){ // using Member1 to send the transaction from createContract ( \"http://localhost:20000\" , contractAbi , contractByteCode , 47 , address ) . then ( async function ( ci ){ console . log ( \"Address of transaction: \" , ci . options . address ); }) . catch ( console . error ); } Info This example uses the web3js library and the web3.eth.Contract object to interact with smart contracts on the chain. Once the contract object is created, you give it the JSON interface of the smart contract and the library converts the calls into low level ABI calls over RPC for you. This benefits you as a developer as it allows you to interact with smart contracts as if they were JavaScript objects.","title":"2. Using web3.eth.Contract"},{"location":"tutorials/contracts/deploying-contracts/#3-using-eth_sendsignedtransaction","text":"To deploy a smart contract using eth_sendSignedTransaction , use an account\u2019s private key to sign and serialize the transaction, and send the API request. This example uses the web3js library to make the API calls and the outputs from compiling the contract . Create a new file public_tx.js (or run the following commands in a JavaScript console) to send the transaction. public_tx.js const web3 = new Web3 ( \"http://localhost:20000\" ); // use an existing account or make a new account const privateKey = \"b9a4bd1539c15bcc83fa9078fe89200b6e9e802ae992f13cd83c853f16e8bed4\" ; const account = web3 . eth . accounts . privateKeyToAccount ( privateKey ); // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractBinPath = path . resolve ( __dirname , 'SimpleStorage.bin' ); const contractBin = fs . readFileSync ( contractBinPath ); // initialize the default constructor with a value `47 = 0x2F`; this value is appended to the bytecode const contractConstructorInit = \"000000000000000000000000000000000000000000000000000000000000002F\" ; // get txnCount for the nonce value const txnCount = await web3 . eth . getTransactionCount ( account . address ); const rawTxOptions = { nonce : web3 . utils . numberToHex ( txnCount ), from : account . address , to : null , // public tx value : \"0x00\" , data : '0x' + contractBin + contractInit , // contract binary appended with initialization value gasPrice : \"0x0\" , // Set to 0 in GoQuorum networks gasLimit : \"0x24A22\" // max number of gas units the tx is allowed to use }; console . log ( \"Creating transaction...\" ); const tx = new Tx ( rawTxOptions ); console . log ( \"Signing transaction...\" ); tx . sign ( privateKey ); console . log ( \"Sending transaction...\" ); var serializedTx = tx . serialize (); const txr = await web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' ). toString ( \"hex\" )); console . log ( \"tx transactionHash: \" + txr . transactionHash ); console . log ( \"tx contractAddress: \" + txr . contractAddress ); rawTxOptions contains the following fields: nonce - Number of transactions sent from this address. from - Address of the EthSigner account. to - Address of the receiver. To deploy a contract, set to null . gas - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas. Set to zero in GoQuorum networks. data - Binary of the contract (in this example there\u2019s also a constructor initialization value appended to the binary value). value - Amount of ETH in Wei transferred from the sender to the recipient. As the example demonstrates, once the transaction tx is created, you can sign it with the private key of the account. You can then serialize it and call eth_sendSignedTransaction to deploy the contract. For reference, the Developer Quickstart provides an example of a public transaction script .","title":"3. Using eth_sendSignedTransaction"},{"location":"tutorials/contracts/deploying-contracts/#private-contracts","text":"","title":"Private contracts"},{"location":"tutorials/contracts/deploying-contracts/#1-using-eth_sendtransaction_1","text":"Call eth_sendTransaction with the following parameters: from - Address of the sender\u2019s account. to - Address of the receiver. To deploy a contract, set to null . gas - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas. Set to zero in GoQuorum networks. privateFrom - The sender\u2019s base-64-encoded public key. privateFor - Array of the recipient\u2019s base-64-encoded public keys. privacyFlag - 0 for standard private, 1 for counter party protection . and 3 for private state validation . data - One of the following: For contract deployments (this use case), the compiled binary of the contract . For contract interactions, the hash of the invoked method signature and encoded parameters (see Ethereum Contract ABI ). For simple ether transfers, empty. Example eth_sendTransaction curl HTTP request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"0xf0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\", \"to\":null, \"gas\":\"0x24A22\",\"gasPrice\":\"0x0\", \"privateFrom\": \"BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo=\", \"privateFor\": [\"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\"], \"privacyFlag\": 0,\"data\":\"0x608060405234801561001057600080fd5b5060405161014d38038061014d8339818101604052602081101561003357600080fd5b8101908080519060200190929190505050806000819055505060f38061005a6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80632a1afcd914604157806360fe47b114605d5780636d4ce63c146088575b600080fd5b604760a4565b6040518082815260200191505060405180910390f35b608660048036036020811015607157600080fd5b810190808035906020019092919050505060aa565b005b608e60b4565b6040518082815260200191505060405180910390f35b60005481565b8060008190555050565b6000805490509056fea2646970667358221220e6966e446bd0af8e6af40eb0d8f323dd02f771ba1f11ae05c65d1624ffb3c58264736f6c63430007060033\"}], \"id\":1}' -H 'Content-Type: application/json' http://localhost:20000 If using the Quorum Developer Quickstart , use the from address and RPC endoint of Member1.","title":"1. Using eth_sendTransaction"},{"location":"tutorials/contracts/deploying-contracts/#2-using-web3ethcontract_1","text":"Using the outputs from compiling the contract , create a new file private_tx_web3.js (or run the following commands in a JavaScript console) to send the transaction. The example code uses the Developer Quickstart and sends the transaction from Member1. private_tx_web3.js const path = require ( 'path' ); const fs = require ( 'fs-extra' ); const web3 = new Web3 ( host ); // use the existing Member1 account or make a new account const privateKey = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ; // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractByteCode = contractJson . evm . bytecode . object async function createContract ( host , contractAbi , contractByteCode , contractInit , fromAddress , toPublicKey ) { const web3 = new Web3 ( host ) const contractInstance = new web3 . eth . Contract ( contractAbi ); const ci = await contractInstance . deploy ({ data : '0x' + contractByteCode , arguments : [ contractInit ] }) . send ({ from : fromAddress , privateFor : [ toPublicKey ], gasLimit : \"0x24A22\" }) . on ( 'transactionHash' , function ( hash ){ console . log ( \"The transaction hash is: \" + hash ); }); return ci ; }; // create the contract async function main (){ // sending the transaction from Member1 to Member3 createContract ( \"http://localhost:20000\" , contractAbi , contractByteCode , 47 , \"f0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\" , \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" ) . then ( async function ( ci ){ console . log ( \"Address of transaction: \" , ci . options . address ); }) . catch ( console . error ); } For reference, the Developer Quickstart provides an example of a private transaction script using web3 .","title":"2. Using web3.eth.Contract"},{"location":"tutorials/contracts/deploying-contracts/#3-using-privgenerateandsendrawtransaction","text":"This example uses the web3js-quorum library to make the priv.generateAndSendRawTransaction API call. Create a new file private_tx_web3js_quorum.js (or run the following commands in a JavaScript console) to send the transaction. private_tx_web3js_quorum.js const Web3 = require ( 'web3' ); const Web3Quorum = require ( 'web3js-quorum' ); // read in the contracts const contractJsonPath = path . resolve ( __dirname , 'SimpleStorage.json' ); const contractJson = JSON . parse ( fs . readFileSync ( contractJsonPath )); const contractAbi = contractJson . abi ; const contractBinPath = path . resolve ( __dirname , 'SimpleStorage.bin' ); const contractBin = fs . readFileSync ( contractBinPath ); // initialize the default constructor with a value `47 = 0x2F`; this value is appended to the bytecode const contractConstructorInit = \"000000000000000000000000000000000000000000000000000000000000002F\" ; // account details // unlock the account so you can sign the tx const accountKeyPath = path . resolve ( __dirname , '../../' , 'config/quorum/networkFiles/member1/accountkey' ); const accountKey = JSON . parse ( fs . readFileSync ( accountKeyPath )); const signingAccount = web3 . eth . accounts . decrypt ( accountKey , \"\" ); const web3 = new Web3 ( \"http://localhost:20000\" ); const web3quorum = new Web3Quorum ( web3 , { privateUrl : client . privateUrl }, true ); // get the nonce for the accountAddress const accountAddress = client . accountAddress ; const txCount = await web3 . eth . getTransactionCount ( `0x ${ accountAddress } ` ); const txOptions = { nonce : txCount , gasPrice : 0 , //Set to 0 in GoQuorum networks gasLimit : 0x24A22 , //max number of gas units the tx is allowed to use value : 0 , data : '0x' + contractBin + contractConstructorInit , from : signingAccount , isPrivate : true , privateKey : fromPrivateKey , privateFrom : fromPublicKey , privateFor : [ toPublicKey ] }; console . log ( \"Creating contract...\" ); const txHash = await web3quorum . priv . generateAndSendRawTransaction ( txOptions ); console . log ( \"Getting contractAddress from txHash: \" , txHash ); console . log ( \"Private Transaction Receipt: \" , txHash . contractAddress ); txOptions contains the following fields: nonce - Number of transactions sent from this address. from - Address of the EthSigner account. gasLimit - Amount of gas provided by the sender for the transaction. gasPrice - Price for each unit of gas. Set to zero in GoQuorum networks. isPrivate - Indicates that this is a private transaction. privateKey - The sender\u2019s GoQuorum node private key. privateFrom - The sender\u2019s base-64-encoded public key. privateFor - Array of the recipient\u2019s base-64-encoded public keys. data - Binary of the contract (in this example there\u2019s also a constructor initialization value appended to the binary value). For reference, the Developer Quickstart provides an example of a private transaction script .","title":"3. Using priv.generateAndSendRawTransaction"},{"location":"tutorials/kubernetes/","text":"Deploy GoQuorum with Kubernetes \u00b6 Use the reference implementations to install private networks using Kubernetes (K8s). Reference implementations are available using: Helm . Helmfile . kubectl . Familiarize yourself with the reference implementations and customize them for your requirements. Quorum-Kubernetes \u00b6 Quorum-Kubernetes is a repository containing Kubernetes manifests and Helm charts that you can customize and deploy on a local cluster or in the cloud. Important We recommend starting with the playground directory and working through the example setups before moving to the dev directory, and finally to the prod directory. The dev and prod directories are identical in terms of what gets deployed, but differ in that the prod folder uses best practices to manage identity (Managed Identities in Azure and IAM in AWS), vaults (KeyVault in Azure and Secrets Manager in AWS), and CSI drivers. All setups use monitoring and we recommend deploying the monitoring manifests or charts to get an overview of the network, nodes, and volumes, and you can create alerts accordingly. In addition, there\u2019s an example configuration for Ingress and routes that you can customize to suit your requirements. Cloud support \u00b6 The repository\u2019s dev charts support on-premise and cloud providers such as AWS, Azure, GCP, and IBM. The prod charts currently only support AWS EKS and Azure AKS natively. You can configure the provider in the values.yml file by setting provider to local , aws , or azure . You can also pass in extra configuratiosn such as a KeyVault name (Azure only). The repository also contains Azure ARM templates and AWS eksctl templates to deploy the required base infrastructure. Limitations \u00b6 When using multi-clusters, Kubernetes load balancers disallow TCP and UDP traffic on the same port, which inhibits discovery working natively for each pod. Use the following solutions to mitigate this limitation: Disallow discovery and use static nodes to allow only TCP traffic. This isn\u2019t an issue for load balancers or exposing nodes publicly. If you need to use discovery, use something such as CNI which is supported by all major cloud providers, and the cloud templates already have CNI implemented. CNI \u00b6 With the traditional kubenet networking mode, nodes get an IP from the virtual network subnet. Each node in turn uses NAT to configure the pods so that they reach other pods on the virtual network. This limits where they can reach but also more specifically what can reach them. For example, an external VM which must have custom routes doesn\u2019t scale well. CNI, on the other hand, allows every pod to get a unique IP directly from the virtual subnet which removes this restriction. Therefore, it has a limit on the maximum number of pods that can be spun up, so you must plan ahead to avoid IP exhaustion. Multi-cluster \u00b6 You must enable CNI to use multi-cluster, or to connect external nodes to an existing Kubernetes cluster. To connect multiple clusters, they must each have different CIDR blocks to ensure no conflicts, and the first step is to peer the VPCs or VNets together and update the route tables. From that point on you can use static nodes and pods to communicate across the cluster. The same setup also works to connect external nodes and business applications from other infrastructure, either in the cloud or on premise. Concepts \u00b6 Storage \u00b6 We recommend using Storage Classes and Persistent Volume Claims (PVCs) . When using PVCs, set the allowVolumeExpansion to true . This helps keep costs low and enables growing the volume over time rather than creating new volumes and copying data across. Namespaces \u00b6 In Kubernetes, namespaces provide a mechanism for isolating groups of resources within a single cluster. Both namespaces and resources (for example, StatefulSets or Services) within a namespace must be unique, but resources across namespaces don\u2019t need to be. Note Namespace-based scoping is not applicable for cluster-wide objects (for example, StorageClass or PersistentVolumes).","title":"Deploy a GoQuorum private network with Kubernetes"},{"location":"tutorials/kubernetes/#deploy-goquorum-with-kubernetes","text":"Use the reference implementations to install private networks using Kubernetes (K8s). Reference implementations are available using: Helm . Helmfile . kubectl . Familiarize yourself with the reference implementations and customize them for your requirements.","title":"Deploy GoQuorum with Kubernetes"},{"location":"tutorials/kubernetes/#quorum-kubernetes","text":"Quorum-Kubernetes is a repository containing Kubernetes manifests and Helm charts that you can customize and deploy on a local cluster or in the cloud. Important We recommend starting with the playground directory and working through the example setups before moving to the dev directory, and finally to the prod directory. The dev and prod directories are identical in terms of what gets deployed, but differ in that the prod folder uses best practices to manage identity (Managed Identities in Azure and IAM in AWS), vaults (KeyVault in Azure and Secrets Manager in AWS), and CSI drivers. All setups use monitoring and we recommend deploying the monitoring manifests or charts to get an overview of the network, nodes, and volumes, and you can create alerts accordingly. In addition, there\u2019s an example configuration for Ingress and routes that you can customize to suit your requirements.","title":"Quorum-Kubernetes"},{"location":"tutorials/kubernetes/#cloud-support","text":"The repository\u2019s dev charts support on-premise and cloud providers such as AWS, Azure, GCP, and IBM. The prod charts currently only support AWS EKS and Azure AKS natively. You can configure the provider in the values.yml file by setting provider to local , aws , or azure . You can also pass in extra configuratiosn such as a KeyVault name (Azure only). The repository also contains Azure ARM templates and AWS eksctl templates to deploy the required base infrastructure.","title":"Cloud support"},{"location":"tutorials/kubernetes/#limitations","text":"When using multi-clusters, Kubernetes load balancers disallow TCP and UDP traffic on the same port, which inhibits discovery working natively for each pod. Use the following solutions to mitigate this limitation: Disallow discovery and use static nodes to allow only TCP traffic. This isn\u2019t an issue for load balancers or exposing nodes publicly. If you need to use discovery, use something such as CNI which is supported by all major cloud providers, and the cloud templates already have CNI implemented.","title":"Limitations"},{"location":"tutorials/kubernetes/#cni","text":"With the traditional kubenet networking mode, nodes get an IP from the virtual network subnet. Each node in turn uses NAT to configure the pods so that they reach other pods on the virtual network. This limits where they can reach but also more specifically what can reach them. For example, an external VM which must have custom routes doesn\u2019t scale well. CNI, on the other hand, allows every pod to get a unique IP directly from the virtual subnet which removes this restriction. Therefore, it has a limit on the maximum number of pods that can be spun up, so you must plan ahead to avoid IP exhaustion.","title":"CNI"},{"location":"tutorials/kubernetes/#multi-cluster","text":"You must enable CNI to use multi-cluster, or to connect external nodes to an existing Kubernetes cluster. To connect multiple clusters, they must each have different CIDR blocks to ensure no conflicts, and the first step is to peer the VPCs or VNets together and update the route tables. From that point on you can use static nodes and pods to communicate across the cluster. The same setup also works to connect external nodes and business applications from other infrastructure, either in the cloud or on premise.","title":"Multi-cluster"},{"location":"tutorials/kubernetes/#concepts","text":"","title":"Concepts"},{"location":"tutorials/kubernetes/#storage","text":"We recommend using Storage Classes and Persistent Volume Claims (PVCs) . When using PVCs, set the allowVolumeExpansion to true . This helps keep costs low and enables growing the volume over time rather than creating new volumes and copying data across.","title":"Storage"},{"location":"tutorials/kubernetes/#namespaces","text":"In Kubernetes, namespaces provide a mechanism for isolating groups of resources within a single cluster. Both namespaces and resources (for example, StatefulSets or Services) within a namespace must be unique, but resources across namespaces don\u2019t need to be. Note Namespace-based scoping is not applicable for cluster-wide objects (for example, StorageClass or PersistentVolumes).","title":"Namespaces"},{"location":"tutorials/kubernetes/create-cluster/","text":"Create a cluster \u00b6 You can create a local or cloud cluster to deploy a GoQuorum network using Kubernetes. Prerequisites \u00b6 Clone the Quorum-Kubernetes repository Install Kubectl Install Helm3 Install AWS CLI and eksctl for AWS EKS clusters Install Azure CLI for Azure AKS clusters Install the cloud-specific CLI Local clusters \u00b6 There are several options to create a local cluster. Select one listed below, or another that you\u2019re comfortable with. Minikube \u00b6 Minikube is one of the most popular options to spin up a local Kubernetes cluster for development. You can install a version based on your architecture. Note We recommend at least 2 CPUs and 16GB of RAM. To start the cluster run the following command: minikube start --cpus 2 --memory 16384 --cni auto kind \u00b6 kind (Kubernetes in Docker) is a lightweight tool for running local Kubernetes clusters. The installation is similar to Minikube . To start the cluster run the following command: kind create cluster Rancher \u00b6 Rancher is a lightweight open source desktop application for Mac, Windows, and Linux. It provides Kubernetes and container management, and allows you to choose the version of Kubernetes to run. It can build, push, pull and run container images. Built container images can be run without needing a registry. Note The official Docker-CLI is not supported but rather uses nerdctl which is a Docker-CLI compatible tool for containerd, and is automatically installed with Rancher Desktop. Note For Windows, you must install Windows Subsystem for Linux (WSL) to install Rancher Desktop. Refer to the official documentation for system requirements and installation instructions. Cloud clusters \u00b6 AWS EKS \u00b6 AWS Elastic Kubernetes Service (AWS EKS) is one of the most popular platforms to deploy GoQuorum. To create a cluster in AWS, you must install the AWS CLI and eksctl . The template comprises the base infrastructure used to build the cluster and other resources in AWS. We also use AWS native services and features after the cluster is created. These include: Pod identities . Secrets Store CSI drivers . Dynamic storage classes backed by AWS EBS. The volume claims are fixed sizes and can be updated as you grow via helm updates, and won\u2019t need to re-provision the underlying storage class. CNI networking mode for EKS. By default, EKS clusters use kubenet to create a virtual network and subnet. Nodes get an IP address from a virtual network subnet. Network address translation (NAT) is then configured on the nodes, and pods receive an IP address \u201chidden\u201d behind the node IP. Note This approach reduces the number of IP addresses that you must reserve in your network space for pods, but constrains what can connect to the nodes from outside the cluster (for example, on-premise nodes or those on another cloud provider). AWS Container Networking Interface (CNI) provides each pod with an IP address from the subnet, and can be accessed directly. The IP addresses must be unique across your network space, and must be planned in advance. Each node has a configuration parameter for the maximum number of pods that it supports. The equivalent number of IP addresses per node are then reserved up front for that node. This approach requires more planning, and can lead to IP address exhaustion as your application demands grow, however makes it easier for external nodes to connect to your cluster. Warning EKS clusters may not use 169.254.0.0/16, 172.30.0.0/16, 172.31.0.0/16, or 192.0.2.0/24 for the Kubernetes service address range. To provision the cluster: Update cluster.yml with your VPC details. Deploy the template: eksctl create cluster -f ./templates/cluster.yml Optionally, deploy the kubernetes dashboard . Provision the drivers. After the deployment completes, provision the secrets manager, identity, and CSI drivers. Use quorum for EKS_NAMESPACE and update AWS_REGION and EKS_CLUSTER_NAME in the commands below to match your settings from step 2. helm repo add secrets-store-csi-driver https://raw.githubusercontent.com/kubernetes-sigs/secrets-store-csi-driver/master/charts helm install --namespace quorum --create-namespace csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver kubectl apply --namespace quorum -f templates/secrets-manager/aws-provider-installer.yml POLICY_ARN = $( aws --region AWS_REGION --query Policy.Arn --output text iam create-policy --policy-name quorum-node-secrets-mgr-policy --policy-document '{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"secretsmanager:CreateSecret\",\"secretsmanager:UpdateSecret\",\"secretsmanager:DescribeSecret\",\"secretsmanager:GetSecretValue\",\"secretsmanager:PutSecretValue\",\"secretsmanager:ReplicateSecretToRegions\",\"secretsmanager:TagResource\"], \"Resource\": [\"arn:aws:secretsmanager:AWS_REGION:AWS_ACCOUNT:secret:goquorum-node-*\"] } ] }' ) eksctl create iamserviceaccount --name quorum-node-secrets-sa --namespace EKS_NAMESPACE --region = AWS_REGION --cluster EKS_CLUSTER_NAME --attach-policy-arn \" $POLICY_ARN \" --approve --override-existing-serviceaccounts You can now use your cluster and you can deploy Helm charts to it. Azure Kubernetes Service \u00b6 Azure Kubernetes Service (AKS) is also a popular cloud platform that you can use to deploy GoQuorum. To create a cluster in Azure, you must install the Azure CLI and have admin rights on your Azure subscription to enable some preview features on AKS. The template comprises the base infrastructure used to build the cluster and other resources in Azure. We also make use Azure native services and features after the cluster is created. These include: AAD pod identities . Secrets Store CSI drivers . Dynamic storage classes backed by Azure Files. The volume claims are fixed sizes and can be updated as you grow via helm updates, and won\u2019t need to re-provision the underlying storage class. CNI networking mode for AKS. By default, AKS clusters use kubenet , to create a virtual network and subnet. Nodes get an IP address from a virtual network subnet. Network address translation (NAT) is then configured on the nodes, and pods receive an IP address \u201chidden\u201d behind the node IP. Note This approach reduces the number of IP addresses you must reserve in your network space for pods to use, but constrains what can connect to the nodes from outside the cluster (for example, on-premise nodes or other cloud providers). AKS Container Networking Interface (CNI) provides each pod with an IP address from the subnet, and can be accessed directly. These IP addresses must be unique across your network space, and must be planned in advance. Each node has a configuration parameter for the maximum number of pods that it supports. The equivalent number of IP addresses per node are then reserved up front for that node. This approach requires more planning, and can leads to IP address exhaustion as your application demands grow, however makes it easier for external nodes to connect to your cluster. Warning Please do not create more than one AKS cluster in the same subnet. AKS clusters may not use 169.254.0.0/16 , 172.30.0.0/16 , 172.31.0.0/16 , or 192.0.2.0/24 for the Kubernetes service address range. To provision the cluster: Enable the preview features that allow you to use AKS with CNI, and a managed identity to authenticate and run cluster operations with other services. We also enable AAD pod identities which use the managed identity. This is in preview, so you must enable this feature by registering the EnablePodIdentityPreview feature: az feature register --name EnablePodIdentityPreview --namespace Microsoft.ContainerService This takes a little while and you can check on progress by running: az feature list --namespace Microsoft.ContainerService -o table Install or update your local Azure CLI with preview features: az extension add --name aks-preview az extension update --name aks-preview Create a resource group if you don\u2019t already have one: az group create --name QuorumGroup --location \"East US\" Deploy the template: Navigate to the Azure portal , select + Create a resource in the upper left corner. Search for Template deployment (deploy using custom templates) and select Create . Select Build your own template in the editor . Remove the contents (JSON) in the editor and paste in the contents of azuredeploy.json Select Save . Input provisioning parameters in the displayed user interface. Provision the drivers: Run the bootstrap script. Use quorum for AKS_NAMESPACE , and update AKS_RESOURCE_GROUP , AKS_CLUSTER_NAME , and AKS_MANAGED_IDENTITY in the commands below to match your settings and deployed resources from step 3. ./scripts/bootstrap.sh \"AKS_RESOURCE_GROUP\" \"AKS_CLUSTER_NAME\" \"AKS_MANAGED_IDENTITY\" \"AKS_NAMESPACE\" You can now use your cluster and you can deploy Helm charts to it.","title":"Create a cluster"},{"location":"tutorials/kubernetes/create-cluster/#create-a-cluster","text":"You can create a local or cloud cluster to deploy a GoQuorum network using Kubernetes.","title":"Create a cluster"},{"location":"tutorials/kubernetes/create-cluster/#prerequisites","text":"Clone the Quorum-Kubernetes repository Install Kubectl Install Helm3 Install AWS CLI and eksctl for AWS EKS clusters Install Azure CLI for Azure AKS clusters Install the cloud-specific CLI","title":"Prerequisites"},{"location":"tutorials/kubernetes/create-cluster/#local-clusters","text":"There are several options to create a local cluster. Select one listed below, or another that you\u2019re comfortable with.","title":"Local clusters"},{"location":"tutorials/kubernetes/create-cluster/#minikube","text":"Minikube is one of the most popular options to spin up a local Kubernetes cluster for development. You can install a version based on your architecture. Note We recommend at least 2 CPUs and 16GB of RAM. To start the cluster run the following command: minikube start --cpus 2 --memory 16384 --cni auto","title":"Minikube"},{"location":"tutorials/kubernetes/create-cluster/#kind","text":"kind (Kubernetes in Docker) is a lightweight tool for running local Kubernetes clusters. The installation is similar to Minikube . To start the cluster run the following command: kind create cluster","title":"kind"},{"location":"tutorials/kubernetes/create-cluster/#rancher","text":"Rancher is a lightweight open source desktop application for Mac, Windows, and Linux. It provides Kubernetes and container management, and allows you to choose the version of Kubernetes to run. It can build, push, pull and run container images. Built container images can be run without needing a registry. Note The official Docker-CLI is not supported but rather uses nerdctl which is a Docker-CLI compatible tool for containerd, and is automatically installed with Rancher Desktop. Note For Windows, you must install Windows Subsystem for Linux (WSL) to install Rancher Desktop. Refer to the official documentation for system requirements and installation instructions.","title":"Rancher"},{"location":"tutorials/kubernetes/create-cluster/#cloud-clusters","text":"","title":"Cloud clusters"},{"location":"tutorials/kubernetes/create-cluster/#aws-eks","text":"AWS Elastic Kubernetes Service (AWS EKS) is one of the most popular platforms to deploy GoQuorum. To create a cluster in AWS, you must install the AWS CLI and eksctl . The template comprises the base infrastructure used to build the cluster and other resources in AWS. We also use AWS native services and features after the cluster is created. These include: Pod identities . Secrets Store CSI drivers . Dynamic storage classes backed by AWS EBS. The volume claims are fixed sizes and can be updated as you grow via helm updates, and won\u2019t need to re-provision the underlying storage class. CNI networking mode for EKS. By default, EKS clusters use kubenet to create a virtual network and subnet. Nodes get an IP address from a virtual network subnet. Network address translation (NAT) is then configured on the nodes, and pods receive an IP address \u201chidden\u201d behind the node IP. Note This approach reduces the number of IP addresses that you must reserve in your network space for pods, but constrains what can connect to the nodes from outside the cluster (for example, on-premise nodes or those on another cloud provider). AWS Container Networking Interface (CNI) provides each pod with an IP address from the subnet, and can be accessed directly. The IP addresses must be unique across your network space, and must be planned in advance. Each node has a configuration parameter for the maximum number of pods that it supports. The equivalent number of IP addresses per node are then reserved up front for that node. This approach requires more planning, and can lead to IP address exhaustion as your application demands grow, however makes it easier for external nodes to connect to your cluster. Warning EKS clusters may not use 169.254.0.0/16, 172.30.0.0/16, 172.31.0.0/16, or 192.0.2.0/24 for the Kubernetes service address range. To provision the cluster: Update cluster.yml with your VPC details. Deploy the template: eksctl create cluster -f ./templates/cluster.yml Optionally, deploy the kubernetes dashboard . Provision the drivers. After the deployment completes, provision the secrets manager, identity, and CSI drivers. Use quorum for EKS_NAMESPACE and update AWS_REGION and EKS_CLUSTER_NAME in the commands below to match your settings from step 2. helm repo add secrets-store-csi-driver https://raw.githubusercontent.com/kubernetes-sigs/secrets-store-csi-driver/master/charts helm install --namespace quorum --create-namespace csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver kubectl apply --namespace quorum -f templates/secrets-manager/aws-provider-installer.yml POLICY_ARN = $( aws --region AWS_REGION --query Policy.Arn --output text iam create-policy --policy-name quorum-node-secrets-mgr-policy --policy-document '{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"secretsmanager:CreateSecret\",\"secretsmanager:UpdateSecret\",\"secretsmanager:DescribeSecret\",\"secretsmanager:GetSecretValue\",\"secretsmanager:PutSecretValue\",\"secretsmanager:ReplicateSecretToRegions\",\"secretsmanager:TagResource\"], \"Resource\": [\"arn:aws:secretsmanager:AWS_REGION:AWS_ACCOUNT:secret:goquorum-node-*\"] } ] }' ) eksctl create iamserviceaccount --name quorum-node-secrets-sa --namespace EKS_NAMESPACE --region = AWS_REGION --cluster EKS_CLUSTER_NAME --attach-policy-arn \" $POLICY_ARN \" --approve --override-existing-serviceaccounts You can now use your cluster and you can deploy Helm charts to it.","title":"AWS EKS"},{"location":"tutorials/kubernetes/create-cluster/#azure-kubernetes-service","text":"Azure Kubernetes Service (AKS) is also a popular cloud platform that you can use to deploy GoQuorum. To create a cluster in Azure, you must install the Azure CLI and have admin rights on your Azure subscription to enable some preview features on AKS. The template comprises the base infrastructure used to build the cluster and other resources in Azure. We also make use Azure native services and features after the cluster is created. These include: AAD pod identities . Secrets Store CSI drivers . Dynamic storage classes backed by Azure Files. The volume claims are fixed sizes and can be updated as you grow via helm updates, and won\u2019t need to re-provision the underlying storage class. CNI networking mode for AKS. By default, AKS clusters use kubenet , to create a virtual network and subnet. Nodes get an IP address from a virtual network subnet. Network address translation (NAT) is then configured on the nodes, and pods receive an IP address \u201chidden\u201d behind the node IP. Note This approach reduces the number of IP addresses you must reserve in your network space for pods to use, but constrains what can connect to the nodes from outside the cluster (for example, on-premise nodes or other cloud providers). AKS Container Networking Interface (CNI) provides each pod with an IP address from the subnet, and can be accessed directly. These IP addresses must be unique across your network space, and must be planned in advance. Each node has a configuration parameter for the maximum number of pods that it supports. The equivalent number of IP addresses per node are then reserved up front for that node. This approach requires more planning, and can leads to IP address exhaustion as your application demands grow, however makes it easier for external nodes to connect to your cluster. Warning Please do not create more than one AKS cluster in the same subnet. AKS clusters may not use 169.254.0.0/16 , 172.30.0.0/16 , 172.31.0.0/16 , or 192.0.2.0/24 for the Kubernetes service address range. To provision the cluster: Enable the preview features that allow you to use AKS with CNI, and a managed identity to authenticate and run cluster operations with other services. We also enable AAD pod identities which use the managed identity. This is in preview, so you must enable this feature by registering the EnablePodIdentityPreview feature: az feature register --name EnablePodIdentityPreview --namespace Microsoft.ContainerService This takes a little while and you can check on progress by running: az feature list --namespace Microsoft.ContainerService -o table Install or update your local Azure CLI with preview features: az extension add --name aks-preview az extension update --name aks-preview Create a resource group if you don\u2019t already have one: az group create --name QuorumGroup --location \"East US\" Deploy the template: Navigate to the Azure portal , select + Create a resource in the upper left corner. Search for Template deployment (deploy using custom templates) and select Create . Select Build your own template in the editor . Remove the contents (JSON) in the editor and paste in the contents of azuredeploy.json Select Save . Input provisioning parameters in the displayed user interface. Provision the drivers: Run the bootstrap script. Use quorum for AKS_NAMESPACE , and update AKS_RESOURCE_GROUP , AKS_CLUSTER_NAME , and AKS_MANAGED_IDENTITY in the commands below to match your settings and deployed resources from step 3. ./scripts/bootstrap.sh \"AKS_RESOURCE_GROUP\" \"AKS_CLUSTER_NAME\" \"AKS_MANAGED_IDENTITY\" \"AKS_NAMESPACE\" You can now use your cluster and you can deploy Helm charts to it.","title":"Azure Kubernetes Service"},{"location":"tutorials/kubernetes/deploy-charts/","text":"Prerequisites \u00b6 Clone the Quorum-Kubernetes repository A running Kubernetes cluster Kubectl Helm3 Provisioning with Helm charts \u00b6 Helm is a method of packaging a collection of objects into a chart which can then be deployed to the cluster. For the rest of this tutorial we use the Dev Helm charts. After you have cloned the Quorum-Kubernetes repository, change the directory to dev for the rest of this tutorial. cd dev/helm If you\u2019re running the cluster on AWS or Azure, please remember to update the values.yml with provider: aws or provider: azure as well. Note You can customize any of the charts in this repository to suit your requirements, and make pull requests to extend functionality. 1. Check that you can connect to the cluster with kubectl \u00b6 Verify kubectl is connected to cluster with: kubectl version Client Version: version.Info { Major: \"1\" , Minor: \"23\" , GitVersion: \"v1.23.1\" , GitCommit: \"86ec240af8cbd1b60bcc4c03c20da9b98005b92e\" , GitTreeState: \"clean\" , BuildDate: \"2021-12-16T11:41:01Z\" , GoVersion: \"go1.17.5\" , Compiler: \"gc\" , Platform: \"linux/amd64\" } Server Version: version.Info { Major: \"1\" , Minor: \"22\" , GitVersion: \"v1.22.3\" , GitCommit: \"c92036820499fedefec0f847e2054d824aea6cd1\" , GitTreeState: \"clean\" , BuildDate: \"2021-10-27T18:35:25Z\" , GoVersion: \"go1.16.9\" , Compiler: \"gc\" , Platform: \"linux/amd64\" } 2. Deploy the network \u00b6 This tutorial isolates groups of resources (for example, StatefulSets and Services) within a single cluster. Note The rest of this tutorial uses quorum as the namespace, but you\u2019re free to pick any name when deploying, as long as it\u2019s consistent across the infrastructure scripts and charts. Run the following in a terminal window: kubectl create namespace quorum 3. Deploy the monitoring chart \u00b6 This chart deploys Prometheus and Grafana to monitor the cluster, nodes, and state of the network. Each Besu pod has annotations which allow Prometheus to scrape metrics from the pod at a specified port and path. For example: template: metadata: annotations: prometheus.io/scrape: \"true\" prometheus.io/port: 9545 prometheus.io/path: \"/debug/metrics/prometheus\" Update the admin username and password in the monitoring values file . Configure alerts to the receiver of your choice (for example, email or Slack), then deploy the chart using: helm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm repo update helm install monitoring prometheus-community/kube-prometheus-stack --version 34 .6.0 --namespace = quorum --create-namespace --values ./values/monitoring.yml --wait kubectl --namespace quorum apply -f ./values/monitoring/ Warning For production use cases, configure Grafana with one of the supported native auth mechanisms . Once complete, you can view deployments in the Kubernetes dashboard (or equivalent). Optionally you can also deploy the Elastic Stack to view logs (and metrics). helm repo add elastic https://helm.elastic.co helm repo update helm install elasticsearch --version 7 .16.3 elastic/elasticsearch --namespace quorum --create-namespace --values ./values/elasticsearch.yml helm install kibana --version 7 .16.3 elastic/kibana --namespace quorum --values ./values/kibana.yml helm install filebeat elastic/filebeat --namespace quorum --values ./values/filebeat.yml # to get metrics, please install metricbeat with config that is similar to filebeat and once complete create a `metricbeat` index in kibana If you install filebeat , please create a filebeat-* index pattern in kibana . All the logs from the nodes are sent to the filebeat index. You can optionally deploy BlockScout to aid with monitoring the network. To do this, update the BlockScout values file and set the database and secret_key_base values. Important Changes to the database requires changes to both the database and the blockscout dictionaries. Once completed, deploy the chart using: helm dependency update ./charts/blockscout helm install blockscout ./charts/blockscout --namespace quorum --values ./values/blockscout-goquorum.yaml 4. Deploy the genesis chart \u00b6 The genesis chart creates the genesis file and keys for the validators and bootnodes. Warning It\u2019s important to keep the release names of the bootnodes and validators as per this tutorial, that is bootnode-n and validator-n (for the initial validator pool), where n is the node number. Any validators created after the initial pool can be named to anything you like. Update the number of validators, accounts, chain ID, and any parameters for the genesis file in the genesis-besu values file , then deploy the chart using: helm install genesis ./charts/goquorum-genesis --namespace quorum --create-namespace --values ./values/genesis-goquorum.yml Once completed, view the genesis and enodes (the list of static nodes) configuration maps that every GoQuorum node uses, and the validator and bootnode node keys as secrets. 5. Deploy the validators \u00b6 This is the first set of nodes that we will deploy. The Dev charts use four validators to replicate best practices on a production network. Each GoQourum node has a few flags that tell the StatefulSet what to deploy and how to clean up. The default values.yml for the StatefulSet define the following flags and this dictionary is present in all the override values files. nodeFlags: bootnode: false generateKeys: false privacy: false removeKeysOnDeletion: false We don\u2019t generate keys for only the initial validator pool; therefore, we set generateKeys to true for every node bar these. To create a Tessera pod paired to GoQuorum for private transactions, set the privacy flag to true . You can optionally remove the secrets for the node if you delete the StatefulSet (for example removing a member node) by setting the removeKeysOnDeletion flag to true . For the initial validator pool we set all the node flags to false and then deploy. Warning It\u2019s important to keep the release names of the validators the same as it is tied to the keys that the genesis chart creates. So we use validator-1 , validator-2 , etc. in the following command. helm install validator-1 ./charts/quorum-node --namespace quorum --values ./values/validator.yml helm install validator-2 ./charts/quorum-node --namespace quorum --values ./values/validator.yml helm install validator-3 ./charts/quorum-node --namespace quorum --values ./values/validator.yml helm install validator-4 ./charts/quorum-node --namespace quorum --values ./values/validator.yml Once complete, you may need to give the validators a few minutes to peer and for round changes, depending on when the first validator was spun up, before the logs display blocks being created. To add a validator into the network , deploy a normal RPC node (step 6) and then vote into the validator pool. 6. Deploy RPC or transaction nodes \u00b6 These nodes need their own node keys, so set the generateKeys flag to true for a standard RPC node. For a transaction node (GoQuorum paired with Tessera for private transactions), set the privacy flag to true and deploy in the same manner as before. For an RPC node with the release name rpc-1 : helm install rpc-1 ./charts/quorum-node --namespace quorum --values ./values/reader.yml For a transaction node release name tx-1 : helm install tx-1 ./charts/quorum-node --namespace quorum --values ./values/txnode.yml Logs for tx-1 resemble the following for Tessera: Logs for GoQuorum resemble the following: 7. Connecting to the node from your local machine via an Ingress \u00b6 In order to view the Grafana dashboards or connect to the nodes to make transactions from your local machine you can deploy an ingress controller with rules. We use the ingress-nginx ingress controller which can be deployed as follows: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx helm repo update helm install quorum-ingress ingress-nginx/ingress-nginx \\ --namespace quorum \\ --set controller.replicaCount = 1 \\ --set controller.nodeSelector. \"beta\\.kubernetes\\.io/os\" = linux \\ --set defaultBackend.nodeSelector. \"beta\\.kubernetes\\.io/os\" = linux \\ --set controller.admissionWebhooks.patch.nodeSelector. \"beta\\.kubernetes\\.io/os\" = linux \\ --set controller.service.externalTrafficPolicy = Local Use pre-defined rules to test functionality, and alter to suit your requirements (for example, to connect to multiple nodes via different paths). Edit the rules file so the service names match your release name. In the example, we deployed a transaction node with the release name member-1 so the corresponding service is called quorum-node-member-1 for the rpc and ws path prefixes. Once you have settings that match your deployments, deploy the rules like so: kubectl apply -f ../../ingress/ingress-rules-quorum.yml Once complete, view the IP address listed under the Ingress section if you\u2019re using the Kubernetes Dashboard or equivalent kubectl command. You can view the Grafana dashboard by going to: # For Grafana's grafana address: http://<INGRESS_IP>/d/a1lVy7ycin9Yv/goquorum-overview?orgId = 1 & refresh = 10s The following is an example RPC call, which confirms that the node running the JSON-RPC service is syncing: curl HTTP request curl -v -X POST -H \"Content-Type: application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' http://<INGRESS_IP>/rpc JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x4e9\" }","title":"Deploy charts"},{"location":"tutorials/kubernetes/deploy-charts/#prerequisites","text":"Clone the Quorum-Kubernetes repository A running Kubernetes cluster Kubectl Helm3","title":"Prerequisites"},{"location":"tutorials/kubernetes/deploy-charts/#provisioning-with-helm-charts","text":"Helm is a method of packaging a collection of objects into a chart which can then be deployed to the cluster. For the rest of this tutorial we use the Dev Helm charts. After you have cloned the Quorum-Kubernetes repository, change the directory to dev for the rest of this tutorial. cd dev/helm If you\u2019re running the cluster on AWS or Azure, please remember to update the values.yml with provider: aws or provider: azure as well. Note You can customize any of the charts in this repository to suit your requirements, and make pull requests to extend functionality.","title":"Provisioning with Helm charts"},{"location":"tutorials/kubernetes/deploy-charts/#1-check-that-you-can-connect-to-the-cluster-with-kubectl","text":"Verify kubectl is connected to cluster with: kubectl version Client Version: version.Info { Major: \"1\" , Minor: \"23\" , GitVersion: \"v1.23.1\" , GitCommit: \"86ec240af8cbd1b60bcc4c03c20da9b98005b92e\" , GitTreeState: \"clean\" , BuildDate: \"2021-12-16T11:41:01Z\" , GoVersion: \"go1.17.5\" , Compiler: \"gc\" , Platform: \"linux/amd64\" } Server Version: version.Info { Major: \"1\" , Minor: \"22\" , GitVersion: \"v1.22.3\" , GitCommit: \"c92036820499fedefec0f847e2054d824aea6cd1\" , GitTreeState: \"clean\" , BuildDate: \"2021-10-27T18:35:25Z\" , GoVersion: \"go1.16.9\" , Compiler: \"gc\" , Platform: \"linux/amd64\" }","title":"1. Check that you can connect to the cluster with kubectl"},{"location":"tutorials/kubernetes/deploy-charts/#2-deploy-the-network","text":"This tutorial isolates groups of resources (for example, StatefulSets and Services) within a single cluster. Note The rest of this tutorial uses quorum as the namespace, but you\u2019re free to pick any name when deploying, as long as it\u2019s consistent across the infrastructure scripts and charts. Run the following in a terminal window: kubectl create namespace quorum","title":"2. Deploy the network"},{"location":"tutorials/kubernetes/deploy-charts/#3-deploy-the-monitoring-chart","text":"This chart deploys Prometheus and Grafana to monitor the cluster, nodes, and state of the network. Each Besu pod has annotations which allow Prometheus to scrape metrics from the pod at a specified port and path. For example: template: metadata: annotations: prometheus.io/scrape: \"true\" prometheus.io/port: 9545 prometheus.io/path: \"/debug/metrics/prometheus\" Update the admin username and password in the monitoring values file . Configure alerts to the receiver of your choice (for example, email or Slack), then deploy the chart using: helm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm repo update helm install monitoring prometheus-community/kube-prometheus-stack --version 34 .6.0 --namespace = quorum --create-namespace --values ./values/monitoring.yml --wait kubectl --namespace quorum apply -f ./values/monitoring/ Warning For production use cases, configure Grafana with one of the supported native auth mechanisms . Once complete, you can view deployments in the Kubernetes dashboard (or equivalent). Optionally you can also deploy the Elastic Stack to view logs (and metrics). helm repo add elastic https://helm.elastic.co helm repo update helm install elasticsearch --version 7 .16.3 elastic/elasticsearch --namespace quorum --create-namespace --values ./values/elasticsearch.yml helm install kibana --version 7 .16.3 elastic/kibana --namespace quorum --values ./values/kibana.yml helm install filebeat elastic/filebeat --namespace quorum --values ./values/filebeat.yml # to get metrics, please install metricbeat with config that is similar to filebeat and once complete create a `metricbeat` index in kibana If you install filebeat , please create a filebeat-* index pattern in kibana . All the logs from the nodes are sent to the filebeat index. You can optionally deploy BlockScout to aid with monitoring the network. To do this, update the BlockScout values file and set the database and secret_key_base values. Important Changes to the database requires changes to both the database and the blockscout dictionaries. Once completed, deploy the chart using: helm dependency update ./charts/blockscout helm install blockscout ./charts/blockscout --namespace quorum --values ./values/blockscout-goquorum.yaml","title":"3. Deploy the monitoring chart"},{"location":"tutorials/kubernetes/deploy-charts/#4-deploy-the-genesis-chart","text":"The genesis chart creates the genesis file and keys for the validators and bootnodes. Warning It\u2019s important to keep the release names of the bootnodes and validators as per this tutorial, that is bootnode-n and validator-n (for the initial validator pool), where n is the node number. Any validators created after the initial pool can be named to anything you like. Update the number of validators, accounts, chain ID, and any parameters for the genesis file in the genesis-besu values file , then deploy the chart using: helm install genesis ./charts/goquorum-genesis --namespace quorum --create-namespace --values ./values/genesis-goquorum.yml Once completed, view the genesis and enodes (the list of static nodes) configuration maps that every GoQuorum node uses, and the validator and bootnode node keys as secrets.","title":"4. Deploy the genesis chart"},{"location":"tutorials/kubernetes/deploy-charts/#5-deploy-the-validators","text":"This is the first set of nodes that we will deploy. The Dev charts use four validators to replicate best practices on a production network. Each GoQourum node has a few flags that tell the StatefulSet what to deploy and how to clean up. The default values.yml for the StatefulSet define the following flags and this dictionary is present in all the override values files. nodeFlags: bootnode: false generateKeys: false privacy: false removeKeysOnDeletion: false We don\u2019t generate keys for only the initial validator pool; therefore, we set generateKeys to true for every node bar these. To create a Tessera pod paired to GoQuorum for private transactions, set the privacy flag to true . You can optionally remove the secrets for the node if you delete the StatefulSet (for example removing a member node) by setting the removeKeysOnDeletion flag to true . For the initial validator pool we set all the node flags to false and then deploy. Warning It\u2019s important to keep the release names of the validators the same as it is tied to the keys that the genesis chart creates. So we use validator-1 , validator-2 , etc. in the following command. helm install validator-1 ./charts/quorum-node --namespace quorum --values ./values/validator.yml helm install validator-2 ./charts/quorum-node --namespace quorum --values ./values/validator.yml helm install validator-3 ./charts/quorum-node --namespace quorum --values ./values/validator.yml helm install validator-4 ./charts/quorum-node --namespace quorum --values ./values/validator.yml Once complete, you may need to give the validators a few minutes to peer and for round changes, depending on when the first validator was spun up, before the logs display blocks being created. To add a validator into the network , deploy a normal RPC node (step 6) and then vote into the validator pool.","title":"5. Deploy the validators"},{"location":"tutorials/kubernetes/deploy-charts/#6-deploy-rpc-or-transaction-nodes","text":"These nodes need their own node keys, so set the generateKeys flag to true for a standard RPC node. For a transaction node (GoQuorum paired with Tessera for private transactions), set the privacy flag to true and deploy in the same manner as before. For an RPC node with the release name rpc-1 : helm install rpc-1 ./charts/quorum-node --namespace quorum --values ./values/reader.yml For a transaction node release name tx-1 : helm install tx-1 ./charts/quorum-node --namespace quorum --values ./values/txnode.yml Logs for tx-1 resemble the following for Tessera: Logs for GoQuorum resemble the following:","title":"6. Deploy RPC or transaction nodes"},{"location":"tutorials/kubernetes/deploy-charts/#7-connecting-to-the-node-from-your-local-machine-via-an-ingress","text":"In order to view the Grafana dashboards or connect to the nodes to make transactions from your local machine you can deploy an ingress controller with rules. We use the ingress-nginx ingress controller which can be deployed as follows: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx helm repo update helm install quorum-ingress ingress-nginx/ingress-nginx \\ --namespace quorum \\ --set controller.replicaCount = 1 \\ --set controller.nodeSelector. \"beta\\.kubernetes\\.io/os\" = linux \\ --set defaultBackend.nodeSelector. \"beta\\.kubernetes\\.io/os\" = linux \\ --set controller.admissionWebhooks.patch.nodeSelector. \"beta\\.kubernetes\\.io/os\" = linux \\ --set controller.service.externalTrafficPolicy = Local Use pre-defined rules to test functionality, and alter to suit your requirements (for example, to connect to multiple nodes via different paths). Edit the rules file so the service names match your release name. In the example, we deployed a transaction node with the release name member-1 so the corresponding service is called quorum-node-member-1 for the rpc and ws path prefixes. Once you have settings that match your deployments, deploy the rules like so: kubectl apply -f ../../ingress/ingress-rules-quorum.yml Once complete, view the IP address listed under the Ingress section if you\u2019re using the Kubernetes Dashboard or equivalent kubectl command. You can view the Grafana dashboard by going to: # For Grafana's grafana address: http://<INGRESS_IP>/d/a1lVy7ycin9Yv/goquorum-overview?orgId = 1 & refresh = 10s The following is an example RPC call, which confirms that the node running the JSON-RPC service is syncing: curl HTTP request curl -v -X POST -H \"Content-Type: application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' http://<INGRESS_IP>/rpc JSON result { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x4e9\" }","title":"7. Connecting to the node from your local machine via an Ingress"},{"location":"tutorials/kubernetes/maintenance/","text":"Prerequisites \u00b6 Clone the Quorum-Kubernetes repository A running Kubernetes cluster with a network Kubectl Helm3 Updating a persistent volume claim size \u00b6 Over time, as the chain grows so will the amount of space used by the persistent volume claim (PVC). As of Kubernetes v1.11, certain types of Storage Classes allow volume resizing. Production charts for Azure use Azure Files and on AWS use EBS Block Store which allow for volume expansion. To update the volume size, you must update the override values file. For example, to increase the size on the transaction nodes volumes, add the following snippet to the txnode values.yml file, with the new size limit (the following example uses 50Gi). storage: sizeLimit: \"50Gi\" pvcSizeLimit: \"50Gi\" Once complete, update the node via helm: helm upgrade tx-1 ./charts/goquorum-node --namespace goquorum --values ./values/txnode.yml Updating GoQuorum versions \u00b6 Important When updating GoQuorum nodes across a cluster, perform the updatesas a rolling update and not all at once, especially for the validator pool. If all the validators are taken offline, the chain halts, and you must wait for round changes to expire before blocks are created again. Updates for GoQuorum can be done via Helm in exactly the same manner as other applications. Alternatively, this can be done via kubectl . This example updates a node called goquorum-validator-3 : Set the update policy to use rolling updates (if not done already): kubectl patch statefulset goquorum-validator-3 --namespace goquorum -p '{\"spec\":{\"updateStrategy\":{\"type\":\"RollingUpdate\"}}}' Update the GoQuorum version via Helm: helm upgrade validator-3 ./charts/goquorum-node --namespace goquorum --values ./values/validator.yml --set image.goquorum.tag = 21 .10.0 Or via kubectl : kubectl patch statefulset goquorum-validator-3 --namespace goquorum --type = 'json' -p = '[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/image\", \"value\":\"quorumengineering/goquorum:21.10.0\"}]'","title":"Maintenance"},{"location":"tutorials/kubernetes/maintenance/#prerequisites","text":"Clone the Quorum-Kubernetes repository A running Kubernetes cluster with a network Kubectl Helm3","title":"Prerequisites"},{"location":"tutorials/kubernetes/maintenance/#updating-a-persistent-volume-claim-size","text":"Over time, as the chain grows so will the amount of space used by the persistent volume claim (PVC). As of Kubernetes v1.11, certain types of Storage Classes allow volume resizing. Production charts for Azure use Azure Files and on AWS use EBS Block Store which allow for volume expansion. To update the volume size, you must update the override values file. For example, to increase the size on the transaction nodes volumes, add the following snippet to the txnode values.yml file, with the new size limit (the following example uses 50Gi). storage: sizeLimit: \"50Gi\" pvcSizeLimit: \"50Gi\" Once complete, update the node via helm: helm upgrade tx-1 ./charts/goquorum-node --namespace goquorum --values ./values/txnode.yml","title":"Updating a persistent volume claim size"},{"location":"tutorials/kubernetes/maintenance/#updating-goquorum-versions","text":"Important When updating GoQuorum nodes across a cluster, perform the updatesas a rolling update and not all at once, especially for the validator pool. If all the validators are taken offline, the chain halts, and you must wait for round changes to expire before blocks are created again. Updates for GoQuorum can be done via Helm in exactly the same manner as other applications. Alternatively, this can be done via kubectl . This example updates a node called goquorum-validator-3 : Set the update policy to use rolling updates (if not done already): kubectl patch statefulset goquorum-validator-3 --namespace goquorum -p '{\"spec\":{\"updateStrategy\":{\"type\":\"RollingUpdate\"}}}' Update the GoQuorum version via Helm: helm upgrade validator-3 ./charts/goquorum-node --namespace goquorum --values ./values/validator.yml --set image.goquorum.tag = 21 .10.0 Or via kubectl : kubectl patch statefulset goquorum-validator-3 --namespace goquorum --type = 'json' -p = '[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/image\", \"value\":\"quorumengineering/goquorum:21.10.0\"}]'","title":"Updating GoQuorum versions"},{"location":"tutorials/kubernetes/playground/","text":"Deploy GoQuorum with Kubernetes in a Local Environment \u00b6 The playground was created to provide an opportunity to deploy quorum-kubernetes in a local environment before attempting in a live environment (such as in the cloud or on-premise). Local deployment can be done with any local Kubernetes tool. Minikube and Rancher Desktop have been tested to work, but any complete Kubernetes solution with support for kubectl should suffice. How to deploy locally \u00b6 Navigate to the playground README . Ensure that your system meets the requirements specified. Choose your Ethereum client (Hyperledger Besu or GoQuorum): quorum-besu or quorum-go . Choose your consensus algorithm. The playground supports Clique, Ethash (PoW), and IBFT2 for Besu, and IBFT for GoQuorum. Follow the instructions from the README for the chosen client and consensus algorithm folder. Important notes \u00b6 Consider the following when deploying and developing with the playground: The playground is created specifically for developers and operators to become familiar with the deployment of GoQuorum in a Kubernetes environment in preparation for going into a cloud or on-premise environment. Thus, it should not be deployed into a production environment. The playground is not a complete reflection of the dev and prod charts as it does not use Helm , but rather static or non-templated code that is deployed through kubectl apply -f . This means that without Helm there\u2019s a significant amount of repeated code. This is fine for development but not ideal for a production environment. The playground uses static/hard-coded keys. Automatic key generation is only supported in dev and prod charts. As the playground is for local development, no cloud integration or lifecycle support is offered.","title":"Local playground"},{"location":"tutorials/kubernetes/playground/#deploy-goquorum-with-kubernetes-in-a-local-environment","text":"The playground was created to provide an opportunity to deploy quorum-kubernetes in a local environment before attempting in a live environment (such as in the cloud or on-premise). Local deployment can be done with any local Kubernetes tool. Minikube and Rancher Desktop have been tested to work, but any complete Kubernetes solution with support for kubectl should suffice.","title":"Deploy GoQuorum with Kubernetes in a Local Environment"},{"location":"tutorials/kubernetes/playground/#how-to-deploy-locally","text":"Navigate to the playground README . Ensure that your system meets the requirements specified. Choose your Ethereum client (Hyperledger Besu or GoQuorum): quorum-besu or quorum-go . Choose your consensus algorithm. The playground supports Clique, Ethash (PoW), and IBFT2 for Besu, and IBFT for GoQuorum. Follow the instructions from the README for the chosen client and consensus algorithm folder.","title":"How to deploy locally"},{"location":"tutorials/kubernetes/playground/#important-notes","text":"Consider the following when deploying and developing with the playground: The playground is created specifically for developers and operators to become familiar with the deployment of GoQuorum in a Kubernetes environment in preparation for going into a cloud or on-premise environment. Thus, it should not be deployed into a production environment. The playground is not a complete reflection of the dev and prod charts as it does not use Helm , but rather static or non-templated code that is deployed through kubectl apply -f . This means that without Helm there\u2019s a significant amount of repeated code. This is fine for development but not ideal for a production environment. The playground uses static/hard-coded keys. Automatic key generation is only supported in dev and prod charts. As the playground is for local development, no cloud integration or lifecycle support is offered.","title":"Important notes"},{"location":"tutorials/kubernetes/production/","text":"Prerequisites \u00b6 Clone the Quorum-Kubernetes repository A running Kubernetes cluster Kubectl Helm3 Overview \u00b6 The charts in the prod folder are similar to those in the dev folder but use cloud native services for identities (IAM on AWS and a Managed Identity on Azure) and secrets (Secrets Manager on AWS and Key Vault on Azure). Any keys or secrets are created directly in Secrets Manager or Key Vault, and the Identity is given permission to retrieve those secrets at runtime. No Kubernetes secrets objects are created. Access to these secrets are done on the least privileges policy and access to them is denied for users. If any admins need access to them, they must update the IAM policy. Warning The following tutorial ONLY supports AWS and Azure currently. Other cloud providers will be added in time. Warning We recommend using AWS RDS or Azure PostgreSQL in High Availability mode for any Tessera nodes that you use. The templates don\u2019t include that functionality. They can be provisioned with CloudFormation or Azure Resource Manager, respectively. Once created, please specify the connection details to the values.yml . Deploy \u00b6 Check that you can connect to the cluster with kubectl \u00b6 Once you have a cluster running , verify kubectl is connected to cluster with: kubectl version Client Version: version.Info { Major: \"1\" , Minor: \"23\" , GitVersion: \"v1.23.1\" , GitCommit: \"86ec240af8cbd1b60bcc4c03c20da9b98005b92e\" , GitTreeState: \"clean\" , BuildDate: \"2021-12-16T11:41:01Z\" , GoVersion: \"go1.17.5\" , Compiler: \"gc\" , Platform: \"linux/amd64\" } Server Version: version.Info { Major: \"1\" , Minor: \"22\" , GitVersion: \"v1.22.3\" , GitCommit: \"c92036820499fedefec0f847e2054d824aea6cd1\" , GitTreeState: \"clean\" , BuildDate: \"2021-10-27T18:35:25Z\" , GoVersion: \"go1.16.9\" , Compiler: \"gc\" , Platform: \"linux/amd64\" } Deploy the network \u00b6 For the rest of this tutorial we use the Prod Helm charts. After you have cloned the Quorum-Kubernetes repository, change the directory to prod for the rest of this tutorial. cd prod/helm Attention Please update all the values files with your choice of cloud provider (AWS or Azure) and set provider: aws or provider: azure as required. Depending on the provider, you may also need to update the azure: or aws: dictionaries with specifics of your cluster and account. Follow the steps outlined in the deploy charts tutorial to deploy the network. Best practices \u00b6 The most important thing is to plan your network out on paper first and then test it in a Dev cluster to make sure connectivity works with your applications and you get the required throughput in transactions per second (TPS). We also recommend you test the entire process, from provisioning infrastructure to updating nodes on a Dev cluster, prior to launching your production network. By default, the cloud Kubernetes clusters should take care of availability and do multi-zones within a region. The scheduler also ensures that deployments are spread out across zones. Where possible, we recommend you use multiple bootnodes and static nodes to speed up peering. Connecting to APIs and services outside the cluster should work as normal, but connecting into your network (such as adding an on-premise node to the network) may require more configuration. Please check the limitations and use CNI where possible. To connect an external node to your cluster, the easiest way is to use a VPN as seen in the following multi-cluster setup. Finally, we recommend setting up monitoring and alerting from the beginning so you can get early warnings of issues rather than after failure. We have a monitoring chart which uses Grafana and you can use it in conjunction with Alertmanager to create alerts or alternatively alert via Cloudwatch or Azure Monitoring. Multi-cluster support \u00b6 When CNI is used, multi-cluster support is simple, but you have to cater for cross-cluster DNS names. Ideally, you want to create two separate VPCs (or VNets) and make sure they have different base CIDR blocks so that IPs don\u2019t conflict. Once done, peer the VPCs together and update the subnet route table, so they are effectively a giant single network. When you spin up clusters , use CNI and CIDR blocks to match the subnet\u2019s CIDR settings. Then deploy the genesis chart on one cluster and copy across the genesis file and static nodes config maps. Depending on your DNS settings, they might be fine as is or they might need to be actual IPs. That is, you can provision cluster B only after cluster A has GoQuorum nodes up and running. Deploy the network on cluster A, and then on cluster B. GoQuorum nodes on cluster A should work as expected, and GoQuorum nodes on cluster B should use the list of peers provided to communicate with the nodes on cluster A. Keeping the list of peers on the clusters live and up to date can be challenging, so we recommend using the cloud service provider\u2019s DNS service such as Route 53 or Azure DNS and adapting the charts to create entries for each node when it comes up.","title":"Production"},{"location":"tutorials/kubernetes/production/#prerequisites","text":"Clone the Quorum-Kubernetes repository A running Kubernetes cluster Kubectl Helm3","title":"Prerequisites"},{"location":"tutorials/kubernetes/production/#overview","text":"The charts in the prod folder are similar to those in the dev folder but use cloud native services for identities (IAM on AWS and a Managed Identity on Azure) and secrets (Secrets Manager on AWS and Key Vault on Azure). Any keys or secrets are created directly in Secrets Manager or Key Vault, and the Identity is given permission to retrieve those secrets at runtime. No Kubernetes secrets objects are created. Access to these secrets are done on the least privileges policy and access to them is denied for users. If any admins need access to them, they must update the IAM policy. Warning The following tutorial ONLY supports AWS and Azure currently. Other cloud providers will be added in time. Warning We recommend using AWS RDS or Azure PostgreSQL in High Availability mode for any Tessera nodes that you use. The templates don\u2019t include that functionality. They can be provisioned with CloudFormation or Azure Resource Manager, respectively. Once created, please specify the connection details to the values.yml .","title":"Overview"},{"location":"tutorials/kubernetes/production/#deploy","text":"","title":"Deploy"},{"location":"tutorials/kubernetes/production/#check-that-you-can-connect-to-the-cluster-with-kubectl","text":"Once you have a cluster running , verify kubectl is connected to cluster with: kubectl version Client Version: version.Info { Major: \"1\" , Minor: \"23\" , GitVersion: \"v1.23.1\" , GitCommit: \"86ec240af8cbd1b60bcc4c03c20da9b98005b92e\" , GitTreeState: \"clean\" , BuildDate: \"2021-12-16T11:41:01Z\" , GoVersion: \"go1.17.5\" , Compiler: \"gc\" , Platform: \"linux/amd64\" } Server Version: version.Info { Major: \"1\" , Minor: \"22\" , GitVersion: \"v1.22.3\" , GitCommit: \"c92036820499fedefec0f847e2054d824aea6cd1\" , GitTreeState: \"clean\" , BuildDate: \"2021-10-27T18:35:25Z\" , GoVersion: \"go1.16.9\" , Compiler: \"gc\" , Platform: \"linux/amd64\" }","title":"Check that you can connect to the cluster with kubectl"},{"location":"tutorials/kubernetes/production/#deploy-the-network","text":"For the rest of this tutorial we use the Prod Helm charts. After you have cloned the Quorum-Kubernetes repository, change the directory to prod for the rest of this tutorial. cd prod/helm Attention Please update all the values files with your choice of cloud provider (AWS or Azure) and set provider: aws or provider: azure as required. Depending on the provider, you may also need to update the azure: or aws: dictionaries with specifics of your cluster and account. Follow the steps outlined in the deploy charts tutorial to deploy the network.","title":"Deploy the network"},{"location":"tutorials/kubernetes/production/#best-practices","text":"The most important thing is to plan your network out on paper first and then test it in a Dev cluster to make sure connectivity works with your applications and you get the required throughput in transactions per second (TPS). We also recommend you test the entire process, from provisioning infrastructure to updating nodes on a Dev cluster, prior to launching your production network. By default, the cloud Kubernetes clusters should take care of availability and do multi-zones within a region. The scheduler also ensures that deployments are spread out across zones. Where possible, we recommend you use multiple bootnodes and static nodes to speed up peering. Connecting to APIs and services outside the cluster should work as normal, but connecting into your network (such as adding an on-premise node to the network) may require more configuration. Please check the limitations and use CNI where possible. To connect an external node to your cluster, the easiest way is to use a VPN as seen in the following multi-cluster setup. Finally, we recommend setting up monitoring and alerting from the beginning so you can get early warnings of issues rather than after failure. We have a monitoring chart which uses Grafana and you can use it in conjunction with Alertmanager to create alerts or alternatively alert via Cloudwatch or Azure Monitoring.","title":"Best practices"},{"location":"tutorials/kubernetes/production/#multi-cluster-support","text":"When CNI is used, multi-cluster support is simple, but you have to cater for cross-cluster DNS names. Ideally, you want to create two separate VPCs (or VNets) and make sure they have different base CIDR blocks so that IPs don\u2019t conflict. Once done, peer the VPCs together and update the subnet route table, so they are effectively a giant single network. When you spin up clusters , use CNI and CIDR blocks to match the subnet\u2019s CIDR settings. Then deploy the genesis chart on one cluster and copy across the genesis file and static nodes config maps. Depending on your DNS settings, they might be fine as is or they might need to be actual IPs. That is, you can provision cluster B only after cluster A has GoQuorum nodes up and running. Deploy the network on cluster A, and then on cluster B. GoQuorum nodes on cluster A should work as expected, and GoQuorum nodes on cluster B should use the list of peers provided to communicate with the nodes on cluster A. Keeping the list of peers on the clusters live and up to date can be challenging, so we recommend using the cloud service provider\u2019s DNS service such as Route 53 or Azure DNS and adapting the charts to create entries for each node when it comes up.","title":"Multi-cluster support"},{"location":"tutorials/private-network/adding-removing-ibft-validators/","text":"Add and remove IBFT validators \u00b6 Prerequisites \u00b6 An IBFT network as configured in the IBFT tutorial . Add a validator \u00b6 Create a working directory for the new node that needs to be added: mkdir node5 Change into the working directory for the new node 5 and run istanbul setup : cd node5 ../istanbul-tools/build/bin/istanbul setup --num 1 --verbose --quorum --save This will generate the validator details including Address , NodeInfo and genesis.json . Example files valida t ors { \"Address\" : \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"Nodekey\" : \"25b47a49ef08f888c04f30417363e6c6bc33e739147b2f8b5377b3168f9f7435\" , \"NodeInfo\" : \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@0.0.0.0:30303?discport=0\" } ge nes is.jso n { \"config\" : { \"chainId\" : 10 , \"eip150Block\" : 1 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 1 , \"eip158Block\" : 1 , \"byzantiumBlock\" : 1 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 }, \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5cffc942\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000f85ad5942aabbc1bb9bacef60a09764d1a1f4f04a47885c1b8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\" , \"gasLimit\" : \"0xe0000000\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : { \"2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" : { \"balance\" : \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } Copy the address of the validator and propose it from more than half the number of current validators. Attach a geth console to the node: geth attach cd .. geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0x4c1ccd426833b9782729a212c857f2f03b7b4c0d at block: 137 (Tue, 11 Jun 2019 16:32:47 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Check existing validators: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] Propose the new validator using the command istanbul.propose(<address>, true) with <address> replaced by the new validator candidate node address: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , true ) JSON result null Exit the console: exit Repeat the proposal process for this candidate node by connecting your geth console to node 1, node 2, and node 3. Note To drop a currently running validator candidate and stop further votes from being cast either for or against it, use istanbul.discard . Verify that the new validator is now in the list of validators by running istanbul.getValidators in a geth console attached to any of your nodes: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The list of validators contains six addresses now. Copy static-nodes.json and genesis.json from the existing chain, placing static-nodes.json into the new node\u2019s data directory: cd node5 mkdir -p data/geth cp ../node0/static-nodes.json data cp ../node0/genesis.json . Edit static-nodes.json and add the new validator\u2019s node info to the end of the file. The new validator\u2019s node info can be retrieved from the output of istanbul setup --num 1 --verbose --quorum --save in step 2. Update the IP address and port of the node info to match the IP address of the validator and port you want to use. [ \"enode://dd333ec28f0a8910c92eb4d336461eea1c20803eed9cf2c056557f986e720f8e693605bba2f4e8f289b1162e5ac7c80c914c7178130711e393ca76abc1d92f57@127.0.0.1:30300?discport=0\" , \"enode://1bb6be462f27e56f901c3fcb2d53a9273565f48e5d354c08f0c044405b29291b405b9f5aa027f3a75f9b058cb43e2f54719f15316979a0e5a2b760fff4631998@127.0.0.1:30301?discport=0\" , \"enode://0df02e94a3befc0683780d898119d3b675e5942c1a2f9ad47d35b4e6ccaf395cd71ec089fcf1d616748bf9871f91e5e3d29c1cf6f8f81de1b279082a104f619d@127.0.0.1:30302?discport=0\" , \"enode://3fe0ff0dd2730eaac7b6b379bdb51215b5831f4f48fa54a24a0298ad5ba8c2a332442948d53f4cd4fd28f373089a35e806ef722eb045659910f96a1278120516@127.0.0.1:30303?discport=0\" , \"enode://e53e92e5a51ac2685b0406d0d3c62288b53831c3b0f492b9dc4bc40334783702cfa74c49b836efa2761edde33a3282704273b2453537b855e7a4aeadcccdb43e@127.0.0.1:30304?discport=0\" , \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@127.0.0.1:30305?discport=0\" ] Copy the node key that was generated by the istanbul setup command to the geth directory inside the working directory: cp 0 /nodekey data/geth Initialize the new node with the following command: geth command geth --datadir data init genesis.json Result INFO [06-11|16:42:27.120] Maximum peer count ETH=25 LES=0 total=25 INFO [06-11|16:42:27.130] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/chaindata cache=16 handles=16 INFO [06-11|16:42:27.138] Writing custom genesis block INFO [06-11|16:42:27.138] Persisted trie from memory database nodes=6 size=1.01kB time=163.024\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.139] Successfully wrote genesis state database=chaindata hash=b992be\u2026533db7 INFO [06-11|16:42:27.139] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/lightchaindata cache=16 handles=16 INFO [06-11|16:42:27.141] Writing custom genesis block INFO [06-11|16:42:27.142] Persisted trie from memory database nodes=6 size=1.01kB time=94.57\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.142] Successfully wrote genesis state database=lightchaindata hash=b992be\u2026533db7 Copy startall.sh to a new start5.sh and execute it to start the node: cd .. cp startall.sh start5.sh Edit start5.sh with the following: #!/bin/bash cd node5 PRIVATE_CONFIG = ignore nohup geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0 .0.0.0 --http.port 22005 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30305 2 >>node.log & Important Update IP and port number matching for this node decided on step 6. Run node 5: ./start5.sh Check that the node is started: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.93 -bash 36432 ttys002 0:24.48 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:23.36 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:24.32 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:24.21 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:24.17 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:00.15 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.04 -bash 36467 ttys003 0:00.32 geth attach node3/data/geth.ipc Remove a validator \u00b6 Attach a geth console to a running validator, run istanbul.getValidators , and identify the address of the validator that needs to be removed: geth attach geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0xc1056df7c02b6f1a353052eaf0533cc7cb743b52 at block: 181 (Tue, 11 Jun 2019 16:36:27 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Run istanbul.getValidators : geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] We will remove 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 from the validator list in this tutorial. Run istanbul.propose(<address>, false) by passing the address of the validator that needs to be removed from more than half of the current validators: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , false ) JSON result null Repeat istanbul.propose(\"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\",false) for node 1, node 2, and node 3. Verify that the validator has been removed by running istanbul.getValidators in one of the nodes\u2019 attached geth console: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The validator 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 was removed and the validators list now only has five addresses. Stop the geth process corresponding to the validator that was removed: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.94 -bash 36432 ttys002 0:31.93 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:30.75 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:31.72 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:31.65 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:31.63 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:06.86 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.05 -bash 36493 ttys003 0:00.22 geth attach node4/data/geth.ipc Kill the geth process that uses port 22005 , corresponding to node 5 as indicated in start5.sh : kill 36485 Add a non-validator node \u00b6 Same instructions as adding a validator excluding step 3, which proposes the node as validator. Remove a non-validator node \u00b6 Just execute step 4 from removing a validator .","title":"Add and remove IBFT validators"},{"location":"tutorials/private-network/adding-removing-ibft-validators/#add-and-remove-ibft-validators","text":"","title":"Add and remove IBFT validators"},{"location":"tutorials/private-network/adding-removing-ibft-validators/#prerequisites","text":"An IBFT network as configured in the IBFT tutorial .","title":"Prerequisites"},{"location":"tutorials/private-network/adding-removing-ibft-validators/#add-a-validator","text":"Create a working directory for the new node that needs to be added: mkdir node5 Change into the working directory for the new node 5 and run istanbul setup : cd node5 ../istanbul-tools/build/bin/istanbul setup --num 1 --verbose --quorum --save This will generate the validator details including Address , NodeInfo and genesis.json . Example files valida t ors { \"Address\" : \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"Nodekey\" : \"25b47a49ef08f888c04f30417363e6c6bc33e739147b2f8b5377b3168f9f7435\" , \"NodeInfo\" : \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@0.0.0.0:30303?discport=0\" } ge nes is.jso n { \"config\" : { \"chainId\" : 10 , \"eip150Block\" : 1 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 1 , \"eip158Block\" : 1 , \"byzantiumBlock\" : 1 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 }, \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5cffc942\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000f85ad5942aabbc1bb9bacef60a09764d1a1f4f04a47885c1b8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\" , \"gasLimit\" : \"0xe0000000\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : { \"2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" : { \"balance\" : \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } Copy the address of the validator and propose it from more than half the number of current validators. Attach a geth console to the node: geth attach cd .. geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0x4c1ccd426833b9782729a212c857f2f03b7b4c0d at block: 137 (Tue, 11 Jun 2019 16:32:47 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Check existing validators: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] Propose the new validator using the command istanbul.propose(<address>, true) with <address> replaced by the new validator candidate node address: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , true ) JSON result null Exit the console: exit Repeat the proposal process for this candidate node by connecting your geth console to node 1, node 2, and node 3. Note To drop a currently running validator candidate and stop further votes from being cast either for or against it, use istanbul.discard . Verify that the new validator is now in the list of validators by running istanbul.getValidators in a geth console attached to any of your nodes: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The list of validators contains six addresses now. Copy static-nodes.json and genesis.json from the existing chain, placing static-nodes.json into the new node\u2019s data directory: cd node5 mkdir -p data/geth cp ../node0/static-nodes.json data cp ../node0/genesis.json . Edit static-nodes.json and add the new validator\u2019s node info to the end of the file. The new validator\u2019s node info can be retrieved from the output of istanbul setup --num 1 --verbose --quorum --save in step 2. Update the IP address and port of the node info to match the IP address of the validator and port you want to use. [ \"enode://dd333ec28f0a8910c92eb4d336461eea1c20803eed9cf2c056557f986e720f8e693605bba2f4e8f289b1162e5ac7c80c914c7178130711e393ca76abc1d92f57@127.0.0.1:30300?discport=0\" , \"enode://1bb6be462f27e56f901c3fcb2d53a9273565f48e5d354c08f0c044405b29291b405b9f5aa027f3a75f9b058cb43e2f54719f15316979a0e5a2b760fff4631998@127.0.0.1:30301?discport=0\" , \"enode://0df02e94a3befc0683780d898119d3b675e5942c1a2f9ad47d35b4e6ccaf395cd71ec089fcf1d616748bf9871f91e5e3d29c1cf6f8f81de1b279082a104f619d@127.0.0.1:30302?discport=0\" , \"enode://3fe0ff0dd2730eaac7b6b379bdb51215b5831f4f48fa54a24a0298ad5ba8c2a332442948d53f4cd4fd28f373089a35e806ef722eb045659910f96a1278120516@127.0.0.1:30303?discport=0\" , \"enode://e53e92e5a51ac2685b0406d0d3c62288b53831c3b0f492b9dc4bc40334783702cfa74c49b836efa2761edde33a3282704273b2453537b855e7a4aeadcccdb43e@127.0.0.1:30304?discport=0\" , \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@127.0.0.1:30305?discport=0\" ] Copy the node key that was generated by the istanbul setup command to the geth directory inside the working directory: cp 0 /nodekey data/geth Initialize the new node with the following command: geth command geth --datadir data init genesis.json Result INFO [06-11|16:42:27.120] Maximum peer count ETH=25 LES=0 total=25 INFO [06-11|16:42:27.130] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/chaindata cache=16 handles=16 INFO [06-11|16:42:27.138] Writing custom genesis block INFO [06-11|16:42:27.138] Persisted trie from memory database nodes=6 size=1.01kB time=163.024\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.139] Successfully wrote genesis state database=chaindata hash=b992be\u2026533db7 INFO [06-11|16:42:27.139] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/lightchaindata cache=16 handles=16 INFO [06-11|16:42:27.141] Writing custom genesis block INFO [06-11|16:42:27.142] Persisted trie from memory database nodes=6 size=1.01kB time=94.57\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.142] Successfully wrote genesis state database=lightchaindata hash=b992be\u2026533db7 Copy startall.sh to a new start5.sh and execute it to start the node: cd .. cp startall.sh start5.sh Edit start5.sh with the following: #!/bin/bash cd node5 PRIVATE_CONFIG = ignore nohup geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0 .0.0.0 --http.port 22005 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --emitcheckpoints --port 30305 2 >>node.log & Important Update IP and port number matching for this node decided on step 6. Run node 5: ./start5.sh Check that the node is started: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.93 -bash 36432 ttys002 0:24.48 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:23.36 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:24.32 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:24.21 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:24.17 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:00.15 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.04 -bash 36467 ttys003 0:00.32 geth attach node3/data/geth.ipc","title":"Add a validator"},{"location":"tutorials/private-network/adding-removing-ibft-validators/#remove-a-validator","text":"Attach a geth console to a running validator, run istanbul.getValidators , and identify the address of the validator that needs to be removed: geth attach geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0xc1056df7c02b6f1a353052eaf0533cc7cb743b52 at block: 181 (Tue, 11 Jun 2019 16:36:27 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Run istanbul.getValidators : geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] We will remove 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 from the validator list in this tutorial. Run istanbul.propose(<address>, false) by passing the address of the validator that needs to be removed from more than half of the current validators: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , false ) JSON result null Repeat istanbul.propose(\"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\",false) for node 1, node 2, and node 3. Verify that the validator has been removed by running istanbul.getValidators in one of the nodes\u2019 attached geth console: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The validator 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 was removed and the validators list now only has five addresses. Stop the geth process corresponding to the validator that was removed: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.94 -bash 36432 ttys002 0:31.93 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:30.75 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:31.72 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:31.65 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:31.63 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:06.86 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.05 -bash 36493 ttys003 0:00.22 geth attach node4/data/geth.ipc Kill the geth process that uses port 22005 , corresponding to node 5 as indicated in start5.sh : kill 36485","title":"Remove a validator"},{"location":"tutorials/private-network/adding-removing-ibft-validators/#add-a-non-validator-node","text":"Same instructions as adding a validator excluding step 3, which proposes the node as validator.","title":"Add a non-validator node"},{"location":"tutorials/private-network/adding-removing-ibft-validators/#remove-a-non-validator-node","text":"Just execute step 4 from removing a validator .","title":"Remove a non-validator node"},{"location":"tutorials/private-network/adding-removing-qbft-validators/","text":"Add and remove QBFT validators \u00b6 Prerequisites \u00b6 A QBFT network as configured in the QBFT tutorial . Add a validator \u00b6 Create a working directory for the new node that needs to be added: mkdir node5 Change into the working directory for the new node 5 and run qbft setup : cd node5 ../istanbul-tools/build/bin/qbft setup --num 1 --verbose --quorum --save This will generate the validator details including Address , NodeInfo and genesis.json . Example files valida t ors { \"Address\" : \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"Nodekey\" : \"25b47a49ef08f888c04f30417363e6c6bc33e739147b2f8b5377b3168f9f7435\" , \"NodeInfo\" : \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@0.0.0.0:30303?discport=0\" } ge nes is.jso n { \"config\" : { \"chainId\" : 10 , \"eip150Block\" : 1 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 1 , \"eip158Block\" : 1 , \"byzantiumBlock\" : 1 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"testQBFTBlock\" : 0 }, \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5cffc942\" , \"extraData\" : \"0xf87aa00000000000000000000000000000000000000000000000000000000000000000f8549493917cadbace5dfce132b991732c6cda9bcc5b8a9427a97c9aaf04f18f3014c32e036dd0ac76da5f1894ce412f988377e31f4d0ff12d74df73b51c42d0ca9498c1334496614aed49d2e81526d089f7264fed9cc080c0\" , \"gasLimit\" : \"0xe0000000\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : { \"2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" : { \"balance\" : \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } Copy the address of the validator and propose it from more than half the number of current validators. Attach a geth console to the node: geth attach cd .. geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0x4c1ccd426833b9782729a212c857f2f03b7b4c0d at block: 137 (Tue, 11 Jun 2019 16:32:47 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Check existing validators: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] Propose the new validator using the command istanbul.propose(<address>, true) with <address> replaced by the new validator candidate node address: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , true ) JSON result null Exit the console: exit Repeat the proposal process for this candidate node by connecting your geth console to node 1, node 2, and node 3. Note To drop a currently running validator candidate and stop further votes from being cast either for or against it, use istanbul.discard . Verify that the new validator is now in the list of validators by running istanbul.getValidators in a geth console attached to any of your nodes: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The list of validators contains six addresses now. Copy static-nodes.json and genesis.json from the existing chain, placing static-nodes.json into the new node\u2019s data directory: cd node5 mkdir -p data/geth cp ../node0/static-nodes.json data cp ../node0/genesis.json . Edit static-nodes.json and add the new validator\u2019s node info to the end of the file. The new validator\u2019s node info can be retrieved from the output of qbft setup --num 1 --verbose --quorum --save in step 2. Update the IP address and port of the node info to match the IP address of the validator and port you want to use. [ \"enode://dd333ec28f0a8910c92eb4d336461eea1c20803eed9cf2c056557f986e720f8e693605bba2f4e8f289b1162e5ac7c80c914c7178130711e393ca76abc1d92f57@127.0.0.1:30300?discport=0\" , \"enode://1bb6be462f27e56f901c3fcb2d53a9273565f48e5d354c08f0c044405b29291b405b9f5aa027f3a75f9b058cb43e2f54719f15316979a0e5a2b760fff4631998@127.0.0.1:30301?discport=0\" , \"enode://0df02e94a3befc0683780d898119d3b675e5942c1a2f9ad47d35b4e6ccaf395cd71ec089fcf1d616748bf9871f91e5e3d29c1cf6f8f81de1b279082a104f619d@127.0.0.1:30302?discport=0\" , \"enode://3fe0ff0dd2730eaac7b6b379bdb51215b5831f4f48fa54a24a0298ad5ba8c2a332442948d53f4cd4fd28f373089a35e806ef722eb045659910f96a1278120516@127.0.0.1:30303?discport=0\" , \"enode://e53e92e5a51ac2685b0406d0d3c62288b53831c3b0f492b9dc4bc40334783702cfa74c49b836efa2761edde33a3282704273b2453537b855e7a4aeadcccdb43e@127.0.0.1:30304?discport=0\" , \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@127.0.0.1:30305?discport=0\" ] Copy the node key that was generated by the qbft setup command to the geth directory inside the working directory: cp 0 /nodekey data/geth Initialize the new node with the following command: geth command geth --datadir data init genesis.json Result INFO [06-11|16:42:27.120] Maximum peer count ETH=25 LES=0 total=25 INFO [06-11|16:42:27.130] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/chaindata cache=16 handles=16 INFO [06-11|16:42:27.138] Writing custom genesis block INFO [06-11|16:42:27.138] Persisted trie from memory database nodes=6 size=1.01kB time=163.024\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.139] Successfully wrote genesis state database=chaindata hash=b992be\u2026533db7 INFO [06-11|16:42:27.139] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/lightchaindata cache=16 handles=16 INFO [06-11|16:42:27.141] Writing custom genesis block INFO [06-11|16:42:27.142] Persisted trie from memory database nodes=6 size=1.01kB time=94.57\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.142] Successfully wrote genesis state database=lightchaindata hash=b992be\u2026533db7 Copy startall.sh to a new start5.sh and execute it to start the node: cd .. cp startall.sh start5.sh Edit start5.sh with the following: #!/bin/bash cd node5 PRIVATE_CONFIG = ignore nohup geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0 .0.0.0 --http.port 22005 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft --emitcheckpoints --port 30305 2 >>node.log & Important Update IP and port number matching for this node decided on step 6. Run node 5: ./start5.sh Check that the node is started: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.93 -bash 36432 ttys002 0:24.48 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:23.36 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:24.32 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:24.21 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:24.17 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:00.15 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.04 -bash 36467 ttys003 0:00.32 geth attach node3/data/geth.ipc Remove a validator \u00b6 Attach a geth console to a running validator, run istanbul.getValidators , and identify the address of the validator that needs to be removed: geth attach geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0xc1056df7c02b6f1a353052eaf0533cc7cb743b52 at block: 181 (Tue, 11 Jun 2019 16:36:27 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Run istanbul.getValidators : geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] We will remove 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 from the validator list in this tutorial. Run istanbul.propose(<address>, false) by passing the address of the validator that needs to be removed from more than half of the current validators: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , false ) JSON result null Repeat istanbul.propose(\"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\",false) for node 1, node 2, and node 3. Verify that the validator has been removed by running istanbul.getValidators in one of the nodes\u2019 attached geth console: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The validator 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 was removed and the validators list now only has five addresses. Stop the geth process corresponding to the validator that was removed: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.94 -bash 36432 ttys002 0:31.93 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:30.75 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:31.72 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:31.65 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:31.63 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:06.86 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.05 -bash 36493 ttys003 0:00.22 geth attach node4/data/geth.ipc Kill the geth process that uses port 22005 , corresponding to node 5 as indicated in start5.sh : kill 36485 Add a non-validator node \u00b6 Same instructions as adding a validator excluding step 3, which proposes the node as validator. Remove a non-validator node \u00b6 Just execute step 4 from removing a validator .","title":"Add and remove QBFT validators"},{"location":"tutorials/private-network/adding-removing-qbft-validators/#add-and-remove-qbft-validators","text":"","title":"Add and remove QBFT validators"},{"location":"tutorials/private-network/adding-removing-qbft-validators/#prerequisites","text":"A QBFT network as configured in the QBFT tutorial .","title":"Prerequisites"},{"location":"tutorials/private-network/adding-removing-qbft-validators/#add-a-validator","text":"Create a working directory for the new node that needs to be added: mkdir node5 Change into the working directory for the new node 5 and run qbft setup : cd node5 ../istanbul-tools/build/bin/qbft setup --num 1 --verbose --quorum --save This will generate the validator details including Address , NodeInfo and genesis.json . Example files valida t ors { \"Address\" : \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"Nodekey\" : \"25b47a49ef08f888c04f30417363e6c6bc33e739147b2f8b5377b3168f9f7435\" , \"NodeInfo\" : \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@0.0.0.0:30303?discport=0\" } ge nes is.jso n { \"config\" : { \"chainId\" : 10 , \"eip150Block\" : 1 , \"eip150Hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"eip155Block\" : 1 , \"eip158Block\" : 1 , \"byzantiumBlock\" : 1 , \"istanbul\" : { \"epoch\" : 30000 , \"policy\" : 0 , \"testQBFTBlock\" : 0 }, \"isQuorum\" : true }, \"nonce\" : \"0x0\" , \"timestamp\" : \"0x5cffc942\" , \"extraData\" : \"0xf87aa00000000000000000000000000000000000000000000000000000000000000000f8549493917cadbace5dfce132b991732c6cda9bcc5b8a9427a97c9aaf04f18f3014c32e036dd0ac76da5f1894ce412f988377e31f4d0ff12d74df73b51c42d0ca9498c1334496614aed49d2e81526d089f7264fed9cc080c0\" , \"gasLimit\" : \"0xe0000000\" , \"difficulty\" : \"0x1\" , \"mixHash\" : \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\" , \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"alloc\" : { \"2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" : { \"balance\" : \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\" : \"0x0\" , \"gasUsed\" : \"0x0\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } Copy the address of the validator and propose it from more than half the number of current validators. Attach a geth console to the node: geth attach cd .. geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0x4c1ccd426833b9782729a212c857f2f03b7b4c0d at block: 137 (Tue, 11 Jun 2019 16:32:47 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Check existing validators: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] Propose the new validator using the command istanbul.propose(<address>, true) with <address> replaced by the new validator candidate node address: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , true ) JSON result null Exit the console: exit Repeat the proposal process for this candidate node by connecting your geth console to node 1, node 2, and node 3. Note To drop a currently running validator candidate and stop further votes from being cast either for or against it, use istanbul.discard . Verify that the new validator is now in the list of validators by running istanbul.getValidators in a geth console attached to any of your nodes: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The list of validators contains six addresses now. Copy static-nodes.json and genesis.json from the existing chain, placing static-nodes.json into the new node\u2019s data directory: cd node5 mkdir -p data/geth cp ../node0/static-nodes.json data cp ../node0/genesis.json . Edit static-nodes.json and add the new validator\u2019s node info to the end of the file. The new validator\u2019s node info can be retrieved from the output of qbft setup --num 1 --verbose --quorum --save in step 2. Update the IP address and port of the node info to match the IP address of the validator and port you want to use. [ \"enode://dd333ec28f0a8910c92eb4d336461eea1c20803eed9cf2c056557f986e720f8e693605bba2f4e8f289b1162e5ac7c80c914c7178130711e393ca76abc1d92f57@127.0.0.1:30300?discport=0\" , \"enode://1bb6be462f27e56f901c3fcb2d53a9273565f48e5d354c08f0c044405b29291b405b9f5aa027f3a75f9b058cb43e2f54719f15316979a0e5a2b760fff4631998@127.0.0.1:30301?discport=0\" , \"enode://0df02e94a3befc0683780d898119d3b675e5942c1a2f9ad47d35b4e6ccaf395cd71ec089fcf1d616748bf9871f91e5e3d29c1cf6f8f81de1b279082a104f619d@127.0.0.1:30302?discport=0\" , \"enode://3fe0ff0dd2730eaac7b6b379bdb51215b5831f4f48fa54a24a0298ad5ba8c2a332442948d53f4cd4fd28f373089a35e806ef722eb045659910f96a1278120516@127.0.0.1:30303?discport=0\" , \"enode://e53e92e5a51ac2685b0406d0d3c62288b53831c3b0f492b9dc4bc40334783702cfa74c49b836efa2761edde33a3282704273b2453537b855e7a4aeadcccdb43e@127.0.0.1:30304?discport=0\" , \"enode://273eaf48591ce0e77c800b3e6465811d6d2f924c4dcaae016c2c7375256d17876c3e05f91839b741fe12350da0b5a741da4e30f39553fe8790f88503c64f6ef9@127.0.0.1:30305?discport=0\" ] Copy the node key that was generated by the qbft setup command to the geth directory inside the working directory: cp 0 /nodekey data/geth Initialize the new node with the following command: geth command geth --datadir data init genesis.json Result INFO [06-11|16:42:27.120] Maximum peer count ETH=25 LES=0 total=25 INFO [06-11|16:42:27.130] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/chaindata cache=16 handles=16 INFO [06-11|16:42:27.138] Writing custom genesis block INFO [06-11|16:42:27.138] Persisted trie from memory database nodes=6 size=1.01kB time=163.024\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.139] Successfully wrote genesis state database=chaindata hash=b992be\u2026533db7 INFO [06-11|16:42:27.139] Allocated cache and file handles database=/Users/username/fromscratchistanbul/node5/data/geth/lightchaindata cache=16 handles=16 INFO [06-11|16:42:27.141] Writing custom genesis block INFO [06-11|16:42:27.142] Persisted trie from memory database nodes=6 size=1.01kB time=94.57\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [06-11|16:42:27.142] Successfully wrote genesis state database=lightchaindata hash=b992be\u2026533db7 Copy startall.sh to a new start5.sh and execute it to start the node: cd .. cp startall.sh start5.sh Edit start5.sh with the following: #!/bin/bash cd node5 PRIVATE_CONFIG = ignore nohup geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0 .0.0.0 --http.port 22005 --http.api admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft --emitcheckpoints --port 30305 2 >>node.log & Important Update IP and port number matching for this node decided on step 6. Run node 5: ./start5.sh Check that the node is started: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.93 -bash 36432 ttys002 0:24.48 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:23.36 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:24.32 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:24.21 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:24.17 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:00.15 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.04 -bash 36467 ttys003 0:00.32 geth attach node3/data/geth.ipc","title":"Add a validator"},{"location":"tutorials/private-network/adding-removing-qbft-validators/#remove-a-validator","text":"Attach a geth console to a running validator, run istanbul.getValidators , and identify the address of the validator that needs to be removed: geth attach geth attach node0/data/geth.ipc Result Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-stable-bb88608c(quorum-v2.2.3)/darwin-amd64/go1.10.2 coinbase: 0xc1056df7c02b6f1a353052eaf0533cc7cb743b52 at block: 181 (Tue, 11 Jun 2019 16:36:27 BST) datadir: /Users/username/fromscratchistanbul/node0/data modules: admin:1.0 debug:1.0 eth:1.0 istanbul:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 Run istanbul.getValidators : geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] We will remove 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 from the validator list in this tutorial. Run istanbul.propose(<address>, false) by passing the address of the validator that needs to be removed from more than half of the current validators: geth console request istanbul . propose ( \"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\" , false ) JSON result null Repeat istanbul.propose(\"0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1\",false) for node 1, node 2, and node 3. Verify that the validator has been removed by running istanbul.getValidators in one of the nodes\u2019 attached geth console: geth console request istanbul . getValidators () JSON result [ \"0x189d23d201b03ae1cf9113672df29a5d672aefa3\" , \"0x44b07d2c28b8ed8f02b45bd84ac7d9051b3349e6\" , \"0x4c1ccd426833b9782729a212c857f2f03b7b4c0d\" , \"0x7ae555d0f6faad7930434abdaac2274fd86ab516\" , \"0xc1056df7c02b6f1a353052eaf0533cc7cb743b52\" ] The validator 0x2aabbc1bb9bacef60a09764d1a1f4f04a47885c1 was removed and the validators list now only has five addresses. Stop the geth process corresponding to the validator that was removed: Command ps Result PID TTY TIME CMD 10554 ttys000 0:00.11 -bash 21829 ttys001 0:00.03 -bash 9125 ttys002 0:00.94 -bash 36432 ttys002 0:31.93 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22000 --http.api admin, 36433 ttys002 0:30.75 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22001 --http.api admin, 36434 ttys002 0:31.72 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22002 --http.api admin, 36435 ttys002 0:31.65 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22003 --http.api admin, 36436 ttys002 0:31.63 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22004 --http.api admin, 36485 ttys002 0:06.86 geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --mine --minerthreads 1 --verbosity 5 --networkid 10 --http --http.addr 0.0.0.0 --http.port 22005 --http.api admin, 36455 ttys003 0:00.05 -bash 36493 ttys003 0:00.22 geth attach node4/data/geth.ipc Kill the geth process that uses port 22005 , corresponding to node 5 as indicated in start5.sh : kill 36485","title":"Remove a validator"},{"location":"tutorials/private-network/adding-removing-qbft-validators/#add-a-non-validator-node","text":"Same instructions as adding a validator excluding step 3, which proposes the node as validator.","title":"Add a non-validator node"},{"location":"tutorials/private-network/adding-removing-qbft-validators/#remove-a-non-validator-node","text":"Just execute step 4 from removing a validator .","title":"Remove a non-validator node"},{"location":"tutorials/private-network/create-a-raft-network/","text":"Create a private network using the Raft consensus protocol \u00b6 A private network provides a configurable network for testing. This private network uses the Raft consensus protocol . Warning Raft is not suitable for production environments. Use only in development environments. You can migrate a Raft network to another consensus protocol . Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall. Prerequisites \u00b6 Node.js version 15 or later . GoQuorum . Ensure that PATH contains geth and bootnode . Tip GoQuorum is a fork of geth . GoQuorum uses the geth command to start GoQuorum nodes. Steps \u00b6 Listed on the right-hand side of the page are the steps to create a private network using Raft with two nodes. 1. Create directories \u00b6 Create directories for your private network and two nodes: Raft-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-1 \u2502 \u2514\u2500\u2500 data | \u2514\u2500\u2500 keystore 2. Run the Quorum Genesis Tool \u00b6 Run the Quorum Genesis Tool interactively or by using CLI options. The following example uses CLI options to create the genesis file and node keys: npx quorum-genesis-tool --consensus raft --chainID 1337 --blockperiod 5 --requestTimeout 10 --epochLength 30000 --difficulty 1 --gasLimit '0xFFFFFF' --coinbase '0x0000000000000000000000000000000000000000' --validators 2 --members 0 --bootnodes 0 --outputPath 'artifacts' Node keys for two nodes, along with static-nodes.json , permissioned-nodes.json , disallowed-nodes.json , genesis.json are generated. Example output Need to install the following packages: quorum-genesis-tool Ok to proceed? ( y ) y Creating bootnodes... Creating members... Creating validators... Artifacts in folder: artifacts/2022-02-23-12-34-35 The following is the folder structure of the artifacts generated: Raft-Network \u251c\u2500\u2500 artifacts \u2514\u2500\u25002022-02-23-12-34-35 \u251c\u2500\u2500 goQuorum \u2502 \u251c\u2500\u2500 disallowed-nodes.json \u2502 \u251c\u2500\u2500 genesis.json \u2502 \u251c\u2500\u2500 permissioned-nodes.json \u2502 \u2514\u2500\u2500 static-nodes.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 userData.json \u251c\u2500\u2500 validator0 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator1 \u2502 \u251c\u2500\u2500 accountAddress \u251c\u2500\u2500 accountKeystore \u251c\u2500\u2500 accountPassword \u251c\u2500\u2500 accountPrivateKey \u251c\u2500\u2500 address \u251c\u2500\u2500 nodekey \u2514\u2500\u2500 nodekey.pub Move all the keys into the artifacts folder directly, for ease of use in the next steps: cd Raft-Network mv artifacts/2022-02-23-12-34-35/* artifacts 3. Update IP and port numbers \u00b6 Go to the goQuorum directory of the artifacts: cd artifacts/goQuorum Update the IP and port numbers for all initial validator nodes in static-nodes.json and permissioned-nodes.json (if applicable). static-nodes.json [ \"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30300?discport=0&raftport=50000\" , \"enode://0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c@127.0.0.1:30301?discport=0&raftport=53001\" ] 4. Copy the static nodes file and node keys to each node \u00b6 Copy static-nodes.json , genesis.json , and permissioned-nodes.json (if applicable) to the data directory for each node: cp static-nodes.json genesis.json ./../Node-0/data/ cp static-nodes.json genesis.json ./../Node-1/data/ In each validator directory, copy the nodekey files and address to the data directory: cp nodekey* address ../../Node-0/data cp nodekey* address ../../Node-1/data Copy the individual account keys to the keystore directory for each node: cp account* ../../Node-0/data/keystore cp account* ../../Node-1/data/keystore 5. Initialize node 1 \u00b6 In the Node-1 directory, initialize node 1: geth --datadir data init data/genesis.json 6. Start node 0 \u00b6 In the Node-0 directory, start the first node: export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --raft --raftport 53000 --raftblocktime 300 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22000 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32000 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30300 The PRIVATE_CONFIG environment variable starts GoQuorum without privacy enabled. 7. Start node 1 \u00b6 In a new terminal in the Node-1 directory, start the remaining node using the same command except specifying different ports for DevP2P and RPC: Important The DevP2P port numbers must match the port numbers in static-nodes.json . export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --raft --raftport 53001 --raftblocktime 300 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22001 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32001 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30301 8. Attach to node 1 \u00b6 In another terminal in the Node-1 directory, attach to your node: geth attach data/geth.ipc Use the Raft cluster command to confirm the cluster now has two nodes: Command raft . cluster Result [{ ip : \"127.0.0.1\" , nodeId : \"1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147\" , p2pPort : 30300 , raftId : 2 , raftPort : 53000 }, { ip : \"127.0.0.1\" , nodeId : \"0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c\" , p2pPort : 30301 , raftId : 1 , raftPort : 53001 }] 9. Add more nodes \u00b6 The process to add more nodes to a Raft network is exactly the same as the previous steps, except: Specify different ports for DevP2P, RPC, and Raft. Specify the Raft ID using the --raftjoinexisting option. export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --raft --raftport 53001 --raftblocktime 300 --raftjoinexisting 2 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22002 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32002 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30302 Important For a Raft network to work, 51% of the peers must be up and running. We recommend having an odd number of at least 3 peers in a network.","title":"Use Raft"},{"location":"tutorials/private-network/create-a-raft-network/#create-a-private-network-using-the-raft-consensus-protocol","text":"A private network provides a configurable network for testing. This private network uses the Raft consensus protocol . Warning Raft is not suitable for production environments. Use only in development environments. You can migrate a Raft network to another consensus protocol . Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall.","title":"Create a private network using the Raft consensus protocol"},{"location":"tutorials/private-network/create-a-raft-network/#prerequisites","text":"Node.js version 15 or later . GoQuorum . Ensure that PATH contains geth and bootnode . Tip GoQuorum is a fork of geth . GoQuorum uses the geth command to start GoQuorum nodes.","title":"Prerequisites"},{"location":"tutorials/private-network/create-a-raft-network/#steps","text":"Listed on the right-hand side of the page are the steps to create a private network using Raft with two nodes.","title":"Steps"},{"location":"tutorials/private-network/create-a-raft-network/#1-create-directories","text":"Create directories for your private network and two nodes: Raft-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-1 \u2502 \u2514\u2500\u2500 data | \u2514\u2500\u2500 keystore","title":"1. Create directories"},{"location":"tutorials/private-network/create-a-raft-network/#2-run-the-quorum-genesis-tool","text":"Run the Quorum Genesis Tool interactively or by using CLI options. The following example uses CLI options to create the genesis file and node keys: npx quorum-genesis-tool --consensus raft --chainID 1337 --blockperiod 5 --requestTimeout 10 --epochLength 30000 --difficulty 1 --gasLimit '0xFFFFFF' --coinbase '0x0000000000000000000000000000000000000000' --validators 2 --members 0 --bootnodes 0 --outputPath 'artifacts' Node keys for two nodes, along with static-nodes.json , permissioned-nodes.json , disallowed-nodes.json , genesis.json are generated. Example output Need to install the following packages: quorum-genesis-tool Ok to proceed? ( y ) y Creating bootnodes... Creating members... Creating validators... Artifacts in folder: artifacts/2022-02-23-12-34-35 The following is the folder structure of the artifacts generated: Raft-Network \u251c\u2500\u2500 artifacts \u2514\u2500\u25002022-02-23-12-34-35 \u251c\u2500\u2500 goQuorum \u2502 \u251c\u2500\u2500 disallowed-nodes.json \u2502 \u251c\u2500\u2500 genesis.json \u2502 \u251c\u2500\u2500 permissioned-nodes.json \u2502 \u2514\u2500\u2500 static-nodes.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 userData.json \u251c\u2500\u2500 validator0 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator1 \u2502 \u251c\u2500\u2500 accountAddress \u251c\u2500\u2500 accountKeystore \u251c\u2500\u2500 accountPassword \u251c\u2500\u2500 accountPrivateKey \u251c\u2500\u2500 address \u251c\u2500\u2500 nodekey \u2514\u2500\u2500 nodekey.pub Move all the keys into the artifacts folder directly, for ease of use in the next steps: cd Raft-Network mv artifacts/2022-02-23-12-34-35/* artifacts","title":"2. Run the Quorum Genesis Tool"},{"location":"tutorials/private-network/create-a-raft-network/#3-update-ip-and-port-numbers","text":"Go to the goQuorum directory of the artifacts: cd artifacts/goQuorum Update the IP and port numbers for all initial validator nodes in static-nodes.json and permissioned-nodes.json (if applicable). static-nodes.json [ \"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30300?discport=0&raftport=50000\" , \"enode://0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c@127.0.0.1:30301?discport=0&raftport=53001\" ]","title":"3. Update IP and port numbers"},{"location":"tutorials/private-network/create-a-raft-network/#4-copy-the-static-nodes-file-and-node-keys-to-each-node","text":"Copy static-nodes.json , genesis.json , and permissioned-nodes.json (if applicable) to the data directory for each node: cp static-nodes.json genesis.json ./../Node-0/data/ cp static-nodes.json genesis.json ./../Node-1/data/ In each validator directory, copy the nodekey files and address to the data directory: cp nodekey* address ../../Node-0/data cp nodekey* address ../../Node-1/data Copy the individual account keys to the keystore directory for each node: cp account* ../../Node-0/data/keystore cp account* ../../Node-1/data/keystore","title":"4. Copy the static nodes file and node keys to each node"},{"location":"tutorials/private-network/create-a-raft-network/#5-initialize-node-1","text":"In the Node-1 directory, initialize node 1: geth --datadir data init data/genesis.json","title":"5. Initialize node 1"},{"location":"tutorials/private-network/create-a-raft-network/#6-start-node-0","text":"In the Node-0 directory, start the first node: export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --raft --raftport 53000 --raftblocktime 300 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22000 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32000 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30300 The PRIVATE_CONFIG environment variable starts GoQuorum without privacy enabled.","title":"6. Start node 0"},{"location":"tutorials/private-network/create-a-raft-network/#7-start-node-1","text":"In a new terminal in the Node-1 directory, start the remaining node using the same command except specifying different ports for DevP2P and RPC: Important The DevP2P port numbers must match the port numbers in static-nodes.json . export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --raft --raftport 53001 --raftblocktime 300 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22001 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32001 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30301","title":"7. Start node 1"},{"location":"tutorials/private-network/create-a-raft-network/#8-attach-to-node-1","text":"In another terminal in the Node-1 directory, attach to your node: geth attach data/geth.ipc Use the Raft cluster command to confirm the cluster now has two nodes: Command raft . cluster Result [{ ip : \"127.0.0.1\" , nodeId : \"1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147\" , p2pPort : 30300 , raftId : 2 , raftPort : 53000 }, { ip : \"127.0.0.1\" , nodeId : \"0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c\" , p2pPort : 30301 , raftId : 1 , raftPort : 53001 }]","title":"8. Attach to node 1"},{"location":"tutorials/private-network/create-a-raft-network/#9-add-more-nodes","text":"The process to add more nodes to a Raft network is exactly the same as the previous steps, except: Specify different ports for DevP2P, RPC, and Raft. Specify the Raft ID using the --raftjoinexisting option. export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --raft --raftport 53001 --raftblocktime 300 --raftjoinexisting 2 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22002 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32002 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30302 Important For a Raft network to work, 51% of the peers must be up and running. We recommend having an odd number of at least 3 peers in a network.","title":"9. Add more nodes"},{"location":"tutorials/private-network/create-ibft-network/","text":"Create a private network using the IBFT consensus protocol \u00b6 A private network provides a configurable network for testing. This tutorial walks you through creating an IBFT private network with five nodes. Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall. Prerequisites \u00b6 Node.js version 15 or later . GoQuorum . Ensure that PATH contains geth and bootnode . Tip GoQuorum is a fork of geth . GoQuorum uses the geth command to start GoQuorum nodes. Steps \u00b6 1. Create directories \u00b6 Create directories for your private network and five nodes. IBFT-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-1 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-2 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-3 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-4 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore 2. Run the Quorum Genesis Tool \u00b6 Run the Quorum Genesis Tool interactively or by using CLI options. The following example uses CLI options to create the genesis file and node keys: npx quorum-genesis-tool --consensus ibft --chainID 1337 --blockperiod 5 --requestTimeout 10 --epochLength 30000 --difficulty 1 --gasLimit '0xFFFFFF' --coinbase '0x0000000000000000000000000000000000000000' --validators 5 --members 0 --bootnodes 0 --outputPath 'artifacts' Node keys for five nodes, along with static-nodes.json , permissioned-nodes.json , disallowed-nodes.json , and genesis.json are generated. Example output Need to install the following packages: quorum-genesis-tool Ok to proceed? ( y ) y Creating bootnodes... Creating members... Creating validators... Artifacts in folder: artifacts/2022-02-23-12-34-35 The following is the folder structure of the artifacts generated: IBFT-Network \u251c\u2500\u2500 artifacts \u2514\u2500\u25002022-02-23-12-34-35 \u251c\u2500\u2500 goQuorum \u2502 \u251c\u2500\u2500 disallowed-nodes.json \u2502 \u251c\u2500\u2500 genesis.json \u2502 \u251c\u2500\u2500 permissioned-nodes.json \u2502 \u2514\u2500\u2500 static-nodes.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 userData.json \u251c\u2500\u2500 validator0 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator1 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator2 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator3 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u2514\u2500\u2500 validator4 \u251c\u2500\u2500 accountAddress \u251c\u2500\u2500 accountKeystore \u251c\u2500\u2500 accountPassword \u251c\u2500\u2500 accountPrivateKey \u251c\u2500\u2500 address \u251c\u2500\u2500 nodekey \u2514\u2500\u2500 nodekey.pub Move all the keys into the artifacts folder directly, for ease of use in the next steps: cd IBFT-Network mv artifacts/2022-02-23-12-34-35/* artifacts 3. Update IP and port numbers \u00b6 Go to the goQuorum directory of the artifacts: cd artifacts/goQuorum Update the IP and port numbers for all initial validator nodes in static-nodes.json and permissioned-nodes.json (if applicable). static-nodes.json [ \"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30300?discport=0&raftport=53000\" , \"enode://0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c@127.0.0.1:30301?discport=0&raftport=53001\" , \"enode://d40a766cb6fe75f052fe21f61bc84ca3851abb6f999d73f97dd76e14fc2dea175d4cf554ccbcc2c7c639a0901932775b523554cb73facdfab08def975208f8e6@127.0.0.1:30302?discport=0&raftport=53002\" , \"enode://80a98f66d243c6604cda0e1c722eed3d9e080591c81710eec70794e0909e58661f4863e29a7a63bf7fb9387afc8609df37bacbf3d5c523d97bf598c3470840f5@127.0.0.1:30303?discport=0&raftport=53003\" , \"enode://7fa183662285993efaf7a59e303ec5543bbcd09cb2883e7611d9576ed90f3bcf0400b70af11c5266e5110eebe8afd4e817437bde574d686f440df1ec85822add@127.0.0.1:30304?discport=0&raftport=53004\" ] 4. Copy the static nodes file and node keys to each node \u00b6 Copy static-nodes.json , genesis.json , and permissioned-nodes.json (if applicable) to the data directory for each node: cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-0/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-1/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-2/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-3/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-4/data/ In each validator directory, copy the nodekey files and address to the data directory: cp nodekey* address ../../Node-0/data cp nodekey* address ../../Node-1/data cp nodekey* address ../../Node-2/data cp nodekey* address ../../Node-3/data cp nodekey* address ../../Node-4/data Copy the individual account keys to the keystore directory for each node: cp account* ../../Node-0/data/keystore cp account* ../../Node-1/data/keystore cp account* ../../Node-2/data/keystore cp account* ../../Node-3/data/keystore cp account* ../../Node-4/data/keystore 5. Initialize nodes \u00b6 In each node directory ( Node-0 , Node-1 , Node-2 , Node-3 , and Node-4 ), initialize the node: geth --datadir data init data/genesis.json 6. Start node 0 \u00b6 In the Node-0 directory, start the first node: export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22000 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32000 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30300 The PRIVATE_CONFIG environment variable starts GoQuorum without privacy enabled. 7. Start nodes 1, 2, 3, and 4 \u00b6 In a new terminal for each node in each node directory, start the remaining nodes using the same command except specifying different ports for DevP2P and RPC. Important The DevP2P port numbers must match the port numbers in static-nodes.json . Node 1 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22001 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32001 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30301 Node 2 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22002 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32002 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30302 Node 3 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22003 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32003 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30303 Node 4 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22004 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32004 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30304 8. Attach to node 0 \u00b6 In another terminal in the Node-0 directory, attach to node 0: geth attach data/geth.ipc 9. Check peer count \u00b6 Use the JavaScript console to check the peer count: Command net.peerCount Result 4 Tip If the peer count is 0, check that static-nodes.json was updated with the correct port numbers and copied to the data directory for each node . The enode ID displayed in the logs on startup must match the enode listed in static-nodes.json for each node, including the port number specified using --port on startup . The log message is: INFO [12-08|10:44:55.044] Started P2P networking self=\"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30301?discport=0\" 10. List current validators \u00b6 Use istanbul.getValidators to view the validator addresses. Command istanbul.getValidators ( \"latest\" ) Result [ \"e1a8d6a6866a6c8f25ed853e3f957b0ed06a8f1c\" , \"6028d68da1df3c54d5f0949de6082fb69a7239d1\" , \"c1ed779faf6975399c5bdb90b40e2f324185bad0\" , \"6480d9bf06fc8ba9a0393976386e47a5c4f014de\" , \"da4d64ac5fea8aaf2943680241ce9ca4befed870\" ] Next steps \u00b6 You can add and remove validators .","title":"Use IBFT"},{"location":"tutorials/private-network/create-ibft-network/#create-a-private-network-using-the-ibft-consensus-protocol","text":"A private network provides a configurable network for testing. This tutorial walks you through creating an IBFT private network with five nodes. Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall.","title":"Create a private network using the IBFT consensus protocol"},{"location":"tutorials/private-network/create-ibft-network/#prerequisites","text":"Node.js version 15 or later . GoQuorum . Ensure that PATH contains geth and bootnode . Tip GoQuorum is a fork of geth . GoQuorum uses the geth command to start GoQuorum nodes.","title":"Prerequisites"},{"location":"tutorials/private-network/create-ibft-network/#steps","text":"","title":"Steps"},{"location":"tutorials/private-network/create-ibft-network/#1-create-directories","text":"Create directories for your private network and five nodes. IBFT-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-1 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-2 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-3 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-4 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore","title":"1. Create directories"},{"location":"tutorials/private-network/create-ibft-network/#2-run-the-quorum-genesis-tool","text":"Run the Quorum Genesis Tool interactively or by using CLI options. The following example uses CLI options to create the genesis file and node keys: npx quorum-genesis-tool --consensus ibft --chainID 1337 --blockperiod 5 --requestTimeout 10 --epochLength 30000 --difficulty 1 --gasLimit '0xFFFFFF' --coinbase '0x0000000000000000000000000000000000000000' --validators 5 --members 0 --bootnodes 0 --outputPath 'artifacts' Node keys for five nodes, along with static-nodes.json , permissioned-nodes.json , disallowed-nodes.json , and genesis.json are generated. Example output Need to install the following packages: quorum-genesis-tool Ok to proceed? ( y ) y Creating bootnodes... Creating members... Creating validators... Artifacts in folder: artifacts/2022-02-23-12-34-35 The following is the folder structure of the artifacts generated: IBFT-Network \u251c\u2500\u2500 artifacts \u2514\u2500\u25002022-02-23-12-34-35 \u251c\u2500\u2500 goQuorum \u2502 \u251c\u2500\u2500 disallowed-nodes.json \u2502 \u251c\u2500\u2500 genesis.json \u2502 \u251c\u2500\u2500 permissioned-nodes.json \u2502 \u2514\u2500\u2500 static-nodes.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 userData.json \u251c\u2500\u2500 validator0 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator1 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator2 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator3 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u2514\u2500\u2500 validator4 \u251c\u2500\u2500 accountAddress \u251c\u2500\u2500 accountKeystore \u251c\u2500\u2500 accountPassword \u251c\u2500\u2500 accountPrivateKey \u251c\u2500\u2500 address \u251c\u2500\u2500 nodekey \u2514\u2500\u2500 nodekey.pub Move all the keys into the artifacts folder directly, for ease of use in the next steps: cd IBFT-Network mv artifacts/2022-02-23-12-34-35/* artifacts","title":"2. Run the Quorum Genesis Tool"},{"location":"tutorials/private-network/create-ibft-network/#3-update-ip-and-port-numbers","text":"Go to the goQuorum directory of the artifacts: cd artifacts/goQuorum Update the IP and port numbers for all initial validator nodes in static-nodes.json and permissioned-nodes.json (if applicable). static-nodes.json [ \"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30300?discport=0&raftport=53000\" , \"enode://0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c@127.0.0.1:30301?discport=0&raftport=53001\" , \"enode://d40a766cb6fe75f052fe21f61bc84ca3851abb6f999d73f97dd76e14fc2dea175d4cf554ccbcc2c7c639a0901932775b523554cb73facdfab08def975208f8e6@127.0.0.1:30302?discport=0&raftport=53002\" , \"enode://80a98f66d243c6604cda0e1c722eed3d9e080591c81710eec70794e0909e58661f4863e29a7a63bf7fb9387afc8609df37bacbf3d5c523d97bf598c3470840f5@127.0.0.1:30303?discport=0&raftport=53003\" , \"enode://7fa183662285993efaf7a59e303ec5543bbcd09cb2883e7611d9576ed90f3bcf0400b70af11c5266e5110eebe8afd4e817437bde574d686f440df1ec85822add@127.0.0.1:30304?discport=0&raftport=53004\" ]","title":"3. Update IP and port numbers"},{"location":"tutorials/private-network/create-ibft-network/#4-copy-the-static-nodes-file-and-node-keys-to-each-node","text":"Copy static-nodes.json , genesis.json , and permissioned-nodes.json (if applicable) to the data directory for each node: cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-0/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-1/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-2/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-3/data/ cp static-nodes.json genesis.json permissioned-nodes.json ./../Node-4/data/ In each validator directory, copy the nodekey files and address to the data directory: cp nodekey* address ../../Node-0/data cp nodekey* address ../../Node-1/data cp nodekey* address ../../Node-2/data cp nodekey* address ../../Node-3/data cp nodekey* address ../../Node-4/data Copy the individual account keys to the keystore directory for each node: cp account* ../../Node-0/data/keystore cp account* ../../Node-1/data/keystore cp account* ../../Node-2/data/keystore cp account* ../../Node-3/data/keystore cp account* ../../Node-4/data/keystore","title":"4. Copy the static nodes file and node keys to each node"},{"location":"tutorials/private-network/create-ibft-network/#5-initialize-nodes","text":"In each node directory ( Node-0 , Node-1 , Node-2 , Node-3 , and Node-4 ), initialize the node: geth --datadir data init data/genesis.json","title":"5. Initialize nodes"},{"location":"tutorials/private-network/create-ibft-network/#6-start-node-0","text":"In the Node-0 directory, start the first node: export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22000 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32000 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30300 The PRIVATE_CONFIG environment variable starts GoQuorum without privacy enabled.","title":"6. Start node 0"},{"location":"tutorials/private-network/create-ibft-network/#7-start-nodes-1-2-3-and-4","text":"In a new terminal for each node in each node directory, start the remaining nodes using the same command except specifying different ports for DevP2P and RPC. Important The DevP2P port numbers must match the port numbers in static-nodes.json . Node 1 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22001 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32001 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30301 Node 2 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22002 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32002 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30302 Node 3 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22003 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32003 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30303 Node 4 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22004 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32004 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30304","title":"7. Start nodes 1, 2, 3, and 4"},{"location":"tutorials/private-network/create-ibft-network/#8-attach-to-node-0","text":"In another terminal in the Node-0 directory, attach to node 0: geth attach data/geth.ipc","title":"8. Attach to node 0"},{"location":"tutorials/private-network/create-ibft-network/#9-check-peer-count","text":"Use the JavaScript console to check the peer count: Command net.peerCount Result 4 Tip If the peer count is 0, check that static-nodes.json was updated with the correct port numbers and copied to the data directory for each node . The enode ID displayed in the logs on startup must match the enode listed in static-nodes.json for each node, including the port number specified using --port on startup . The log message is: INFO [12-08|10:44:55.044] Started P2P networking self=\"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30301?discport=0\"","title":"9. Check peer count"},{"location":"tutorials/private-network/create-ibft-network/#10-list-current-validators","text":"Use istanbul.getValidators to view the validator addresses. Command istanbul.getValidators ( \"latest\" ) Result [ \"e1a8d6a6866a6c8f25ed853e3f957b0ed06a8f1c\" , \"6028d68da1df3c54d5f0949de6082fb69a7239d1\" , \"c1ed779faf6975399c5bdb90b40e2f324185bad0\" , \"6480d9bf06fc8ba9a0393976386e47a5c4f014de\" , \"da4d64ac5fea8aaf2943680241ce9ca4befed870\" ]","title":"10. List current validators"},{"location":"tutorials/private-network/create-ibft-network/#next-steps","text":"You can add and remove validators .","title":"Next steps"},{"location":"tutorials/private-network/create-qbft-network/","text":"Create a private network using the QBFT consensus protocol \u00b6 A private network provides a configurable network for testing. This tutorial walks you through creating an QBFT private network with five nodes. Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall. Prerequisites \u00b6 Node.js version 15 or later . GoQuorum . Ensure that PATH contains geth and bootnode . Tip GoQuorum is a fork of geth . GoQuorum uses the geth command to start GoQuorum nodes. Steps \u00b6 1. Create directories \u00b6 Create directories for your private network and five nodes. QBFT-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-1 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-2 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-3 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-4 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore 2. Run the Quorum Genesis Tool \u00b6 Run the Quorum Genesis Tool interactively or by using CLI options. The following example uses CLI options to create the genesis file and node keys: npx quorum-genesis-tool --consensus qbft --chainID 1337 --blockperiod 5 --requestTimeout 10 --epochLength 30000 --difficulty 1 --gasLimit '0xFFFFFF' --coinbase '0x0000000000000000000000000000000000000000' --validators 5 --members 0 --bootnodes 0 --outputPath 'artifacts' Node keys for five nodes, along with static-nodes.json , permissioned-nodes.json , disallowed-nodes.json , and genesis.json are generated. output Need to install the following packages: quorum-genesis-tool Ok to proceed? ( y ) y Creating bootnodes... Creating members... Creating validators... Artifacts in folder: artifacts/2022-02-23-12-34-35 The following is the folder structure of the artifacts generated: QBFT-Network \u251c\u2500\u2500 artifacts \u2514\u2500\u25002022-02-23-12-34-35 \u251c\u2500\u2500 goQuorum \u2502 \u251c\u2500\u2500 disallowed-nodes.json \u2502 \u251c\u2500\u2500 genesis.json \u2502 \u251c\u2500\u2500 permissioned-nodes.json \u2502 \u2514\u2500\u2500 static-nodes.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 userData.json \u251c\u2500\u2500 validator0 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator1 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator2 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator3 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u2514\u2500\u2500 validator4 \u251c\u2500\u2500 accountAddress \u251c\u2500\u2500 accountKeystore \u251c\u2500\u2500 accountPassword \u251c\u2500\u2500 accountPrivateKey \u251c\u2500\u2500 address \u251c\u2500\u2500 nodekey \u2514\u2500\u2500 nodekey.pub Move all the keys into the artifacts folder directly, for ease of use in the next steps: cd QBFT-Network mv artifacts/2022-02-23-12-34-35/* artifacts 3. Update IP and port numbers \u00b6 Go to the goQuorum directory of the artifacts: cd artifacts/goQuorum Update the IP and port numbers for all initial validator nodes in static-nodes.json and permissioned-nodes.json (if applicable). static-nodes.json [ \"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30300?discport=0&raftport=53000\" , \"enode://0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c@127.0.0.1:30301?discport=0&raftport=53001\" , \"enode://d40a766cb6fe75f052fe21f61bc84ca3851abb6f999d73f97dd76e14fc2dea175d4cf554ccbcc2c7c639a0901932775b523554cb73facdfab08def975208f8e6@127.0.0.1:30302?discport=0&raftport=53002\" , \"enode://80a98f66d243c6604cda0e1c722eed3d9e080591c81710eec70794e0909e58661f4863e29a7a63bf7fb9387afc8609df37bacbf3d5c523d97bf598c3470840f5@127.0.0.1:30303?discport=0&raftport=53003\" , \"enode://7fa183662285993efaf7a59e303ec5543bbcd09cb2883e7611d9576ed90f3bcf0400b70af11c5266e5110eebe8afd4e817437bde574d686f440df1ec85822add@127.0.0.1:30304?discport=0&raftport=53004\" ] 4. Copy the static nodes file and node keys to each node \u00b6 Copy static-nodes.json , genesis.json , and permissioned-nodes.json (if applicable) to the data directory for each node: cp static-nodes.json genesis.json ./../Node-0/data/ cp static-nodes.json genesis.json ./../Node-1/data/ cp static-nodes.json genesis.json ./../Node-2/data/ cp static-nodes.json genesis.json ./../Node-3/data/ cp static-nodes.json genesis.json ./../Node-4/data/ In each validator directory, copy the nodekey files and address to the data directory: cp nodekey* address ../../Node-0/data cp nodekey* address ../../Node-1/data cp nodekey* address ../../Node-2/data cp nodekey* address ../../Node-3/data cp nodekey* address ../../Node-4/data Copy the individual account keys to the keystore directory for each node: cp account* ../../Node-0/data/keystore cp account* ../../Node-1/data/keystore cp account* ../../Node-2/data/keystore cp account* ../../Node-3/data/keystore cp account* ../../Node-4/data/keystore 5. Initialize nodes \u00b6 In each node directory ( Node-0 , Node-1 , Node-2 , Node-3 , and Node-4 ), initialize the node: geth --datadir data init data/genesis.json 6. Start node 0 \u00b6 In the Node-0 directory, start the first node: export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22000 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32000 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30300 The PRIVATE_CONFIG environment variable starts GoQuorum without privacy enabled. 7. Start nodes 1, 2, 3, and 4 \u00b6 In a new terminal for each node in each node directory, start the remaining nodes using the same command except specifying different ports for DevP2P and RPC. Important The DevP2P port numbers must match the port numbers in static-nodes.json . Node 1 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22001 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32001 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30301 Node 2 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints --http --http.addr 127 .0.0.1 --http.port 22002 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32002 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30302 Node 3 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22003 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32003 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30303 Node 4 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22004 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32004 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30304 8. Attach to node 0 \u00b6 In another terminal in the Node-0 directory, attach to node 0: geth attach data/geth.ipc 9. Check peer count \u00b6 Use the JavaScript console to check the peer count: Command net.peerCount Result 4 Tip If the peer count is 0, check the static-nodes.json was updated with the correct port numbers and copied to the data directory for each node . The enode ID displayed in the logs on startup must match the enode listed in static-nodes.json for each node including the port number specified using --port on startup . The log message is: INFO [12-08|10:44:55.044] Started P2P networking self=\"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30301?discport=0\" 10. List current validators \u00b6 Use istanbul.getValidators to view the validator addresses. Command istanbul.getValidators ( \"latest\" ) Result [ \"e1a8d6a6866a6c8f25ed853e3f957b0ed06a8f1c\" , \"6028d68da1df3c54d5f0949de6082fb69a7239d1\" , \"c1ed779faf6975399c5bdb90b40e2f324185bad0\" , \"6480d9bf06fc8ba9a0393976386e47a5c4f014de\" , \"da4d64ac5fea8aaf2943680241ce9ca4befed870\" ] Next steps \u00b6 You can add and remove validators .","title":"Use QBFT"},{"location":"tutorials/private-network/create-qbft-network/#create-a-private-network-using-the-qbft-consensus-protocol","text":"A private network provides a configurable network for testing. This tutorial walks you through creating an QBFT private network with five nodes. Important The steps in this tutorial create an isolated, but not protected or secure, Ethereum private network. We recommend running the private network behind a properly configured firewall.","title":"Create a private network using the QBFT consensus protocol"},{"location":"tutorials/private-network/create-qbft-network/#prerequisites","text":"Node.js version 15 or later . GoQuorum . Ensure that PATH contains geth and bootnode . Tip GoQuorum is a fork of geth . GoQuorum uses the geth command to start GoQuorum nodes.","title":"Prerequisites"},{"location":"tutorials/private-network/create-qbft-network/#steps","text":"","title":"Steps"},{"location":"tutorials/private-network/create-qbft-network/#1-create-directories","text":"Create directories for your private network and five nodes. QBFT-Network/ \u251c\u2500\u2500 Node-0 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-1 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-2 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-3 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore \u251c\u2500\u2500 Node-4 \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 keystore","title":"1. Create directories"},{"location":"tutorials/private-network/create-qbft-network/#2-run-the-quorum-genesis-tool","text":"Run the Quorum Genesis Tool interactively or by using CLI options. The following example uses CLI options to create the genesis file and node keys: npx quorum-genesis-tool --consensus qbft --chainID 1337 --blockperiod 5 --requestTimeout 10 --epochLength 30000 --difficulty 1 --gasLimit '0xFFFFFF' --coinbase '0x0000000000000000000000000000000000000000' --validators 5 --members 0 --bootnodes 0 --outputPath 'artifacts' Node keys for five nodes, along with static-nodes.json , permissioned-nodes.json , disallowed-nodes.json , and genesis.json are generated. output Need to install the following packages: quorum-genesis-tool Ok to proceed? ( y ) y Creating bootnodes... Creating members... Creating validators... Artifacts in folder: artifacts/2022-02-23-12-34-35 The following is the folder structure of the artifacts generated: QBFT-Network \u251c\u2500\u2500 artifacts \u2514\u2500\u25002022-02-23-12-34-35 \u251c\u2500\u2500 goQuorum \u2502 \u251c\u2500\u2500 disallowed-nodes.json \u2502 \u251c\u2500\u2500 genesis.json \u2502 \u251c\u2500\u2500 permissioned-nodes.json \u2502 \u2514\u2500\u2500 static-nodes.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 userData.json \u251c\u2500\u2500 validator0 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator1 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator2 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u251c\u2500\u2500 validator3 \u2502 \u251c\u2500\u2500 accountAddress \u2502 \u251c\u2500\u2500 accountKeystore \u2502 \u251c\u2500\u2500 accountPassword \u2502 \u251c\u2500\u2500 accountPrivateKey \u2502 \u251c\u2500\u2500 address \u2502 \u251c\u2500\u2500 nodekey \u2502 \u2514\u2500\u2500 nodekey.pub \u2514\u2500\u2500 validator4 \u251c\u2500\u2500 accountAddress \u251c\u2500\u2500 accountKeystore \u251c\u2500\u2500 accountPassword \u251c\u2500\u2500 accountPrivateKey \u251c\u2500\u2500 address \u251c\u2500\u2500 nodekey \u2514\u2500\u2500 nodekey.pub Move all the keys into the artifacts folder directly, for ease of use in the next steps: cd QBFT-Network mv artifacts/2022-02-23-12-34-35/* artifacts","title":"2. Run the Quorum Genesis Tool"},{"location":"tutorials/private-network/create-qbft-network/#3-update-ip-and-port-numbers","text":"Go to the goQuorum directory of the artifacts: cd artifacts/goQuorum Update the IP and port numbers for all initial validator nodes in static-nodes.json and permissioned-nodes.json (if applicable). static-nodes.json [ \"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30300?discport=0&raftport=53000\" , \"enode://0e6f7fff39188535b6084fa57fe0277d022a4beb988924bbb58087a43dd24f5feb78ca9d1cd880e26dd5162b8d331eeffee777386a4ab181528b3817fa39652c@127.0.0.1:30301?discport=0&raftport=53001\" , \"enode://d40a766cb6fe75f052fe21f61bc84ca3851abb6f999d73f97dd76e14fc2dea175d4cf554ccbcc2c7c639a0901932775b523554cb73facdfab08def975208f8e6@127.0.0.1:30302?discport=0&raftport=53002\" , \"enode://80a98f66d243c6604cda0e1c722eed3d9e080591c81710eec70794e0909e58661f4863e29a7a63bf7fb9387afc8609df37bacbf3d5c523d97bf598c3470840f5@127.0.0.1:30303?discport=0&raftport=53003\" , \"enode://7fa183662285993efaf7a59e303ec5543bbcd09cb2883e7611d9576ed90f3bcf0400b70af11c5266e5110eebe8afd4e817437bde574d686f440df1ec85822add@127.0.0.1:30304?discport=0&raftport=53004\" ]","title":"3. Update IP and port numbers"},{"location":"tutorials/private-network/create-qbft-network/#4-copy-the-static-nodes-file-and-node-keys-to-each-node","text":"Copy static-nodes.json , genesis.json , and permissioned-nodes.json (if applicable) to the data directory for each node: cp static-nodes.json genesis.json ./../Node-0/data/ cp static-nodes.json genesis.json ./../Node-1/data/ cp static-nodes.json genesis.json ./../Node-2/data/ cp static-nodes.json genesis.json ./../Node-3/data/ cp static-nodes.json genesis.json ./../Node-4/data/ In each validator directory, copy the nodekey files and address to the data directory: cp nodekey* address ../../Node-0/data cp nodekey* address ../../Node-1/data cp nodekey* address ../../Node-2/data cp nodekey* address ../../Node-3/data cp nodekey* address ../../Node-4/data Copy the individual account keys to the keystore directory for each node: cp account* ../../Node-0/data/keystore cp account* ../../Node-1/data/keystore cp account* ../../Node-2/data/keystore cp account* ../../Node-3/data/keystore cp account* ../../Node-4/data/keystore","title":"4. Copy the static nodes file and node keys to each node"},{"location":"tutorials/private-network/create-qbft-network/#5-initialize-nodes","text":"In each node directory ( Node-0 , Node-1 , Node-2 , Node-3 , and Node-4 ), initialize the node: geth --datadir data init data/genesis.json","title":"5. Initialize nodes"},{"location":"tutorials/private-network/create-qbft-network/#6-start-node-0","text":"In the Node-0 directory, start the first node: export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22000 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32000 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30300 The PRIVATE_CONFIG environment variable starts GoQuorum without privacy enabled.","title":"6. Start node 0"},{"location":"tutorials/private-network/create-qbft-network/#7-start-nodes-1-2-3-and-4","text":"In a new terminal for each node in each node directory, start the remaining nodes using the same command except specifying different ports for DevP2P and RPC. Important The DevP2P port numbers must match the port numbers in static-nodes.json . Node 1 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22001 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32001 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30301 Node 2 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints --http --http.addr 127 .0.0.1 --http.port 22002 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32002 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30302 Node 3 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22003 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32003 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30303 Node 4 export ADDRESS = $( grep -o '\"address\": *\"[^\"]*\"' ./data/keystore/accountKeystore | grep -o '\"[^\"]*\"$' | sed 's/\"//g' ) export PRIVATE_CONFIG = ignore geth --datadir data \\ --networkid 1337 --nodiscover --verbosity 5 \\ --syncmode full --nousb \\ --istanbul.blockperiod 5 --mine --miner.threads 1 --miner.gasprice 0 --emitcheckpoints \\ --http --http.addr 127 .0.0.1 --http.port 22004 --http.corsdomain \"*\" --http.vhosts \"*\" \\ --ws --ws.addr 127 .0.0.1 --ws.port 32004 --ws.origins \"*\" \\ --http.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --ws.api admin,trace,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul,qbft \\ --unlock ${ ADDRESS } --allow-insecure-unlock --password ./data/keystore/accountPassword \\ --port 30304","title":"7. Start nodes 1, 2, 3, and 4"},{"location":"tutorials/private-network/create-qbft-network/#8-attach-to-node-0","text":"In another terminal in the Node-0 directory, attach to node 0: geth attach data/geth.ipc","title":"8. Attach to node 0"},{"location":"tutorials/private-network/create-qbft-network/#9-check-peer-count","text":"Use the JavaScript console to check the peer count: Command net.peerCount Result 4 Tip If the peer count is 0, check the static-nodes.json was updated with the correct port numbers and copied to the data directory for each node . The enode ID displayed in the logs on startup must match the enode listed in static-nodes.json for each node including the port number specified using --port on startup . The log message is: INFO [12-08|10:44:55.044] Started P2P networking self=\"enode://1647ade9de728630faff2a69d81b2071eac873d776bfdf012b1b9e7e9ae1ea56328e79e34b24b496722412f4348b9aecaf2fd203fa56772a1a5dcdaa4a550147@127.0.0.1:30301?discport=0\"","title":"9. Check peer count"},{"location":"tutorials/private-network/create-qbft-network/#10-list-current-validators","text":"Use istanbul.getValidators to view the validator addresses. Command istanbul.getValidators ( \"latest\" ) Result [ \"e1a8d6a6866a6c8f25ed853e3f957b0ed06a8f1c\" , \"6028d68da1df3c54d5f0949de6082fb69a7239d1\" , \"c1ed779faf6975399c5bdb90b40e2f324185bad0\" , \"6480d9bf06fc8ba9a0393976386e47a5c4f014de\" , \"da4d64ac5fea8aaf2943680241ce9ca4befed870\" ]","title":"10. List current validators"},{"location":"tutorials/private-network/create-qbft-network/#next-steps","text":"You can add and remove validators .","title":"Next steps"},{"location":"tutorials/quorum-dev-quickstart/","text":"Get started with Quorum Developer Quickstart \u00b6 The Quorum Developer Quickstart is a command line tool that allows users to set up a development GoQuorum network on their local machine in less than two minutes. The quickstart is written in Javascript and designed to be run as a global npm module from the command line. Prerequisites \u00b6 Node.js and NPM version 14 or higher Docker and Docker-compose Truffle development framework curl command line MetaMask Run Quorum Developer Quickstart \u00b6 To run the quickstart without installation, use npx : npx quorum-dev-quickstart You can also install the quickstart globally with npm : npm install -g quorum-dev-quickstart # Once the global module is installed, run: quorum-dev-quickstart Note Many npm installations don\u2019t have permission to install global modules and will throw an EACCES error. npm has a recommended solution . Options \u00b6 You can provide these flags when running quorum-dev-quickstart : Flag Required to skip prompt Description --clientType=<STRING> Yes Use quorum for GoQuorum. --privacy=<true|false> Yes Enables or disables private transaction support. --orchestrate=<true|false> No Enables support for ConsenSys Orchestrate . --monitoring=<STRING> No Use default for Prometheus, Grafana, elk to add ELK; splunk to add Splunk. --outputPath=<PATH> No Path to output artifacts. -h , --help No Show help. Interacting with the network \u00b6 To explore the features of GoQuorum, such as permissioning and privacy, follow the Quorum Developer Quickstart tutorial . The tutorial also has information on smart contracts, dapps, wallets, and monitoring the network. Tools \u00b6 The quickstart provides the option to deploy monitoring tools alongside your network. You can use: Prometheus and Grafana to collect and visualize metrics. Cakeshop to explore the chain, work with contracts, and manage peers and permissions. Quorum Reporting to inspect contracts. Elastic Stack to manage logs. Splunk to manage logs. Developing \u00b6 Clone the repo to your local machine: git clone https://github.com/ConsenSys/quorum-dev-quickstart.git Change into the quickstart directory: cd quorum-dev-quickstart Install all dependencies: npm install Build changes to any files in the src directory and output to a build directory: npm run build Run the updated quickstart: npm run start Alternatively, you can run node build/index.js . Contributing \u00b6 Quorum Dev Quickstart is open source, and we invite you to contribute enhancements. You will be required to complete a Contributor License Agreement (CLA) before we are able to merge. If you have any questions about the contribution process, you can get them answered on the GoQuorum community support . Getting help \u00b6 Stuck on a step? Please join the GoQuorum community support .","title":"Get started with Quorum Developer Quickstart"},{"location":"tutorials/quorum-dev-quickstart/#get-started-with-quorum-developer-quickstart","text":"The Quorum Developer Quickstart is a command line tool that allows users to set up a development GoQuorum network on their local machine in less than two minutes. The quickstart is written in Javascript and designed to be run as a global npm module from the command line.","title":"Get started with Quorum Developer Quickstart"},{"location":"tutorials/quorum-dev-quickstart/#prerequisites","text":"Node.js and NPM version 14 or higher Docker and Docker-compose Truffle development framework curl command line MetaMask","title":"Prerequisites"},{"location":"tutorials/quorum-dev-quickstart/#run-quorum-developer-quickstart","text":"To run the quickstart without installation, use npx : npx quorum-dev-quickstart You can also install the quickstart globally with npm : npm install -g quorum-dev-quickstart # Once the global module is installed, run: quorum-dev-quickstart Note Many npm installations don\u2019t have permission to install global modules and will throw an EACCES error. npm has a recommended solution .","title":"Run Quorum Developer Quickstart"},{"location":"tutorials/quorum-dev-quickstart/#options","text":"You can provide these flags when running quorum-dev-quickstart : Flag Required to skip prompt Description --clientType=<STRING> Yes Use quorum for GoQuorum. --privacy=<true|false> Yes Enables or disables private transaction support. --orchestrate=<true|false> No Enables support for ConsenSys Orchestrate . --monitoring=<STRING> No Use default for Prometheus, Grafana, elk to add ELK; splunk to add Splunk. --outputPath=<PATH> No Path to output artifacts. -h , --help No Show help.","title":"Options"},{"location":"tutorials/quorum-dev-quickstart/#interacting-with-the-network","text":"To explore the features of GoQuorum, such as permissioning and privacy, follow the Quorum Developer Quickstart tutorial . The tutorial also has information on smart contracts, dapps, wallets, and monitoring the network.","title":"Interacting with the network"},{"location":"tutorials/quorum-dev-quickstart/#tools","text":"The quickstart provides the option to deploy monitoring tools alongside your network. You can use: Prometheus and Grafana to collect and visualize metrics. Cakeshop to explore the chain, work with contracts, and manage peers and permissions. Quorum Reporting to inspect contracts. Elastic Stack to manage logs. Splunk to manage logs.","title":"Tools"},{"location":"tutorials/quorum-dev-quickstart/#developing","text":"Clone the repo to your local machine: git clone https://github.com/ConsenSys/quorum-dev-quickstart.git Change into the quickstart directory: cd quorum-dev-quickstart Install all dependencies: npm install Build changes to any files in the src directory and output to a build directory: npm run build Run the updated quickstart: npm run start Alternatively, you can run node build/index.js .","title":"Developing"},{"location":"tutorials/quorum-dev-quickstart/#contributing","text":"Quorum Dev Quickstart is open source, and we invite you to contribute enhancements. You will be required to complete a Contributor License Agreement (CLA) before we are able to merge. If you have any questions about the contribution process, you can get them answered on the GoQuorum community support .","title":"Contributing"},{"location":"tutorials/quorum-dev-quickstart/#getting-help","text":"Stuck on a step? Please join the GoQuorum community support .","title":"Getting help"},{"location":"tutorials/quorum-dev-quickstart/remix/","text":"GoQuorum plugin for Remix \u00b6 The GoQuorum plugin for Ethereum\u2019s Remix IDE adds support for creating and interacting with private contracts on a GoQuorum network. Using the Quorum plugin for Remix \u00b6 Go to the Remix IDE . From the left menu select the Plugin manager tab, scroll down to Quorum Network , and Activate . Accept the permission to allow the plugin to retrieve compilation results. This allows the plugin to use the Solidity compiler to get the compiled contract binary to deploy to your GoQuorum node. The plugin should now be included in the icons on the left side. Click on the Quorum icon to show the plugin. Input the geth RPC URL and hit enter. If you are currently running the quorum-examples 7nodes network, the first node\u2019s URL is http://localhost:20000 . If the node is running, the plugin says Connected and the rest of the UI appears. The GoQuorum plugin uses results from Remix\u2019s Solidity compiler, so pull up some contract code and compile it as you normally would in Remix. The plugin will automatically receive the compiled code on each new compilation. Once you have a contract compiled, it will automatically be selected in the Compiled Contracts dropdown. Input any constructor values and deploy. If successful, the contract will show up in a collapsed view under Deployed Contracts . Click the caret to expand. From here you can call methods on the contract. To create a private contract, add your Tessera public keys one at a time to the Private for multi-select box. Press enter after inputting each one to save and select. Add as many peers as you want, then deploy the contract again as in step 7. After deploying and expanding the new contract, you should see the public keys that you selected in the widget. Every method call will include the selected keys automatically. If you have any feedback or questions, please open a GitHub issue or reach out on the GoQuorum community support . Contributing \u00b6 The GoQuorum plugin for Remix is open source and you can contribute enhancements. Upon review of your changes you\u2019re required to complete a Contributor License Agreement (CLA) before merging. If you have any questions about the contribution process, please contact the Quorum support team .","title":"Remix"},{"location":"tutorials/quorum-dev-quickstart/remix/#goquorum-plugin-for-remix","text":"The GoQuorum plugin for Ethereum\u2019s Remix IDE adds support for creating and interacting with private contracts on a GoQuorum network.","title":"GoQuorum plugin for Remix"},{"location":"tutorials/quorum-dev-quickstart/remix/#using-the-quorum-plugin-for-remix","text":"Go to the Remix IDE . From the left menu select the Plugin manager tab, scroll down to Quorum Network , and Activate . Accept the permission to allow the plugin to retrieve compilation results. This allows the plugin to use the Solidity compiler to get the compiled contract binary to deploy to your GoQuorum node. The plugin should now be included in the icons on the left side. Click on the Quorum icon to show the plugin. Input the geth RPC URL and hit enter. If you are currently running the quorum-examples 7nodes network, the first node\u2019s URL is http://localhost:20000 . If the node is running, the plugin says Connected and the rest of the UI appears. The GoQuorum plugin uses results from Remix\u2019s Solidity compiler, so pull up some contract code and compile it as you normally would in Remix. The plugin will automatically receive the compiled code on each new compilation. Once you have a contract compiled, it will automatically be selected in the Compiled Contracts dropdown. Input any constructor values and deploy. If successful, the contract will show up in a collapsed view under Deployed Contracts . Click the caret to expand. From here you can call methods on the contract. To create a private contract, add your Tessera public keys one at a time to the Private for multi-select box. Press enter after inputting each one to save and select. Add as many peers as you want, then deploy the contract again as in step 7. After deploying and expanding the new contract, you should see the public keys that you selected in the widget. Every method call will include the selected keys automatically. If you have any feedback or questions, please open a GitHub issue or reach out on the GoQuorum community support .","title":"Using the Quorum plugin for Remix"},{"location":"tutorials/quorum-dev-quickstart/remix/#contributing","text":"The GoQuorum plugin for Remix is open source and you can contribute enhancements. Upon review of your changes you\u2019re required to complete a Contributor License Agreement (CLA) before merging. If you have any questions about the contribution process, please contact the Quorum support team .","title":"Contributing"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/","text":"Use Quorum Developer Quickstart \u00b6 The Quorum Developer Quickstart uses the GoQuorum Docker image to run a private IBFT network of GoQuorum nodes managed by Docker Compose. Important This tutorial runs a private network suitable for education or demonstration purposes and is not intended for running production networks. Prerequisites \u00b6 Node.js and NPM version 14 or higher Docker and Docker-compose Truffle development framework curl command line MetaMask Important Allow Docker up to 4G of memory or 6G if running the privacy examples. Refer to the Resources section in Docker for Mac and Docker Desktop for details. Generate the tutorial blockchain configuration files \u00b6 To create the tutorial docker-compose files and artifacts, run: npx quorum-dev-quickstart Follow the prompts displayed to run GoQuorum and logging with ELK . Enter n for Codefi Orchestrate and y for private transactions . Start the network \u00b6 To start the network, go to the installation directory ( quorum-test-network if you used the default value) and run: ./run.sh The script builds the Docker images, and runs the Docker containers. Four GoQuorum IBFT validator nodes and a non-validator node are created to simulate a base network. In addition, there are three member pairs (GoQuorum and Tessera sets) to simulate private nodes on the network. When execution is successfully finished, the process lists the available services: Services list ************************************* Quorum Dev Quickstart ************************************* ---------------------------------- List endpoints and services ---------------------------------- JSON-RPC HTTP service endpoint : http://localhost:8545 JSON-RPC WebSocket service endpoint : ws://localhost:8546 Web block explorer address : http://localhost:25000/ Prometheus address : http://localhost:9090/graph Cakeshop toolkit address : http://localhost:8999 Grafana address : http://localhost:3000/d/a1lVy7ycin9Yv/goquorum-overview?orgId=1&refresh=10s&from=now-30m&to=now&var-system=All For more information on the endpoints and services, refer to README.md in the installation directory. **************************************************************** Use the JSON-RPC HTTP service endpoint to access the RPC node service from your dapp or from cryptocurrency wallets such as MetaMask. Use the JSON-RPC WebSocket service endpoint to access the WebSocket node service from your dapp. Use the Web block explorer address to display the block explorer web application. Use the Prometheus address to access the Prometheus dashboard and monitor nodes and view metrics . Use the Grafana address to access the Grafana dashboard to monitor nodes and view metrics . Use the Kibana logs address to access and manage logs in Kibana . To display the list of endpoints again, run: ./list.sh Use a block explorer \u00b6 The quickstart supports a modified version of the Alethio Ethereum Lite Explorer and BlockScout . Alethio Ethereum Lite Explorer \u00b6 Access the Alethio Ethereum Lite Explorer at http://localhost:25000 as displayed when starting the private network. The block explorer displays a summary of the private network, indicating four peers. Click the block number to the right of Best Block to display the block details: You can explore blocks by clicking on the blocks under Bk on the left-hand side. You can search for a specific block, transaction hash, or address by clicking the in the top left-hand corner. BlockScout \u00b6 At the prompt Do you wish to enable support for monitoring your network with BlockScout? , enter Y to start BlockScout at http://localhost:26000 . Note BlockScout\u2019s Docker image is resource heavy when running. Ensure you have adequate CPU resources dedicated to the container. The quickstart BlockScout configuration is available as a reference for your own network. Monitor nodes with Prometheus and Grafana \u00b6 The sample network also includes Prometheus and Grafana monitoring tools to let you visualize node health and usage. You can directly access these tools from your browser at the addresses displayed in the endpoint list. Prometheus dashboard . Grafana dashboard . For more details on how to configure and use these tools for your own nodes, see our performances monitoring documentation , the Prometheus documentation and Grafana documentation . Run JSON-RPC requests \u00b6 You can run JSON-RPC requests on: HTTP with http://localhost:8545 . WebSockets with ws://localhost:8546 . Run with curl \u00b6 This tutorial uses curl to send JSON-RPC requests over HTTP. Request the node version \u00b6 Run the following command from the host shell: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":1}' -H 'Content-Type: application/json' http://localhost:8545 The result displays the client version of the running node: Result example { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"Geth/node5-istanbul/v1.9.20-stable-1d7926a1(quorum-v21.4.2)/linux-amd64/go1.15.5\" } Result explanation \"jsonrpc\" : \"2.0\" indicates that the JSON-RPC 2.0 spec format is used. \"id\" : 1 is the request identifier used to match the request and the response. This tutorial always uses 1. \"result\" contains the running GoQuorum information: v1.9.20-stable-1d7926a1 is the Geth build that has been used for GoQuorum quorum-v21.4.2 is the running GoQuorum version number. This may be different when you run this tutorial. linux-amd64 is the architecture used to build this version. go1.15.5 is the Go version used. This may be different when you run this tutorial. Successfully calling this method shows that you can connect to the nodes using JSON-RPC over HTTP. From here, you can walk through more interesting requests demonstrated in the rest of this section, or skip ahead to Create a transaction using MetaMask . Count the peers \u00b6 Peers are the other nodes connected to the node receiving the JSON-RPC request. Poll the peer count using net_peerCount : curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_peerCount\",\"params\":[],\"id\":1}' -H 'Content-Type: application/json' http://localhost:8545 The result indicates seven peers (our validators): { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x7\" } Request the most recent block number \u00b6 Call eth_blockNumber to retrieve the number of the most recently synchronized block: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' -H 'Content-Type: application/json' http://localhost:8545 The result indicates the highest block number synchronized on this node. { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x2a\" } Here the hexadecimal value 0x2a translates to decimal as 42 , the number of blocks received by the node so far, about two minutes after the new network started. Private transactions \u00b6 This example uses the web3.js library to make the API calls, creating three member nodes pairs (a GoQuorum node which has a corresponding Tessera node for privacy) that can be accessed using APIs on the following ports: Member1Quorum RPC: http://localhost:20000 Member1Tessera: http://localhost:9081 Member2Quorum RPC: http://localhost:20002 Member1Tessera: http://localhost:9082 Member3Quorum RPC: http://localhost:20004 Member1Tessera: http://localhost:9083 Navigate to the smart_contracts directory and deploy the private transaction: cd smart_contracts npm install node scripts/private_tx.js This deploys the contract and sends an arbitrary value ( 47 ) from Member1 to Member3 . Once done, it performs a read operation on the contract using the get function and the contract\u2019s ABI, at the address specified. It then performs a write operation using the set function and the contract\u2019s ABI, at the address and sets the value to 123 . Lastly, it performs a read operation on all three members to verify that this is private between Member1 and Member3 only, and you should see that only Member1 and Member3 return the result of 123 , and Member2 has an undefined value. node scripts/private_tx.js The transaction hash is: 0x4d796b2ccac109fc54006105df44c519341696fa88e004ce5c614239cb9f92a2 Address of transaction: 0x695Baaf717370fcBb42aB45CD83C531C27D79eF1 Use the smart contracts 'get' function to read the contract 's constructor initialized value .. Member1 obtained value at deployed contract is: 47 Use the smart contracts ' set ' function to update that value to 123 .. - from member1 to member3 Verify the private transaction is private by reading the value from all three members .. Member1 obtained value at deployed contract is: 123 Member3 obtained value at deployed contract is: 123 Member2 obtained value at deployed contract is: undefined Inspect the member nodes with geth attach \u00b6 You can inspect any of the GoQuorum nodes by using attach.sh to open the geth JavaScript console. Use a separate terminal window for each of Member1, Member2, and Member3. In each terminal, go to the main directory where docker-compose.yml is located, then: In terminal 1, run ./attach.sh 1 to attach to Member1. In terminal 2, run ./attach.sh 2 to attach to Member2. In terminal 3, run ./attach.sh 3 to attach to Member3. To view the private transaction, run the following command in one of the terminals: geth console request eth . getTransaction ( \"0x4d796b2ccac109fc54006105df44c519341696fa88e004ce5c614239cb9f92a2\" ); // replace with your transaction hash JSON result { blockHash : \"0x3d69d2eb2a50a96072c549805f0ba04ce364b68ef7c16cd0ddac8e6c184e599e\" , blockNumber : 823 , fr om : \"0xf0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\" , gas : 150050 , gasPrice : 0 , hash : \"0x4d796b2ccac109fc54006105df44c519341696fa88e004ce5c614239cb9f92a2\" , i n pu t : \"0xe619b9d1469c34735145be181a28d18c09b575ef1a8fdbdcb0fe3934c2de5a8c62814e93b087ee918cfa294a0023aa6d42ef360ccf4997f1b94ae1e6c9145a3a\" , n o n ce : 6 , r : \"0x2660131d78ccd80773e8094d9fbf7d030f9753ddb1496af5b12f643ba95f900b\" , s : \"0x50f3e787595b88e5738adba373971d61394c9710d1a0dbee7287d10085d2fef5\" , t o : null , transa c t io n I n dex : 0 , v : \"0x26\" , value : 0 } Note The v field value of \"0x25\" or \"0x26\" (37 or 38 in decimal) indicates this transaction has a private payload (input). Read the contract with get() \u00b6 For each of the three nodes, create a variable called address using the geth console, and assign to it the address of the contract created by Member1. The contract address can be found: In Member1\u2019s log file data/logs/1.log . Using eth.getTransactionReceipt(txHash) , where txHash is the hash printed to the terminal after sending the transaction. The contract address is found in the result parameter contractAddress . It is also printed in the terminal when the private transaction is processed. After identifying the contract address, run the following command in each terminal: var address = \"0x695Baaf717370fcBb42aB45CD83C531C27D79eF1\" ; // replace with your contract address Use eth.contract to define a contract class with the simpleStorage ABI definition in each terminal: var address = \"0x695baaf717370fcbb42ab45cd83c531c27d79ef1\" // replace with your address var abi = [{ \"constant\" : true , \"inputs\" : [], \"name\" : \"storedData\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"x\" , \"type\" : \"uint256\" }], \"name\" : \"set\" , \"outputs\" : [], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"get\" , \"outputs\" : [{ \"name\" : \"retVal\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"initVal\" , \"type\" : \"uint256\" }], \"type\" : \"constructor\" }]; var private = eth . contract ( abi ). at ( address ) The function calls are available on the contract instance, and you can call those methods on the contract. Get the value of the contract to confirm that only Member1 and Member3 can see the value. In terminal window 1 (Member1): private . get () 123 In terminal window 2 (Member2): private . get () undefined In terminal window 3 (Member3): private . get () 123 Member2 can\u2019t read the state. Look in smart_contracts/node scripts/private_tx.js to confirm that 123 was the value set when the contract was updated. Write to the contract with set() \u00b6 Have Member1 set the state to the value 200 and confirm that only Member1 and Member3 can view the new state. In terminal window 1 (Member1): # send to Member3 private . set ( 200 ,{ from : eth . accounts [ 0 ], privateFor : [ \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" ]}); \"0xacf293b491cccd1b99d0cfb08464a68791cc7b5bc14a9b6e4ff44b46889a8f70\" You can check the log files in data/logs/ to see each node validating the block with this new private transaction. Once the block containing the transaction is validated, you can check the state from each of the members. In terminal window 1 (Member1): private . get () 200 In terminal window 2 (Member2): private . get () undefined In terminal window 3 (Member3): private . get () 200 Member2 can\u2019t read the state. All nodes are validating the same blockchain of transactions, with the private transactions containing only a 512-bit hash in place of the transaction data, and only the parties to the private transactions can view and update the state of the private contracts. Use Remix \u00b6 You can connect your nodes to Remix by using the GoQuorum Plugin . Follow the instructions for activating the remix plugin in Getting Started , using the GoQuorum and Tessera URLs in the Private transactions section. Use Cakeshop \u00b6 Cakeshop allows you to perform transactions directly using the UI. Open http://localhost:8999 in your browser. Select the Contracts tab and Deploy the contract registry. Go to the Sandbox , select the SimpleStorage sample contract from the Contract Library, and deploy with Private For set to the second node\u2019s public key ( QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc= ). Return to the main Cakeshop page, go to the Contracts tab again, and you should be able to see the contract you just deployed. Interact with it from there, and switch between nodes using the dropdown in the top right corner of the page. Create a transaction using MetaMask \u00b6 You can use MetaMask to send a transaction on your private network. Open MetaMask and connect it to your private network RPC endpoint by selecting Localhost 8545 in the network list. Choose one of the following test accounts and import it into MetaMask by copying the corresponding private key . Security warning Do not use the test accounts on Ethereum Mainnet or any production network. The following accounts are test accounts and their private keys are publicly visible in this documentation and in publicly available source code. They are not secure and everyone can use them. Using test accounts on Ethereum Mainnet and production networks can lead to loss of funds and identity fraud. In this documentation, we only provide test accounts for ease of testing and learning purposes; never use them for other purposes. Always secure your Ethereum Mainnet and any production account properly. See for instance MyCrypto \u201cProtecting Yourself and Your Funds\u201d guide . Test Account 1 (address 0xfe3b557e8fb62b89f4916b721be55ceb828dbd73 ) Private key to copy : 0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63 Initial balance : 200 Eth (200000000000000000000 Wei) Test Account 2 (address 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 ) Private key to copy : 0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 Initial balance : 90000 Eth (90000000000000000000000 Wei) Test Account 3 (address 0xf17f52151EbEF6C7334FAD080c5704D77216b732 ) Private key to copy : 0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f Initial balance : 90000 Eth (90000000000000000000000 Wei) After importing an existing test account, create another test account from scratch to use as the recipient for a test Ether transaction. In MetaMask, select the new test account and copy its address . In the Block Explorer , search for the new test account by clicking on the and pasting the test account address into the search box. The new test account displays with a zero balance. Send test Ether from the first test account (containing test Ether) to the new test account (which has a zero balance). Tip You can use a zero gas price here as this private test network is a free gas network, but the maximum amount of gas that can be used (the gas limit) for a value transaction must be at least 21000. Refresh the Block Explorer page in your browser displaying the target test account. The updated balance reflects the transaction completed using MetaMask. Smart contract and dapp usage \u00b6 You can use a demo dapp called Pet Shop, provided by Truffle . The dapp runs a local website using Docker, and uses smart contracts deployed on the network. The directory created by quorum-dev-quickstart includes a dapps directory with a pet-shop subdirectory, which contains the source code for the dapp, including the smart contracts, website, and configurations to run this tutorial. With the blockchain running and MetaMask connected to Localhost 8545 , run the following command to start the Pet Shop dapp: cd dapps/pet-shop ./run_dapp.sh The script: Installs the dapp Node dependencies (you may see some warnings here, but it will not prevent the dapp from running). Compiles the contracts. Deploys the contracts to the blockchain. Runs the tests. Builds and runs a Docker image to serve the dapp website. ./run_dapp.sh example output Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /home/jfernandes/workspace/quorum-dev-quickstart/quorum-test-network/dapps/pet-shop/pet-shop-box/build/contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'quickstartWallet' > Network id: 1337 > Block gas limit: 700000000 (0x29b92700) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x98c7d7754cf11b2ba5a8aa676b1299720bca0668b00b91b9d223c059f5456144 > Blocks: 1 Seconds: 4 > contract address: 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0 > block number: 154 > block timestamp: 0x60f7ca69 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 90000 > gas used: 221555 (0x36173) > gas price: 0 gwei > value sent: 0 ETH > total cost: 0 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' -------------------- > transaction hash: 0xc38e10fd2078f331d6e0f8cf27f958fad8a8a02c9789680da53f39806e407332 > Blocks: 0 Seconds: 4 > contract address: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10 > block number: 156 > block timestamp: 0x60f7ca73 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 90000 > gas used: 239851 (0x3a8eb) > gas price: 0 gwei > value sent: 0 ETH > total cost: 0 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 ETH Summary ======= > Total deployments: 2 > Final cost: 0 ETH Using network 'quickstartWallet'. Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Using network 'quickstartWallet'. Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol TestAdoption \u2713 testUserCanAdoptPet (2071ms) \u2713 testGetAdopterAddressByPetId (6070ms) \u2713 testGetAdopterAddressByPetIdInArray (6077ms) 3 passing (37s) After these tests are successful, the script builds a container for the Pet Shop dapp and deploys it, binding it to port 3001 on your system. Sending build context to Docker daemon 411.5MB Step 1/5 : FROM node:12.14.1-stretch-slim 12.14.1-stretch-slim: Pulling from library/node 619014d83c02: Pull complete 8c5d9aed65fb: Pull complete aaabe8e9daf2: Pull complete f7567fa7b9f3: Pull complete a989ed5f800b: Pull complete Digest: sha256:59ac2f2c3a0c490d8424306032f9b638f5ea83327ffaf23c66490e0026d1a000 Status: Downloaded newer image for node:12.14.1-stretch-slim ---> 2f7e25ad14ea Step 2/5 : EXPOSE 3001 ---> Running in 3c818550ed02 Removing intermediate container 3c818550ed02 ---> 7839d0b263a2 Step 3/5 : WORKDIR /app ---> Running in be4c761044b5 Removing intermediate container be4c761044b5 ---> 1a6e6d161952 Step 4/5 : COPY . /app ---> f33c3b13bc5d Step 5/5 : CMD npm run dev ---> Running in f64911ca050f Removing intermediate container f64911ca050f ---> 16d28763e27b Successfully built 16d28763e27b Successfully tagged quorum-dev-quickstart_pet_shop:latest fdbefa105bee995c56c2be23e9912f943973462bfc0b37df610e7feb7be4ca86 In the browser where you have MetaMask enabled and one of the test accounts loaded, open a new tab and navigate to the Pet Shop dapp where you can adopt lovely pets (sorry, not for real, it\u2019s a demo). When you select Adopt , a MetaMask window pops up and requests your permission to continue with the transaction. After the transaction is complete and successful, the status of the pet you adopted shows Success . You can also search for the transaction and view its details in the Block Explorer . The MetaMask UI also keeps a record of the transaction. Deploy your own dapp \u00b6 You can deploy your own dapp to the Quorum Developer Quickstart by configuring your dapp to point to the Quickstart network. If you\u2019re using Truffle , update the networks object in the Truffle configuration file to specify which networks to connect to for deployments and testing. The Quickstart\u2019s RPC service endpoint is http://localhost:8545 . For example, the following is the Truffle configuration file for the Pet Shop dapp used in the Quickstart GoQuorum network: const PrivateKeyProvider = require ( \"@truffle/hdwallet-provider\" ); // insert the private key of the account used in MetaMask, e.g. Account 1 (Miner Coinbase Account) const privateKey = \"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\" ; module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" // Match any network id }, develop : { port : 8545 }, quickstartWallet : { provider : () => new PrivateKeyProvider ( privateKey , \"http://localhost:8545\" ), network_id : \"*\" , type : \"quorum\" , gasPrice : 0 , chainId : 1337 } } }; Deploy the dapp using: truffle migrate --network quickstartWallet Stop and restart the private network without removing containers \u00b6 To shut down the private network without deleting the containers: Linux/MacOS ./stop.sh This command stops the containers related to the services specified in the docker-compose.yml file. To restart the private network: Linux/MacOS ./resume.sh Stop the private network and remove containers \u00b6 To shut down the private network and delete all containers and images created from running the sample network and the Pet Shop dapp: Linux/MacOS ./remove.sh Add a new node to the network \u00b6 New nodes joining an existing network require the following: The same genesis file used by all other nodes on the running network. A list of nodes to connect to; this is done by specifying bootnodes , or by providing a list of static nodes . A node key pair and optionally an account. If the running network is using permissions, then you need to add the new node\u2019s enode details to the permissions file used by existing nodes, or update the onchain permissioning contract. The following steps describe the process to add a new node to the Quorum Dev Quickstart. 1. Create the node key files \u00b6 Create a node key pair and account for a new node, by running the following script: cd ./extra npm install node generate_node_keys.js --password \"Password\" Note The --password parameter is optional. 2. Create new node directory \u00b6 In the config/nodes directory, create a subdirectory for the new node (for example, newnode ), and move the nodekey , nodekey.pub , address and accountkey files from the previous step into this directory. 3. Update docker-compose \u00b6 Add an entry for the new node into the docker-compose file: newnode : << : *quorum-def container_name : newnode ports : - 18545:8545/tcp - 18546:8546/tcp - 30303 - 9545 environment : - GOQUORUM_GENESIS_MODE=standard - PRIVATE_CONFIG=ignore volumes : - ./config/goquorum:/quorum - ./config/nodes/newnode:/config/keys - ./logs/quorum:/var/log/quorum/ networks : quorum-dev-quickstart : ipv4_address : 172.16.239.41 Important Select an IP address and port map that aren\u2019t being used for the other containers. Additionally mount the newly created folder ./config/nodes/newnode to the /config/keys directory of the new node. 4. Update files with the enode address \u00b6 Add the new node\u2019s enode address to the static nodes file and permissions file . The enode uses the format enode://pubkey@ip_address:30303?discport=0&raftport=53000 . where raftport is only required for the Raft consensus algorithm If the nodekey.pub is 4540ea...9c1d78 and the IP address is 172.16.239.41 , then the enode address would be \"enode://4540ea...9c1d78@172.16.239.41:30303?discport=0&raftport=53000\" , which must be added to both files. 5. Start the network \u00b6 Once complete, start the network up with ./run.sh On a live network the process is the same when using local permissions with the permissioned-nodes.json file. You don\u2019t need to restart the network and subsequent changes to the files are picked up by the servers. When using the smart contract you can either make changes via a dapp or via RPC API calls.","title":"Use the quickstart"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#use-quorum-developer-quickstart","text":"The Quorum Developer Quickstart uses the GoQuorum Docker image to run a private IBFT network of GoQuorum nodes managed by Docker Compose. Important This tutorial runs a private network suitable for education or demonstration purposes and is not intended for running production networks.","title":"Use Quorum Developer Quickstart"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#prerequisites","text":"Node.js and NPM version 14 or higher Docker and Docker-compose Truffle development framework curl command line MetaMask Important Allow Docker up to 4G of memory or 6G if running the privacy examples. Refer to the Resources section in Docker for Mac and Docker Desktop for details.","title":"Prerequisites"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#generate-the-tutorial-blockchain-configuration-files","text":"To create the tutorial docker-compose files and artifacts, run: npx quorum-dev-quickstart Follow the prompts displayed to run GoQuorum and logging with ELK . Enter n for Codefi Orchestrate and y for private transactions .","title":"Generate the tutorial blockchain configuration files"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#start-the-network","text":"To start the network, go to the installation directory ( quorum-test-network if you used the default value) and run: ./run.sh The script builds the Docker images, and runs the Docker containers. Four GoQuorum IBFT validator nodes and a non-validator node are created to simulate a base network. In addition, there are three member pairs (GoQuorum and Tessera sets) to simulate private nodes on the network. When execution is successfully finished, the process lists the available services: Services list ************************************* Quorum Dev Quickstart ************************************* ---------------------------------- List endpoints and services ---------------------------------- JSON-RPC HTTP service endpoint : http://localhost:8545 JSON-RPC WebSocket service endpoint : ws://localhost:8546 Web block explorer address : http://localhost:25000/ Prometheus address : http://localhost:9090/graph Cakeshop toolkit address : http://localhost:8999 Grafana address : http://localhost:3000/d/a1lVy7ycin9Yv/goquorum-overview?orgId=1&refresh=10s&from=now-30m&to=now&var-system=All For more information on the endpoints and services, refer to README.md in the installation directory. **************************************************************** Use the JSON-RPC HTTP service endpoint to access the RPC node service from your dapp or from cryptocurrency wallets such as MetaMask. Use the JSON-RPC WebSocket service endpoint to access the WebSocket node service from your dapp. Use the Web block explorer address to display the block explorer web application. Use the Prometheus address to access the Prometheus dashboard and monitor nodes and view metrics . Use the Grafana address to access the Grafana dashboard to monitor nodes and view metrics . Use the Kibana logs address to access and manage logs in Kibana . To display the list of endpoints again, run: ./list.sh","title":"Start the network"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#use-a-block-explorer","text":"The quickstart supports a modified version of the Alethio Ethereum Lite Explorer and BlockScout .","title":"Use a block explorer"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#alethio-ethereum-lite-explorer","text":"Access the Alethio Ethereum Lite Explorer at http://localhost:25000 as displayed when starting the private network. The block explorer displays a summary of the private network, indicating four peers. Click the block number to the right of Best Block to display the block details: You can explore blocks by clicking on the blocks under Bk on the left-hand side. You can search for a specific block, transaction hash, or address by clicking the in the top left-hand corner.","title":"Alethio Ethereum Lite Explorer"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#blockscout","text":"At the prompt Do you wish to enable support for monitoring your network with BlockScout? , enter Y to start BlockScout at http://localhost:26000 . Note BlockScout\u2019s Docker image is resource heavy when running. Ensure you have adequate CPU resources dedicated to the container. The quickstart BlockScout configuration is available as a reference for your own network.","title":"BlockScout"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#monitor-nodes-with-prometheus-and-grafana","text":"The sample network also includes Prometheus and Grafana monitoring tools to let you visualize node health and usage. You can directly access these tools from your browser at the addresses displayed in the endpoint list. Prometheus dashboard . Grafana dashboard . For more details on how to configure and use these tools for your own nodes, see our performances monitoring documentation , the Prometheus documentation and Grafana documentation .","title":"Monitor nodes with Prometheus and Grafana"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#run-json-rpc-requests","text":"You can run JSON-RPC requests on: HTTP with http://localhost:8545 . WebSockets with ws://localhost:8546 .","title":"Run JSON-RPC requests"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#run-with-curl","text":"This tutorial uses curl to send JSON-RPC requests over HTTP.","title":"Run with curl"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#request-the-node-version","text":"Run the following command from the host shell: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":1}' -H 'Content-Type: application/json' http://localhost:8545 The result displays the client version of the running node: Result example { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"Geth/node5-istanbul/v1.9.20-stable-1d7926a1(quorum-v21.4.2)/linux-amd64/go1.15.5\" } Result explanation \"jsonrpc\" : \"2.0\" indicates that the JSON-RPC 2.0 spec format is used. \"id\" : 1 is the request identifier used to match the request and the response. This tutorial always uses 1. \"result\" contains the running GoQuorum information: v1.9.20-stable-1d7926a1 is the Geth build that has been used for GoQuorum quorum-v21.4.2 is the running GoQuorum version number. This may be different when you run this tutorial. linux-amd64 is the architecture used to build this version. go1.15.5 is the Go version used. This may be different when you run this tutorial. Successfully calling this method shows that you can connect to the nodes using JSON-RPC over HTTP. From here, you can walk through more interesting requests demonstrated in the rest of this section, or skip ahead to Create a transaction using MetaMask .","title":"Request the node version"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#count-the-peers","text":"Peers are the other nodes connected to the node receiving the JSON-RPC request. Poll the peer count using net_peerCount : curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_peerCount\",\"params\":[],\"id\":1}' -H 'Content-Type: application/json' http://localhost:8545 The result indicates seven peers (our validators): { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x7\" }","title":"Count the peers"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#request-the-most-recent-block-number","text":"Call eth_blockNumber to retrieve the number of the most recently synchronized block: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' -H 'Content-Type: application/json' http://localhost:8545 The result indicates the highest block number synchronized on this node. { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x2a\" } Here the hexadecimal value 0x2a translates to decimal as 42 , the number of blocks received by the node so far, about two minutes after the new network started.","title":"Request the most recent block number"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#private-transactions","text":"This example uses the web3.js library to make the API calls, creating three member nodes pairs (a GoQuorum node which has a corresponding Tessera node for privacy) that can be accessed using APIs on the following ports: Member1Quorum RPC: http://localhost:20000 Member1Tessera: http://localhost:9081 Member2Quorum RPC: http://localhost:20002 Member1Tessera: http://localhost:9082 Member3Quorum RPC: http://localhost:20004 Member1Tessera: http://localhost:9083 Navigate to the smart_contracts directory and deploy the private transaction: cd smart_contracts npm install node scripts/private_tx.js This deploys the contract and sends an arbitrary value ( 47 ) from Member1 to Member3 . Once done, it performs a read operation on the contract using the get function and the contract\u2019s ABI, at the address specified. It then performs a write operation using the set function and the contract\u2019s ABI, at the address and sets the value to 123 . Lastly, it performs a read operation on all three members to verify that this is private between Member1 and Member3 only, and you should see that only Member1 and Member3 return the result of 123 , and Member2 has an undefined value. node scripts/private_tx.js The transaction hash is: 0x4d796b2ccac109fc54006105df44c519341696fa88e004ce5c614239cb9f92a2 Address of transaction: 0x695Baaf717370fcBb42aB45CD83C531C27D79eF1 Use the smart contracts 'get' function to read the contract 's constructor initialized value .. Member1 obtained value at deployed contract is: 47 Use the smart contracts ' set ' function to update that value to 123 .. - from member1 to member3 Verify the private transaction is private by reading the value from all three members .. Member1 obtained value at deployed contract is: 123 Member3 obtained value at deployed contract is: 123 Member2 obtained value at deployed contract is: undefined","title":"Private transactions"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#inspect-the-member-nodes-with-geth-attach","text":"You can inspect any of the GoQuorum nodes by using attach.sh to open the geth JavaScript console. Use a separate terminal window for each of Member1, Member2, and Member3. In each terminal, go to the main directory where docker-compose.yml is located, then: In terminal 1, run ./attach.sh 1 to attach to Member1. In terminal 2, run ./attach.sh 2 to attach to Member2. In terminal 3, run ./attach.sh 3 to attach to Member3. To view the private transaction, run the following command in one of the terminals: geth console request eth . getTransaction ( \"0x4d796b2ccac109fc54006105df44c519341696fa88e004ce5c614239cb9f92a2\" ); // replace with your transaction hash JSON result { blockHash : \"0x3d69d2eb2a50a96072c549805f0ba04ce364b68ef7c16cd0ddac8e6c184e599e\" , blockNumber : 823 , fr om : \"0xf0e2db6c8dc6c681bb5d6ad121a107f300e9b2b5\" , gas : 150050 , gasPrice : 0 , hash : \"0x4d796b2ccac109fc54006105df44c519341696fa88e004ce5c614239cb9f92a2\" , i n pu t : \"0xe619b9d1469c34735145be181a28d18c09b575ef1a8fdbdcb0fe3934c2de5a8c62814e93b087ee918cfa294a0023aa6d42ef360ccf4997f1b94ae1e6c9145a3a\" , n o n ce : 6 , r : \"0x2660131d78ccd80773e8094d9fbf7d030f9753ddb1496af5b12f643ba95f900b\" , s : \"0x50f3e787595b88e5738adba373971d61394c9710d1a0dbee7287d10085d2fef5\" , t o : null , transa c t io n I n dex : 0 , v : \"0x26\" , value : 0 } Note The v field value of \"0x25\" or \"0x26\" (37 or 38 in decimal) indicates this transaction has a private payload (input).","title":"Inspect the member nodes with geth attach"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#read-the-contract-with-get","text":"For each of the three nodes, create a variable called address using the geth console, and assign to it the address of the contract created by Member1. The contract address can be found: In Member1\u2019s log file data/logs/1.log . Using eth.getTransactionReceipt(txHash) , where txHash is the hash printed to the terminal after sending the transaction. The contract address is found in the result parameter contractAddress . It is also printed in the terminal when the private transaction is processed. After identifying the contract address, run the following command in each terminal: var address = \"0x695Baaf717370fcBb42aB45CD83C531C27D79eF1\" ; // replace with your contract address Use eth.contract to define a contract class with the simpleStorage ABI definition in each terminal: var address = \"0x695baaf717370fcbb42ab45cd83c531c27d79ef1\" // replace with your address var abi = [{ \"constant\" : true , \"inputs\" : [], \"name\" : \"storedData\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"x\" , \"type\" : \"uint256\" }], \"name\" : \"set\" , \"outputs\" : [], \"payable\" : false , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"get\" , \"outputs\" : [{ \"name\" : \"retVal\" , \"type\" : \"uint256\" }], \"payable\" : false , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"initVal\" , \"type\" : \"uint256\" }], \"type\" : \"constructor\" }]; var private = eth . contract ( abi ). at ( address ) The function calls are available on the contract instance, and you can call those methods on the contract. Get the value of the contract to confirm that only Member1 and Member3 can see the value. In terminal window 1 (Member1): private . get () 123 In terminal window 2 (Member2): private . get () undefined In terminal window 3 (Member3): private . get () 123 Member2 can\u2019t read the state. Look in smart_contracts/node scripts/private_tx.js to confirm that 123 was the value set when the contract was updated.","title":"Read the contract with get()"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#write-to-the-contract-with-set","text":"Have Member1 set the state to the value 200 and confirm that only Member1 and Member3 can view the new state. In terminal window 1 (Member1): # send to Member3 private . set ( 200 ,{ from : eth . accounts [ 0 ], privateFor : [ \"1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg=\" ]}); \"0xacf293b491cccd1b99d0cfb08464a68791cc7b5bc14a9b6e4ff44b46889a8f70\" You can check the log files in data/logs/ to see each node validating the block with this new private transaction. Once the block containing the transaction is validated, you can check the state from each of the members. In terminal window 1 (Member1): private . get () 200 In terminal window 2 (Member2): private . get () undefined In terminal window 3 (Member3): private . get () 200 Member2 can\u2019t read the state. All nodes are validating the same blockchain of transactions, with the private transactions containing only a 512-bit hash in place of the transaction data, and only the parties to the private transactions can view and update the state of the private contracts.","title":"Write to the contract with set()"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#use-remix","text":"You can connect your nodes to Remix by using the GoQuorum Plugin . Follow the instructions for activating the remix plugin in Getting Started , using the GoQuorum and Tessera URLs in the Private transactions section.","title":"Use Remix"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#use-cakeshop","text":"Cakeshop allows you to perform transactions directly using the UI. Open http://localhost:8999 in your browser. Select the Contracts tab and Deploy the contract registry. Go to the Sandbox , select the SimpleStorage sample contract from the Contract Library, and deploy with Private For set to the second node\u2019s public key ( QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc= ). Return to the main Cakeshop page, go to the Contracts tab again, and you should be able to see the contract you just deployed. Interact with it from there, and switch between nodes using the dropdown in the top right corner of the page.","title":"Use Cakeshop"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#create-a-transaction-using-metamask","text":"You can use MetaMask to send a transaction on your private network. Open MetaMask and connect it to your private network RPC endpoint by selecting Localhost 8545 in the network list. Choose one of the following test accounts and import it into MetaMask by copying the corresponding private key . Security warning Do not use the test accounts on Ethereum Mainnet or any production network. The following accounts are test accounts and their private keys are publicly visible in this documentation and in publicly available source code. They are not secure and everyone can use them. Using test accounts on Ethereum Mainnet and production networks can lead to loss of funds and identity fraud. In this documentation, we only provide test accounts for ease of testing and learning purposes; never use them for other purposes. Always secure your Ethereum Mainnet and any production account properly. See for instance MyCrypto \u201cProtecting Yourself and Your Funds\u201d guide . Test Account 1 (address 0xfe3b557e8fb62b89f4916b721be55ceb828dbd73 ) Private key to copy : 0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63 Initial balance : 200 Eth (200000000000000000000 Wei) Test Account 2 (address 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 ) Private key to copy : 0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 Initial balance : 90000 Eth (90000000000000000000000 Wei) Test Account 3 (address 0xf17f52151EbEF6C7334FAD080c5704D77216b732 ) Private key to copy : 0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f Initial balance : 90000 Eth (90000000000000000000000 Wei) After importing an existing test account, create another test account from scratch to use as the recipient for a test Ether transaction. In MetaMask, select the new test account and copy its address . In the Block Explorer , search for the new test account by clicking on the and pasting the test account address into the search box. The new test account displays with a zero balance. Send test Ether from the first test account (containing test Ether) to the new test account (which has a zero balance). Tip You can use a zero gas price here as this private test network is a free gas network, but the maximum amount of gas that can be used (the gas limit) for a value transaction must be at least 21000. Refresh the Block Explorer page in your browser displaying the target test account. The updated balance reflects the transaction completed using MetaMask.","title":"Create a transaction using MetaMask"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#smart-contract-and-dapp-usage","text":"You can use a demo dapp called Pet Shop, provided by Truffle . The dapp runs a local website using Docker, and uses smart contracts deployed on the network. The directory created by quorum-dev-quickstart includes a dapps directory with a pet-shop subdirectory, which contains the source code for the dapp, including the smart contracts, website, and configurations to run this tutorial. With the blockchain running and MetaMask connected to Localhost 8545 , run the following command to start the Pet Shop dapp: cd dapps/pet-shop ./run_dapp.sh The script: Installs the dapp Node dependencies (you may see some warnings here, but it will not prevent the dapp from running). Compiles the contracts. Deploys the contracts to the blockchain. Runs the tests. Builds and runs a Docker image to serve the dapp website. ./run_dapp.sh example output Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /home/jfernandes/workspace/quorum-dev-quickstart/quorum-test-network/dapps/pet-shop/pet-shop-box/build/contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'quickstartWallet' > Network id: 1337 > Block gas limit: 700000000 (0x29b92700) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x98c7d7754cf11b2ba5a8aa676b1299720bca0668b00b91b9d223c059f5456144 > Blocks: 1 Seconds: 4 > contract address: 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0 > block number: 154 > block timestamp: 0x60f7ca69 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 90000 > gas used: 221555 (0x36173) > gas price: 0 gwei > value sent: 0 ETH > total cost: 0 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' -------------------- > transaction hash: 0xc38e10fd2078f331d6e0f8cf27f958fad8a8a02c9789680da53f39806e407332 > Blocks: 0 Seconds: 4 > contract address: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10 > block number: 156 > block timestamp: 0x60f7ca73 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 90000 > gas used: 239851 (0x3a8eb) > gas price: 0 gwei > value sent: 0 ETH > total cost: 0 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 ETH Summary ======= > Total deployments: 2 > Final cost: 0 ETH Using network 'quickstartWallet'. Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Using network 'quickstartWallet'. Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol TestAdoption \u2713 testUserCanAdoptPet (2071ms) \u2713 testGetAdopterAddressByPetId (6070ms) \u2713 testGetAdopterAddressByPetIdInArray (6077ms) 3 passing (37s) After these tests are successful, the script builds a container for the Pet Shop dapp and deploys it, binding it to port 3001 on your system. Sending build context to Docker daemon 411.5MB Step 1/5 : FROM node:12.14.1-stretch-slim 12.14.1-stretch-slim: Pulling from library/node 619014d83c02: Pull complete 8c5d9aed65fb: Pull complete aaabe8e9daf2: Pull complete f7567fa7b9f3: Pull complete a989ed5f800b: Pull complete Digest: sha256:59ac2f2c3a0c490d8424306032f9b638f5ea83327ffaf23c66490e0026d1a000 Status: Downloaded newer image for node:12.14.1-stretch-slim ---> 2f7e25ad14ea Step 2/5 : EXPOSE 3001 ---> Running in 3c818550ed02 Removing intermediate container 3c818550ed02 ---> 7839d0b263a2 Step 3/5 : WORKDIR /app ---> Running in be4c761044b5 Removing intermediate container be4c761044b5 ---> 1a6e6d161952 Step 4/5 : COPY . /app ---> f33c3b13bc5d Step 5/5 : CMD npm run dev ---> Running in f64911ca050f Removing intermediate container f64911ca050f ---> 16d28763e27b Successfully built 16d28763e27b Successfully tagged quorum-dev-quickstart_pet_shop:latest fdbefa105bee995c56c2be23e9912f943973462bfc0b37df610e7feb7be4ca86 In the browser where you have MetaMask enabled and one of the test accounts loaded, open a new tab and navigate to the Pet Shop dapp where you can adopt lovely pets (sorry, not for real, it\u2019s a demo). When you select Adopt , a MetaMask window pops up and requests your permission to continue with the transaction. After the transaction is complete and successful, the status of the pet you adopted shows Success . You can also search for the transaction and view its details in the Block Explorer . The MetaMask UI also keeps a record of the transaction.","title":"Smart contract and dapp usage"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#deploy-your-own-dapp","text":"You can deploy your own dapp to the Quorum Developer Quickstart by configuring your dapp to point to the Quickstart network. If you\u2019re using Truffle , update the networks object in the Truffle configuration file to specify which networks to connect to for deployments and testing. The Quickstart\u2019s RPC service endpoint is http://localhost:8545 . For example, the following is the Truffle configuration file for the Pet Shop dapp used in the Quickstart GoQuorum network: const PrivateKeyProvider = require ( \"@truffle/hdwallet-provider\" ); // insert the private key of the account used in MetaMask, e.g. Account 1 (Miner Coinbase Account) const privateKey = \"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\" ; module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" // Match any network id }, develop : { port : 8545 }, quickstartWallet : { provider : () => new PrivateKeyProvider ( privateKey , \"http://localhost:8545\" ), network_id : \"*\" , type : \"quorum\" , gasPrice : 0 , chainId : 1337 } } }; Deploy the dapp using: truffle migrate --network quickstartWallet","title":"Deploy your own dapp"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#stop-and-restart-the-private-network-without-removing-containers","text":"To shut down the private network without deleting the containers: Linux/MacOS ./stop.sh This command stops the containers related to the services specified in the docker-compose.yml file. To restart the private network: Linux/MacOS ./resume.sh","title":"Stop and restart the private network without removing containers"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#stop-the-private-network-and-remove-containers","text":"To shut down the private network and delete all containers and images created from running the sample network and the Pet Shop dapp: Linux/MacOS ./remove.sh","title":"Stop the private network and remove containers"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#add-a-new-node-to-the-network","text":"New nodes joining an existing network require the following: The same genesis file used by all other nodes on the running network. A list of nodes to connect to; this is done by specifying bootnodes , or by providing a list of static nodes . A node key pair and optionally an account. If the running network is using permissions, then you need to add the new node\u2019s enode details to the permissions file used by existing nodes, or update the onchain permissioning contract. The following steps describe the process to add a new node to the Quorum Dev Quickstart.","title":"Add a new node to the network"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#1-create-the-node-key-files","text":"Create a node key pair and account for a new node, by running the following script: cd ./extra npm install node generate_node_keys.js --password \"Password\" Note The --password parameter is optional.","title":"1. Create the node key files"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#2-create-new-node-directory","text":"In the config/nodes directory, create a subdirectory for the new node (for example, newnode ), and move the nodekey , nodekey.pub , address and accountkey files from the previous step into this directory.","title":"2. Create new node directory"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#3-update-docker-compose","text":"Add an entry for the new node into the docker-compose file: newnode : << : *quorum-def container_name : newnode ports : - 18545:8545/tcp - 18546:8546/tcp - 30303 - 9545 environment : - GOQUORUM_GENESIS_MODE=standard - PRIVATE_CONFIG=ignore volumes : - ./config/goquorum:/quorum - ./config/nodes/newnode:/config/keys - ./logs/quorum:/var/log/quorum/ networks : quorum-dev-quickstart : ipv4_address : 172.16.239.41 Important Select an IP address and port map that aren\u2019t being used for the other containers. Additionally mount the newly created folder ./config/nodes/newnode to the /config/keys directory of the new node.","title":"3. Update docker-compose"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#4-update-files-with-the-enode-address","text":"Add the new node\u2019s enode address to the static nodes file and permissions file . The enode uses the format enode://pubkey@ip_address:30303?discport=0&raftport=53000 . where raftport is only required for the Raft consensus algorithm If the nodekey.pub is 4540ea...9c1d78 and the IP address is 172.16.239.41 , then the enode address would be \"enode://4540ea...9c1d78@172.16.239.41:30303?discport=0&raftport=53000\" , which must be added to both files.","title":"4. Update files with the enode address"},{"location":"tutorials/quorum-dev-quickstart/using-the-quickstart/#5-start-the-network","text":"Once complete, start the network up with ./run.sh On a live network the process is the same when using local permissions with the permissioned-nodes.json file. You don\u2019t need to restart the network and subsequent changes to the files are picked up by the servers. When using the smart contract you can either make changes via a dapp or via RPC API calls.","title":"5. Start the network"}]}